[{"title": "尊贵的 Tesla 车主 +1", "author": "林木木的博客", "pubDate": "2025-01-19 11:48:13", "link": "https://immmmm.com/hi-tesla-2025/", "description": "\n<p>上周 Model Y 焕新款终于官宣，细看了几分钟，旋即下了 Model 3 ，今日已成为“尊贵”的特斯拉车主。</p>\n<p>与之前的焕新款 3 相比：</p>\n<ul>\n<li>25年贵了3600</li>\n<li>电池增加到 62.5 度，原来是 60 度</li>\n<li>能以 ¥1299 购买赛博家用充电桩，原来要 ¥5200</li>\n</ul>\n<p>然后，若是旧车置换的话能试用 90 天的 EAP（增强版自动辅助驾驶）。</p>\n<h3>溜车三天杂记（1月23日）</h3>\n<h4>满电表显 458km，挺准</h4>\n<p>这几天市区道路+高架+高速累计已开 300km+，能耗在 137kw/h 。</p>\n<p>按照公式 62.5 度电 ÷ 137 能耗 x 1000 ≈ 456km，一次充电，满足一周上下班，够够的。</p>\n<p>家充 7kw，谷电 3 毛/度，一杯普通奶茶，一晚，满电。美滋滋。</p>\n<p>看别人发着，超充或第三方，50 几分钟可满电，算 2 元/度，一百来块钱，一小时，满电。还可以。</p>\n<h4>AP/EAP，上高架高速，好使</h4>\n<p>置换送了 90 天的 EAP，相比免费的 AP 多了“召唤”、“自动泊车”、“高速自动换道”和“高速自动进匝道”等。而 AP 只有车道保持，即“跟车”。</p>\n<p>虽然已落后国内的“智驾”，但其是纯视觉方案，想想，还是佩服！若经常高架高速，若 EAP 不是 3万2 而是 3千2，那还是非常值得开通的。</p>\n<p>有一点挺难受，两者都是保持车道居中，但很多人习惯于车道靠左一些，包括我自己。右侧是一辆大车且快贴着线时，感觉压力山大。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/01/IMG_8167.JPEG\" alt=\"\"></p>\n<h3>一人一车，磨合一小时</h3>\n<h4>优点</h4>\n<ul>\n<li>星空灰还对眼，既没有土灰的感觉，也没有纯黑那么刚硬的感觉。</li>\n<li>动力是杠杠的，没啥感觉没几秒就上了 80+ 码，找了找车机开启了超速“蜂鸣”提醒。</li>\n<li>隔音效果、车内震动优于预期，没有网上说的那么差。</li>\n<li>与 iOS 搭配，更可餐。锁屏、桌面、快捷小组件应有尽有。就等新系统推送，还能用 iWatch 控制。</li>\n</ul>\n<h4>缺点</h4>\n<ul>\n<li>新车味重，闻着晕。</li>\n<li>前排座位硬，怎么调都不舒服；后排空间小，做做小朋友还行。</li>\n<li>后车镜怎么调都难受，倒车拐弯盲区仍不少，没有 360 车身四周影像。</li>\n</ul>\n<h3>下单到提车，行云流水线</h3>\n<ul>\n<li>上周日晚 8 点，找了个客户经理，下定金 ¥1000。</li>\n<li>周一拉群，确认当地提车上牌，预计一周后（即今天）可提车。</li>\n<li>周二旧车置换官方合作方，上门验车估价签协议，立马收到 ¥1000 定金；虽老车已经符合报废补贴，但二手车估出来还值 1W1，这样加上后续的置换国补 1W5，比直接报废划算。</li>\n<li>同步，五年免息招行开启车贷申请流程。周三招行上门面签，周四贷款通过，同步 APP 里付了尾款 ¥79500，银行经理说贷个取个整 15W5，所以首付多付了些。</li>\n<li>同步，家用充电桩拉群，周三现场勘探后，确认方案。自己在国家电网上申请新电表，修改为新能源类型并开通峰谷电。</li>\n<li>周六，官方 App 内给车上好保险，选择周日也就是今天 0 点生效，太平洋保险基础套餐 ¥9013。</li>\n<li>今天，顺利提车，店内 0 消费，未延保，未买窗膜。</li>\n</ul>\n<h3>没日没夜，买了一堆软装</h3>\n<h4>山姆</h4>\n<ul>\n<li>腰靠、头靠两对 ¥245</li>\n</ul>\n<h4>YZ 牌</h4>\n<ul>\n<li>门槛条 4 件套 ¥156</li>\n<li>手套箱挂钩 ¥11.5</li>\n<li>通风口防尘网、后排空调出风口保护罩 ¥26.6</li>\n<li>后排空调下储物垃圾盒 ¥75.2</li>\n<li>中控储物收纳盒 ¥30</li>\n<li>补胎千斤顶支持 ¥20</li>\n<li>门锁保护扣 ¥15.7</li>\n<li>后排椅子下防踢垫板 ¥27.5</li>\n</ul>\n<h4>3M 牌</h4>\n<ul>\n<li>3M 屏下中控磁吸储物盒 ¥126</li>\n<li>3M 车头进风口防虫网 ¥109</li>\n</ul>\n<h4>小特叔叔车品</h4>\n<ul>\n<li>中控拓展坞，点烟器取电款 ¥108</li>\n<li>车门储物盒 x4，¥91.3</li>\n<li>碳纤纹车牌架 ¥70.2</li>\n<li>屏幕保护条 ¥8.3</li>\n<li>无线充软硅胶垫 ¥14.2</li>\n<li>后备箱垫 ¥63.7</li>\n<li>后备箱侧边储物盒 ¥54.4</li>\n</ul>\n<p>另外，买的刹车踏板扣到指甲开裂，仍安装失败，差评！还有中控水杯垫，毛胚就卡得够紧，多余。</p>\n<p>哦，找的客户经理私下送了脚垫，但还在路上。</p>\n<h3>感叹</h3>\n<p>副驾边的铭牌，生产日期 <code>2025年1月15日</code>，上周日 12 号晚下单，车子这周三下线，周日交付到车主手上。</p>\n<p>充值信仰，还看老马！</p>\n", "categories": ["%E6%97%A5%E5%B8%B8"], "time": 1737258493}, {"title": "浏览器插件推荐：AI Share Card 生成网页分享卡片", "author": "林木木的博客", "pubDate": "2025-01-06 15:17:22", "link": "https://immmmm.com/ai-share-card/", "description": "\n<p>一款 AI 网页分享卡片生成小工具，利用 AI 将网页内容一键转换为精美的分享卡片。</p>\n<p>真是万物皆可卡片，看到支持自定义模板，所以又折腾了一晚。</p>\n<p>但，好像也没啥大用…… 那就，玩呗～</p>\n<h3>上效果对比图（左为默认样式）</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.edui123.com/2025/01/Picsew_20250107195720.JPEG.webp\" alt=\"\"></p>\n<h3>自定义模版代码分享</h3>\n<p>两个 import 分别是来源 SVG 图标，自定义字体。</p>\n<pre tabindex=\"0\"><code>&lt;style&gt;\n@import url(https://r2.immmmm.com/via.css);\n@import url(https://static.zeoseven.com/zsft/7/main/result.css);\n.card{font-family:\"Zhuque Fangsong (technical preview)\"}\n\n.powered-by{visibility:hidden}\n.powered-by span{visibility:visible}\n#cardContainer,.card{width:380px!important}\n.card-wrapper{border-radius:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,.1),0 8px 10px -6px rgba(0,0,0,.1)}\n.card{font-weight:400;box-sizing:border-box;padding:28px;background:#fff;border-radius:20px}\n.header{color:#a6a6a6;height:24px;overflow:hidden}\n.product{font-style:italic}\n.product,h1.title{letter-spacing:.02em}\nh1.title{font-size:20px;font-weight:700;color:#2b2b2b;margin:4px 0 12px;line-height:1.5}\n.summary{background:#f8f9fc;padding:16px;border-radius:12px;margin-bottom:12px;font-size:15px;color:#2b2b2b;line-height:1.8;letter-spacing:.03em;box-shadow:inset 0 2px 4px 0 rgba(0,0,0,.06)}\n.points{margin-bottom:10px}\n.point{display:flex;align-items:flex-start;margin-top:12px;font-size:15px;color:#2b2b2b;padding:2px 0}\n.point:before{content:\"\";width:4px;height:4px;background:#287cf6;border-radius:50%;margin-top:10px;margin-right:6px;flex-shrink:0}\n.point:nth-last-child(-n+2){margin-right:100px}\n.qr-section{position:relative}\n#qrcode{width:76px;height:76px;border-radius:8px;padding:6px;background:#f8f9fc;border:1px solid #f5f5f5;position:absolute;bottom:0;right:0}\n#qrcode img{width:100%;height:100%;object-fit:contain}\n&lt;/style&gt;\n\n&lt;div class=\"card\"&gt;\n  &lt;div id=\"card-img\"&gt;&lt;/div&gt;\n  &lt;div class=\"header\"&gt;\n    &lt;span class=\"date\"&gt;{{DATE}} &lt;/span&gt; · &lt;span class=\"product\"&gt;{{QR_SUBTITLE}} &lt;/span&gt;\n  &lt;/div&gt;\n  &lt;h1 class=\"title\"&gt;{{TITLE}} &lt;span data-via=\"{{PLATFORM}}\"&gt;&lt;/span&gt;&lt;/h1&gt;\n  &lt;div class=\"summary\"&gt;\n    {{SUMMARY}}\n  &lt;/div&gt;\n  &lt;div class=\"points\"&gt;\n    {{#each POINTS}}\n    &lt;div class=\"point\"&gt;{{this}}&lt;/div&gt;\n    {{/each}}\n  &lt;/div&gt;\n  &lt;div class=\"qr-section\"&gt;\n    &lt;div id=\"qrcode\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt; \n</code></pre>\n<h3>相关站点记录</h3>\n<h4>官方介绍</h4>\n<ul>\n<li>主页 <a href=\"https://zkv549gmz8.feishu.cn/wiki/LPQEwSvUfiXgxckspzncGjOdnqe\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://zkv549gmz8.feishu.cn/wiki/LPQEwSvUfiXgxckspzncGjOdnqe</a>\n</li>\n<li>Chrome扩展 <a href=\"https://chromewebstore.google.com/detail/bfaolbpkelfmiijhdlcbflbpfpebepon\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://chromewebstore.google.com/detail/bfaolbpkelfmiijhdlcbflbpfpebepon</a>\n</li>\n</ul>\n<h4>来源 SVG 图标如下压缩：</h4>\n<ul>\n<li>获取图标 SVG 代码 <a href=\"https://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://www.iconfont.cn/</a>\n</li>\n<li>粘贴压缩并复制 <a href=\"https://jakearchibald.github.io/svgomg/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://jakearchibald.github.io/svgomg/</a>\n</li>\n<li>Encode 代码 <a href=\"https://meyerweb.com/eric/tools/dencoder/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://meyerweb.com/eric/tools/dencoder/</a>\n</li>\n</ul>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1736147842}, {"title": "2024年终总结", "author": "Redish101博客", "pubDate": "2024-12-30 16:00:00", "link": "https://blog.redish101.top/article/2024-summary", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://cdn.smartcis.cn/gh/redish101/cdn@src/img/postspark_export_2024-12-22_15-17-56.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412290927100.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291013292.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291018651.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741579.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741355.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291821543.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291929767.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291947480.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291953729.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292002652.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292004463.jpg\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/2024-summary\">https://blog.redish101.top/article/2024-summary</a>\n</blockquote>\n<div>\n<h2>2024年终总结及新年计划</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">2024年即将结束，在此总结一年中的功过荣辱以及值得记录或吐槽的事情、物品，并同时针对2025年进行总体规划。</p>\n<h2>博客</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度对博客进行了大规模，长时间（从冬天到夏天）的重构，从去年七月Next.js SSG的方案转为Go(Fiber) + Next.js的前后端分离方案，使自己的Go能力更上一部，尝试规模稍微复杂些的项目的流程。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">具体详尽内容见<a href=\"https://www.notion.so/16b0d19ec45680f4998cfdc9afac1cd7?pvs=21\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">博客重构</a> 。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">今年认识了一个与SpringBoot类似风格的nodejs服务端框架（nestjs），可惜没有早点遇到，轻笑推荐的好好用，早知道的话reblog就用nest写了。</p>\n<h2>编程</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度基本着重于对reblog的开发，但经过一年的长时间拖延，reblog整体依然处于较简陋的状态，来年将对reblog进行进一步的完善，为reblog新增如下功能（优先级递减）：</p>\n<ol start=\"1\">\n<li>标签与分类</li>\n<li>即刻（类似于说说功能）</li>\n<li>评论</li>\n<li>友情链接朋友圈（文章聚合订阅）</li>\n<li>内置的AI支持（摘要、问答）</li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">同时，将考虑使用nestjs重构retalk项目。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">来年将将更多经历投入到Acme Cloud Platform的开发上。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">截至本文完成时，Redish101共在GitHub上产生了1047次提交，相比2023年约增长622%。</p>\n<img src=\"https://cdn.smartcis.cn/gh/redish101/cdn@src/img/postspark_export_2024-12-22_15-17-56.png\" alt=\"https://cdn.smartcis.cn/gh/redish101/cdn@src/img/postspark_export_2024-12-22_15-17-56.png\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度共参与2个有效Pull Request：</p>\n<ol start=\"1\">\n<li><a href=\"https://github.com/umijs/umi/pull/12516\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">feat(create-umi): 为create-umi新增设置项目名称的步骤 #12516</a></li>\n<li><a href=\"https://github.com/gofiber/contrib/pull/1172\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">feat: Migrate Monitor Middleware #1172</a></li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">25年将着重对于以下领域的学习：</p>\n<ol start=\"1\">\n<li>Qt</li>\n<li>Nestjs</li>\n<li>OpenGL</li>\n<li>Vulkan</li>\n</ol>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">redish又在给自己挖坑了</p></blockquote>\n<h2>武汉</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">曾经出门的时候不止一次在火车上经过武汉，对于武昌火车站和长江大桥留下了深刻印象，再加上距离也不算很远，所以在24年二月初选择去武汉看看。</p>\n<h3>Day0</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">距离武汉并非十分遥远，便选择了乘火车（Z263硬座）前往。春节将至，凌晨三点钟的郑州站依旧灯火通明。列车缓缓驶出车站，前往武汉的旅途在窗外飞速后退的灯火旁拉开了帷幕。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">列车一路狂奔，天也蒙蒙亮了起来，但是天气似乎并不是十分晴朗，太阳在云层的遮挡下仅仅是撒下了些许白光。在无际的朦胧中，窗外的田野慢慢渐变到楼房。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">“前方到站——武昌站”。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412290927100.png\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412290927100.png\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">随着人流下了车，正式踏入武汉的地界。</p>\n<h3>Day1</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">走出武昌火车站，外面正下着朦胧的小雨，冒着小雨到了粮道街。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">热干面！</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">既然到了武汉肯定是要尝尝热干面的。热干面还是蛮合胃口的，筋道的面条裹挟着浓郁的浆汁，很是美味（<del>看似一小份不过似乎很容易吃饱</del>）。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">吃过饭，便来到了武汉最著名的景点之一——黄鹤楼。</p>\n<blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">昔人已乘黄鹤去，此地空余黄鹤楼。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">黄鹤一去不复返，白云千载空悠悠。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">晴川历历汉阳树，芳草萋萋鹦鹉洲。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">日暮乡关何处是？烟波江上使人愁。</p>\n</blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">古往今来，数不尽的人登上黄鹤楼，感慨万千，吟诗作赋，给这座楼增添了许多文化气息。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">逐层登上黄鹤楼，苍茫朦胧的景色扑面而来。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291013292.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291013292.jpeg\"><img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291018651.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291018651.jpeg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">下午去了辛亥革命纪念馆</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741579.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741579.jpeg\"><img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741355.jpg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741355.jpg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">天色渐渐暗下来了，毕竟凌晨就起床，又累又饿的，便匆匆回了酒店。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">坐车到酒店附近，已是天昏地暗，浑身疲软。摸了下口袋，身份证不翼而飞。猛地惊醒，趁着公交尚未离开，狂奔了回去，抱着一丝希望想要从车上找到，可惜无果。回到房间，给博物馆的工作人员打了个电话，也并未有人找到。</p>\n<h3>Day2</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">上午去了古德寺。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">古德寺的建筑风格与我一般印象中的佛教寺院很不一样，没有红墙绿瓦，反倒是浓郁的异域风气。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291821543.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291821543.jpeg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">雨水不大，微微拂面，给这建筑也衬上了一层静谧的气息。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">古德寺本身不大，没过多长时间就逛完了，便赶到湖北省博物馆附近。因为预约的是下午的场次，所以便准备先吃饭再前往博物馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">四周找寻好长时间，总算是走到小区附近找到了餐馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">吃过饭，排了好长时间队，总算进了博物馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">越王勾践剑展厅更是要排很长时间的队，排了好长时间进去后依然有很多人围到前面，身高又不占优势，甚至也没排到清楚的照片。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291929767.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291929767.jpeg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">从博物馆出来后看到天色并非很晚，就在截止前一会预约了隔壁美术馆的门票。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><del>来都来了.jpg（逃）</del></p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">不过可能是我的眼光不足以欣赏，也可能阅历不够丰富吧，没有看懂什么。。。</p>\n<h3>Day3</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">第三天选择长途跋涉去了科技馆玩，见到了好多之前在北京看到的相似的设施。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">不过寒假的多选一作业里面：</p>\n<ol start=\"1\">\n<li>制造一枚核弹，并拍摄引爆视频；</li>\n<li>制造一台永动机；</li>\n<li>上传一张与牛顿或爱因斯坦的合照。</li>\n<li>…</li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">于是……</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291947480.jpg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291947480.jpg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><del>太合理啦</del></p>\n<h3>Day4</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">第四天去了一个令我印象深刻的地方——五大旧址。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">曾经某次历史卷子曾给出了这里的图片，在学校“清晰”的印刷质量下已经是漆黑一片。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><del>所以，某种程度上的故地重游</del></p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">离开后时间还早，便前往晴川阁。</p>\n<blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">江上风烟望武昌，临江高阁晓苍苍。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">涛声八月蛟龙吼，霸气千秋草树荒。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">几点青山浮大别，一声残笛弄沧浪。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">自经崔颢题诗后，别是人间翰墨场。</p>\n</blockquote>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291953729.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291953729.jpeg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">由于下雪，（也许是雨夹雪，冻雨或者其他类似的各种东西），天气始终是朦胧的，迷蒙的，我很喜欢这种BSL（<del>白内障</del>）风格的氛围。远处楼影绰绰，淡墨色的长江大桥独跨江面。</p>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">忽如一夜春风来，千树万树梨花开。</p></blockquote>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292002652.jpg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292002652.jpg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><strong>徒步横跨长江！</strong></p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292004463.jpg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292004463.jpg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">走上了这座古朴的大桥，可能是风大，也可能单纯腿软，总觉得桥面在晃动。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">一不小心好险摔跤。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">还是小看了长江的长度，本以为能够步行过去后还能再徒步到酒店，看来还是高估自己了，最后依然选择坐地铁会酒店。</p>\n<h3>Day5</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">由于是上午的车，所以并没有去很远的地方，所以又去了一趟辛亥革命起义纪念馆，可惜身份证还是没找到。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">快到了回家的时候，走进武昌火车站，严峻的天气让诸多列车晚点，许多乘客滞留在候车厅，不过好在我们所乘坐的车次是从武昌火车站始发，而且有DF11G-0001/2的加持，列车依然正常出发。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">列车在风雪中奔驰，掠过楼房与田野。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">飞速的行驶并未成常态，在经过信阳附近时，开始了长时间的临时停车。（还好买的软座车票！）天逐渐黑了下来，腰酸背痛接踵而至，晚点了数小时后终于到了郑州站。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">深夜总算是回到家了，武汉之行也告一段落。</p>\n<h2>北京</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在七月份去了北京，内容较多，又考虑与以往在北京的经历串联起来写一篇文章，所以还是不放到年终总结里了吧（咕咕咕咕咕咕）。</p>\n<h2>历史</h2>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以史为鉴，可以正衣冠</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">2025年将加大对于历史领域的了解，以下列出一份推荐书目：</p>\n<ol start=\"1\">\n<li>全球通史</li>\n<li>中国通史</li>\n<li>通鉴纪事本末</li>\n</ol>\n<h2>纪事本末与人物志</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">纪事本末是一种以具体事件为纲的史书体例，为了能够更清晰的串联人生经历，记载事件本末，来年将着重于记录各种重要事件。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">为了在交往时更加方便，将记录身边以及新认识的人的基本信息，性格特征，经历之类，以在交往中能够有更为详尽的信息参考。</p>\n<h2>A&amp;Q</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度也被人问了很多问题，这里集中回答下吧。</p>\n<h3>为什么叫redish，和redis有什么关系吗?</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">redish这个名字其实在很久之前（2020年之前）就已经取了，当时并不了解redis这一项目，取了这个名字。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">至于这个名字的含义？</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><strong>R</strong>obust and <strong>E</strong>fficient <strong>D</strong>istributed <strong>I</strong>ntelligent data <strong>S</strong>torage <strong>H</strong>andler</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><strong>强健且高效的分布式智能数据存储处理器</strong></p>\n<h3>为什么周末总是出门？</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">确实有些事情的，不要乱猜了）</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">写到这里也差不多了，就这样吧，今年的文章似乎确实不是很多，明年一定狠狠的更新！```</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/2024-summary#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1735545600}, {"title": "使用 Cursor 做了几个单页小工具", "author": "林木木的博客", "pubDate": "2024-12-21 03:13:43", "link": "https://immmmm.com/build-html-by-cursor/", "description": "\n<p>最大感受，说清楚需求，基本上第一次对话即可生成。之后都是叠加需求和反复修复的过程。</p>\n<p>最大感慨，需求是稀缺资源，真切合理的需求结合 AI，把之前根本不会想尝试，变为积极主动试一试。</p>\n<h3>由简到难的 24 点出题器</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-nqww.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-nqxm.png.webp\" alt=\"\"></p>\n<p>「24 点出题器」 <a href=\"https://edui123.com/24/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://edui123.com/24/</a></p>\n<p>把 1362 道有解的 24 点题目，依据难度排序，支持按序和随机出题，右上角有 30 秒倒计时，点击标题可查看解法。</p>\n<p>玩 24 点日常难受的点在于直接拿扑克牌玩，1820 个不同组合，而实际有解的只有 1362 个。1362/1820≈0.748≈75%，四局有一局无解，已经很打击兴趣咯。</p>\n<p>很早看到 <a href=\"https://www.4shu.net/game/difficulties/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">4数网</a> 经过难度排序的题库，基于世界各地的人们已经解决 6283289 个题目，计算了每道题目的 “统一中值解决时间”, 并从最简单到最难给这些题目排序。</p>\n<p>一拍即合，干活！</p>\n<h3>语文生字拼音匹配小游戏</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-npdd.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-npiy.png.webp\" alt=\"\"></p>\n<p>「认读小能手」 <a href=\"https://edui123.com/renzi/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://edui123.com/renzi/</a></p>\n<p>基于部编语文一年级上册“识字表”中的 280 字，给认读生字增加一点趣味互动性，家里或学校能在期末阶段用上一用。</p>\n<ul>\n<li>3 种模式可选：限时 1 分钟、3 分钟、不限时；</li>\n<li>拖动拼音到对应的汉字上方，右上角有实时的统计数据条。</li>\n<li>限时模型下，结束时会有统计数据汇总，还有过程中拖动错误的汉字记录回顾。</li>\n</ul>\n<h3>自动听写词语</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-nsoi.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-nsqr.png.webp\" alt=\"\"></p>\n<p>「词语听写」 <a href=\"https://edui123.com/tingxie\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://edui123.com/tingxie</a></p>\n<p>一个自动朗读语文书后“词语表”的在线网页。</p>\n<ul>\n<li>内置 3~6 年级上册词语，选择年级、第几课，点击开始即可；</li>\n<li>默认每个词语读两遍，不同词语停顿 3 秒（可拖动修改）；</li>\n<li>随机模式，全册词语打乱顺序 20 个为一组；</li>\n<li>早读模式，全册词语打乱顺序读完后会显示“词语”。</li>\n</ul>\n<h3>杂记</h3>\n<p>其实 3 个都是单页可离线的 html，听写后来改用第三方接口，因为发现 Edge 文字转语音国内不可用，能用也只能 PC 上，使用太受限。</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1734722023}, {"title": "Memos &amp; n8n ，秒接入 AI", "author": "林木木的博客", "pubDate": "2024-12-18 13:30:36", "link": "https://immmmm.com/get-ai-memos/", "description": "\n<p>Memos 0.18 还是哪个版本开始就支持 webhook ，一直不知道有啥用。自从折腾了 n8n，发现能连通，而且也自用有段时间。</p>\n<p>自动化流程思路是：接收 Memos Webhook，判断是新建事件，判断首行是否有 <code>触发词</code>，进入对应流程修改当前条笔记。</p>\n<h3>演示之一</h3>\n<p><code>a修改</code> 接内容，触发✌️</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-suku.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-supf.png.webp\" alt=\"\"></p>\n<h3>使用简要说明</h3>\n<p>安装 n8n 之后，下载 <a href=\"https://n8n.akashio.com/b121c42b66fe4963925baa70de007dd6\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Memos_v0_22_3__share.json</a>，其它版本需自行微调。</p>\n<h3>修改授权信息</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-swwj.png.webp\" alt=\"\"></p>\n<h3>复制 Webhook 节点链接</h3>\n<p>粘贴到 Memos 设置 <code>偏好设置</code> 内。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-tdak.png.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-teap.png.webp\" alt=\"\"></p>\n<h3>根据需要可修改触发词</h3>\n<p>基于正则匹配。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-swol.png.webp\" alt=\"\"></p>\n<h2>后记</h2>\n<p>拓展性极强，当日常使用次数极少，不太习惯……</p>\n<p>其它更多的拓展一个思路，对于有 webhook 或 api 接口，都能非常方便接入 n8n 做联动 💪</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1734499836}, {"title": "正在使用的 Docker 清单", "author": "林木木的博客", "pubDate": "2024-12-08 09:16:41", "link": "https://immmmm.com/my-docker-list/", "description": "\n<p>9 月底TX轻量云搞活动 ¥159x2 新开了 2C4G 机子，比起大几千的续费，便宜太多太多。</p>\n<p>试了试整站镜像备份还原，但被告知新机器的硬盘（70GB）比原来的（80GB）小，不行。</p>\n<p>搁置两月，趁着阴天降温宅家，花了一下午，迁移完毕。🎉</p>\n<h3><a href=\"https://github.com/soulteary/docker-flare\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Flare</a></h3>\n<p>超级轻量、快速、美观的个人导航页面，还支持前端编辑。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/flare-editor-beta.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/flare-ui.png.webp\" alt=\"\"></p>\n<h3><a href=\"https://github.com/Rock-Candy-Tea/hexo-circle-of-friends\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">友链朋友圈</a></h3>\n<p>古早博客功能，个人的首页调用和友圈都是基于此。</p>\n<p>刚发现后继有人，已经有了轻量版本。</p>\n<h3><a href=\"https://github.com/cooderl/wewe-rss\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">WeWe RSS</a></h3>\n<p>更优雅的微信公众号订阅方式。部署之后登录自己的微信读书账号，个人已稳定运行大半年。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/wewerss.png.webp\" alt=\"\"></p>\n<h3><a href=\"https://github.com/usememos/memos\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Memos</a></h3>\n<p>挺好的随记工具，但不兼容更新频繁，停留在 v0.18.2 安逸。博客首页调用、哔哔广场都基于此。</p>\n\n\n\n\n\t\n\n\n<div class=\"post-preview\">\n  <div class=\"post-preview--meta\">\n    <div class=\"post-preview--middle\">\n      <h4 class=\"post-preview--title\">\n        <a target=\"_blank\" href=\"https://immmmm.com/memobbs-app/\">哔哔广场.app</a>\n      </h4>\n      <time class=\"post-preview--date\">2024-01-21</time><small>#折腾 </small>\n      \n      <section class=\"post-preview--excerpt\">\n        基于 @归臧 的 Memos 样式和功能，在 @koobai 无限需求之下，连肝一周并败入域名解析之: https://memobbs.app/\n折腾核心动力：颜值在线！\n满足核心需求：Memos&amp;rsquo;er 共舞~\n\n      </section>\n</div>\n  </div>\n  \n    <img rel=\"link\" loading=\"lazy\" class=\"post-preview--image avatar\" src=\"https://r2.immmmm.com/2024/01/bbv3.png.webp\">\n</div>\n\n<h3><a href=\"https://github.com/twikoojs/twikoo\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Twikoo</a></h3>\n<p>一个简洁、安全、免费的静态网站评论系统。配置和评论数据迁移起来真方便。</p>\n<h3><a href=\"https://github.com/stilleshan/frps\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">stilleshan/frps</a></h3>\n<p>网穿透服务，原版怎么都不行，用这个分分钟搞定。</p>\n\n\n\n\n\t\n\n\n<div class=\"post-preview\">\n  <div class=\"post-preview--meta\">\n    <div class=\"post-preview--middle\">\n      <h4 class=\"post-preview--title\">\n        <a target=\"_blank\" href=\"https://immmmm.com/install-frp-record/\">迁移 FRP 记录</a>\n      </h4>\n      <time class=\"post-preview--date\">2024-11-10</time><small>#折腾 </small>\n      \n      <section class=\"post-preview--excerpt\">\n        （旧文重更：2024/11/10）\n服务器到期在即，迁移 FRP 小记，为了把家里的 书库 talebook 能无障碍在线使用。\n群晖拉起 frpc，服务器部署 frps，路由器端口转发，给个子域名解析，即可实现域名访问服务。\n\n      </section>\n</div>\n  </div>\n  \n    <img rel=\"link\" loading=\"lazy\" class=\"post-preview--image avatar\" src=\"https://r2.immmmm.com/2024/11/SCR-20241110-kfqf.png.webp\">\n</div>\n\n<h3><a href=\"https://umami.is/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Umami</a></h3>\n<p>一个高颜值可自部署的统计应用，还支持前端调用数据。</p>\n\n\n\n\n\t\n\n\n<div class=\"post-preview\">\n  <div class=\"post-preview--meta\">\n    <div class=\"post-preview--middle\">\n      <h4 class=\"post-preview--title\">\n        <a target=\"_blank\" href=\"https://immmmm.com/hi-umami-api/\">前端调用 Umami API 数据</a>\n      </h4>\n      <time class=\"post-preview--date\">2024-11-10</time><small>#折腾 </small>\n      \n      <section class=\"post-preview--excerpt\">\n        Umami 一个高颜值可自部署的统计应用。\n看着服务器负载常年低于10%，有一点点需求的应用，特别是能 Docker 部署的，全都安排上！看着基本的统计数据都有。不错不错！但，能直接 API 前端调用统计数据不？可以的，接口见官网： https://umami.is/docs/api\n\n      </section>\n</div>\n  </div>\n  \n    <img rel=\"link\" loading=\"lazy\" class=\"post-preview--image avatar\" src=\"https://r2.immmmm.com/2023/06/umami-im.png\">\n</div>\n\n<h3><a href=\"https://github.com/wy580477/musicn-container\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">musicn-container</a></h3>\n<p>可播放及下载音乐的命令行工具 musicn 的容器版本，支持 amd64/arm64 架构。偶尔用来下载个 MP3。</p>\n<h3><a href=\"https://github.com/n8n-io/n8n\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">n8n</a></h3>\n<p>免费自部署低代码平台，比如用来接入 <a href=\"https://n8n.akashio.com/b121c42b66fe4963925baa70de007dd6\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Memos AI 助理</a>，追踪微信公众号更新并生成 AI 日报等。</p>\n\n\n\n\n\t\n\n\n<div class=\"post-preview\">\n  <div class=\"post-preview--meta\">\n    <div class=\"post-preview--middle\">\n      <h4 class=\"post-preview--title\">\n        <a target=\"_blank\" href=\"https://immmmm.com/hi-n8n/\">我应该是最后一个才知道有 n8n 这个东西的人吧</a>\n      </h4>\n      <time class=\"post-preview--date\">2024-08-01</time><small>#折腾 </small>\n      \n      <section class=\"post-preview--excerpt\">\n        借用 @heo 某篇文章的句式，表达一下对 n8n 的惊叹之感！不搜不知道，一搜吓一跳。\n小众软件19年10月、少数派 @珪璋 去年5月、@OSEN今年1月、@lcomplete 今年4月，以及我最最后才从 @汐笺 知道的 n8n 中文教程。\n\n      </section>\n</div>\n  </div>\n  \n    <img rel=\"link\" loading=\"lazy\" class=\"post-preview--image avatar\" src=\"https://r2.immmmm.com/2024/08/SCR-20240801-mgzr.png.webp\">\n</div>\n\n<h3><a href=\"https://github.com/talebook/talebook\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Talebook</a></h3>\n<p>以下几个 Docker 都部署在 NAS 里。</p>\n<p>基于 Calibre 简单的个人图书管理系统，各方面都比 calibre-web 好用。而且 Talebook 可以直接读取 Calibre 数据库，日常通过本地连接 NAS 管理书籍，结合 frpc 穿透绑上域名，供好友自取，还内置了 opds 功能，手机用 KyBooks3 APP 顺利实现 APP 内检索下载阅读。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/ds-docker-5.jpg.jpeg.webp\" alt=\"\"></p>\n<h3>vaultwarden</h3>\n<p>Bitwarden 自部署镜像。</p>\n<h3><a href=\"https://ghost.org/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Ghost</a></h3>\n<p>用作家庭内部图片博客，基本上是整理照片时，随手丢上去更新一下。回头翻翻，把美好瞬间记录也是件美好的事。</p>\n<p>停留在 5.8.3 版本，因为这是 sqlite3 的最高版本，再高需要另外部署 MySQL 8。</p>\n<h3><a href=\"https://github.com/Sitoi/dailycheckin\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">DailyCheckIn</a></h3>\n<p>基于「Docker」/「青龙面板」/「群晖」/「本地」的每日签到脚本。</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1733620601}, {"title": "Deno再尝试：使用Deno编写一个简单的WebAPI", "author": "Redish101博客", "pubDate": "2024-07-22 20:13:46", "link": "https://blog.redish101.top/article/deno", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/deno\">https://blog.redish101.top/article/deno</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">两年前，我通过<a href=\"https://mk1.io/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">Ray(@so1ve)</a>的博客系统<a href=\"https://github.com/dolan-x/dolan-server\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">dolan-x</a>了解到了<code>Deno</code>这一新的 js 运行时以及其对应的 saas 服务<code>Deno Deploy</code>，为了<del>白嫖<code>Deno Deploy</code></del>，决定尝试一下，用 Deno + oak + LeanCloud 写了一个简单的友链管理。但是 Deno 脆弱的生态和与 go 类似的基于 url 的模块系统（即使能通过<code>import_map.json</code>定义别名）实在没有太多优势，最近 Deno Deploy 又被群友提及，看到 Deno 本身变化很大，便决定再尝试用 Deno 写一个东西。凑巧<a href=\"https://redish101.top/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">个人主页</a>想加一个活动监测器，便决定用 Deno 来实现。</p>\n<h2>web 框架的选择</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">相比之前的友链，这次要做的比较简单，所以没有使用一些框架，而是直接使用标准库中的<code>Deno.serve</code>实现。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>Deno.serve</code>接受一个函数，函数接受请求对象返回响应。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const handler = (req: Request) {\n    return new Response(\"Hello, World!\");\n}\n\nDeno.serve(handler);</code></pre>\n<h2>路由</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Deno 本身并没有实现路由，但是可以通过手动解析<code>pathname</code>实现。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const handler = (req: Request) {\n    const { pathname } = new URL(req.url);\n\n    if (pathname === \"/\") {\n        return new Response(\"Hello, World!\");\n    }\n\n    if (pathname === \"/foo\") {\n        return new Response(\"bar\");\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">对于复杂的路由，可以尝试把 handler 封装到 map 中：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">type Handler = (req: Request) =&gt; Response;\ntype HandlerMap = { [pathname: string]: Handler };\n\nconst handlers: HandlerMap = {\n  \"/\": () =&gt; new Responese(\"Hello, World!\"),\n  \"/foo\": () =&gt; new Response(\"bar\"),\n};\n\nconst handler = (req: Request) =&gt; {\n  const { pathname } = new URL(req.url);\n\n  const matchedHandler = handlers[pathname];\n\n  if (matchedHandler) {\n    return matchedHandler(req);\n  }\n\n  return new Response(\"Not Found\", { status: 404 });\n};</code></pre>\n<h2>格式化响应</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">最好封装一个格式化响应对象，封装<code>success</code>，<code>message</code>，<code>data</code>等属性，方便处理：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">class FmtResponse&lt;T&gt; {\n  private code: number = 200;\n  private success: boolean = true;\n  private message: string = \"success\";\n  private data: T | null = null;\n\n  constructor(opts: { code?: number; message?: string; data?: T }) {\n    if (opts.code &amp;&amp; opts.code &gt;= 400) {\n      this.success = false;\n    }\n    this.message = opts.message || \"success\";\n    this.data = opts.data || null;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">并提供一个<code>json</code>方法返回 json 格式的响应：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">public json() {\n    const resObj = {\n      success: this.success,\n      message: this.message,\n      data: this.data,\n    };\n\n    return new Response(JSON.stringify(resObj), {\n      status: this.code,\n      headers: {\n        \"content-type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n        \"Access-Control-Allow-Headers\": \"Content-Type, apikey\",\n      },\n    });\n}</code></pre>\n<h2>数据的储存</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">选择<code>Deno Deploy</code>很大一部分原因是因为其方便的 kv 储存，可以方便的持久化储存数据：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const kv = await Deno.openKv();\n\nawait kv.set([\"settings\", \"username\"], \"redish101\");\n\nconst username = await kv.get([\"settings\", \"username\"]);\n\nconsole.log(username.value); // \"redish101\"</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">值得一提的是，<code>DenoKV</code>虽然可以在本地使用，但是需要在 cli 传入<code>--unstable-kv</code>：</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">deno run --unstable-kv main.ts</code></pre>\n<h2>监控数据的上报</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这部分没什么可说的，用 rust 写了一个上报器，每 20 分钟通过请求接口上报正常状态的数据，并作为 macOS 服务运行：</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">use std::env;\n\nuse tokio::time;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt::init();\n\n    info!(\"Welcome to remonitor!\");\n\n    let apiurl = \"https://redish101-remonitor.deno.dev/remonitor\";\n    let apikey = env::var(\"APIKEY\").unwrap();\n\n    let mut interval = time::interval(time::Duration::from_secs(1200));\n\n    loop {\n        interval.tick().await;\n        info!(\"Post status\");\n        reqwest::Client::new()\n           .get(apiurl)\n           .header(\"apikey\", apikey.clone())\n           .send()\n           .await\n           .expect(\"Failed to send request\");\n        info!(\"Sent request\");\n    }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">macos 的服务不能直接读取环境变量，只能读取通过<code>launchctl setenv</code>设置的环境变量。通过 plist 设置<code>keepAlive</code>可以实现后台运行：</p>\n<pre class=\"language-xml lang-xml\"><code class=\"language-xml lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;Label&lt;/key&gt;\n    &lt;string&gt;top.redish101.remonitor&lt;/string&gt;\n    &lt;key&gt;ProgramArguments&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;/path/to/client&lt;/string&gt;\n    &lt;/array&gt;\n    &lt;key&gt;RunAtLoad&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;key&gt;KeepAlive&lt;/key&gt;\n    &lt;true/&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;</code></pre>\n<h2>部署</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>Deno Deploy</code>是Deno推出的saas服务，提供了Deno程序的部署、KV、定时任务等功能，并且速度不错，所以选择了通过Deno Deploy部署。</p>\n<h2>总结</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Deno虽说目前不怎么适合放到大型项目的生产环境，但是写一些小服务玩玩还是很舒服的，编码体验很好</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/deno#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1721650426}, {"title": "国产光学顶起来了？永诺42.5mm f1.7 使用体验报告", "author": "小N同学的博客", "pubDate": "2024-04-23 02:40:27", "link": "https://www.imcharon.com/8557/", "description": "在这个镜头机身溢价的时代，国产能否发力抢出一片市场？", "categories": ["往日余生", "精选", "摄影", "照片", "镜头"], "time": 1713811227}, {"title": "【Magisk】方正悠黑 Google Sans VF On OPlus", "author": "小N同学的博客", "pubDate": "2024-03-27 14:33:01", "link": "https://www.imcharon.com/8539/", "description": "这是一款基于方正悠黑 Google VF Sans可变字体的OPlus机型字体模块 OPPO / OnePlu […]", "categories": ["往日余生", "教程", "maigsk", "root", "美化"], "time": 1711521181}, {"title": "【Magisk】Manrope腾祥黑体 VF On OPlus By Charon", "author": "小N同学的博客", "pubDate": "2024-03-25 17:53:32", "link": "https://www.imcharon.com/8525/", "description": "这是一款基于Manrope腾祥黑体 VF Sans可变字体的OPlus机型字体模块", "categories": ["往日余生", "教程", "magisk", "root", "美化"], "time": 1711360412}, {"title": "Bitwarden插件无法登录如何修复（Cannot read properties of nul(reading ‘iterations‘)）", "author": "小N同学的博客", "pubDate": "2024-03-22 17:58:32", "link": "https://www.imcharon.com/8514/", "description": "修复一个奇怪的BUG", "categories": ["往日余生", "教程", "bitwarden"], "time": 1711101512}, {"title": "SteamDeck开启samba服务", "author": "Yume.KISEKI", "pubDate": "2024-01-15 14:27:53", "link": "https://www.monoko.jp/steamdeck-samba/", "description": "\n<p>SteamDeck开启samba服务 1.前言 为什么steamdeck要开启samba服务，不为别的，我只用 […]</p>\n<p><a href=\"https://www.monoko.jp/steamdeck-samba/\">SteamDeck开启samba服务</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "samba", "steamdeck"], "time": 1705300073}, {"title": "记录一次勇敢的旅程", "author": "小N同学的博客", "pubDate": "2023-12-30 13:56:09", "link": "https://www.imcharon.com/8477/", "description": "在12月初的时候，我计划了一场“特种兵”式的西部旅游计划。 不知道大家最近刷社交媒体，有没有刷到一句话： 纵观 […]", "categories": ["往日余生", "旅行"], "time": 1703915769}, {"title": "Phira源码解析1: 入口函数", "author": "Redish101博客", "pubDate": "2023-12-17 05:43:12", "link": "https://blog.redish101.top/article/phira-source-code-1", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/phira-source-code-1\">https://blog.redish101.top/article/phira-source-code-1</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>phira</code>，原<code>prpr</code>，一款Phigros自制谱播放器，程序主体部分使用rust编写，底层为轻量的跨平台的rust图形库<code>miniquad</code>与其封装库<code>macroquad</code>。</p>\n<h2>项目结构</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">phira的仓库内有以下几个包</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">.\n├── Cargo.lock\n├── Cargo.toml\n├── LICENSE\n├── README-zh_CN.md\n├── README.md\n├── assets\n├── build_wasm.sh\n├── phira\n├── phira-main\n├── phira-monitor\n├── prpr\n├── prpr-avc\n└── rustfmt.toml</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">其中核心程序部分</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">.\n├── phira\n├── prpr\n└── phira-main</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">我们也主要展开这两个包的解析。</p>\n<h3><code>phira-main/src/main.rs</code></h3>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">fn main() {\n    phira::quad_main();\n}</code></pre>\n<h3><code>phira::quad_main</code></h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>phira::quad_main();</code>调用位于phira包内的入口函数。<code>quad_main</code>函数内容如下</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">pub extern \"C\" fn quad_main() {\n    macroquad::Window::from_config(build_conf(), async {\n        if let Err(err) = the_main().await {\n            error!(\"Error: {:?}\", err);\n        }\n    });\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>macroquad::Window::from_config</code>函数用于从配置新建一个macroquad窗口，此处配置由<code>build_conf</code>函数生成。</p>\n<h3><code>build_conf</code></h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">此函数位于<code>prpr</code>包内。内容如下</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">pub fn build_conf() -&gt; macroquad::window::Conf {\n    macroquad::window::Conf {\n        window_title: \"Phira\".to_string(),\n        window_width: 973,\n        window_height: 608,\n        ..Default::default()\n    }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">此函数返回了<code>macroquad::window::Conf</code>结构体，此结构体用以指定macroquad窗口的标题，尺寸等配置项。</p>\n<h3><code>the_main</code></h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在<code>quad_main</code>函数中被调用，程序实际主体部分。内容如下：</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">async fn the_main() -&gt; Result&lt;()&gt; {\n    // 注册日志记录器\n    log::register();\n\n    // 初始化资源文件\n    init_assets();\n\n    // 创建tokio运行时\n    let rt = tokio::runtime::Builder::new_multi_thread()\n        .worker_threads(4) // 设置工作线程数为4\n        .enable_all() // 启用所有功能\n        .build() // 构建运行时\n        .unwrap(); // 获取运行时实例\n    let _guard = rt.enter(); // 进入运行时上下文\n\n    // ios环境下的特殊设置\n    #[cfg(target_os = \"ios\")]\n    unsafe {\n        use prpr::objc::*;\n        #[allow(improper_ctypes)]\n        extern \"C\" {\n            pub fn NSSearchPathForDirectoriesInDomains(\n                directory: std::os::raw::c_ulong,\n                domain_mask: std::os::raw::c_ulong,\n                expand_tilde: bool,\n            ) -&gt; *mut NSArray&lt;*mut NSString&gt;;\n        }\n        let directories = NSSearchPathForDirectoriesInDomains(5, 1, true);\n        let first: &amp;mut NSString = msg_send![directories, firstObject];\n        let path = first.as_str().to_owned();\n        *DATA_PATH.lock().unwrap() = Some(path);\n        *CACHE_DIR.lock().unwrap() = Some(\"Caches\".to_owned());\n    }\n\n    // 读取数据文件目录\n    let dir = dir::root()?;\n    let mut data: Data = std::fs::read_to_string(format!(\"{dir}/data.json\")) // 读取数据文件\n        .map_err(anyhow::Error::new) // 处理错误\n        .and_then(|s| Ok(serde_json::from_str(&amp;s)?)) // 解析JSON数据\n        .unwrap_or_default(); // 如果解析失败，使用默认值\n    data.init().await?; // 初始化数据\n    set_data(data); // 设置数据\n    sync_data(); // 同步数据\n\n    // 创建消息通道\n    let rx = {\n        let (tx, rx) = mpsc::channel();\n        *MESSAGES_TX.lock().unwrap() = Some(tx);\n        rx\n    };\n\n    // 创建防沉迷消息通道\n    let aa_rx = {\n        let (tx, rx) = mpsc::channel();\n        *AA_TX.lock().unwrap() = Some(tx);\n        rx\n    };\n\n    // 设置暂停恢复监听器\n    unsafe { get_internal_gl() }\n        .quad_context\n        .display_mut()\n        .set_pause_resume_listener(on_pause_resume);\n\n    // 如果存在用户信息，执行防沉迷操作\n    if let Some(me) = &amp;get_data().me {\n        anti_addiction_action(\"startup\", Some(format!(\"phira-{}\", me.id)));\n    }\n\n    // 加载Phigros字体文件\n    let pgr_font = FontArc::try_from_vec(load_file(\"phigros.ttf\").await?)?;\n    PGR_FONT.with(move |it| *it.borrow_mut() = Some(TextPainter::new(pgr_font, None)));\n\n    // 加载其他字体文件\n    let font = FontArc::try_from_vec(load_file(\"font.ttf\").await?)?;\n    let mut painter = TextPainter::new(font.clone(), None);\n\n    // 创建主场景、时间管理器和帧率计时器\n    let main = Main::new(Box::new(MainScene::new(font).await?), TimeManager::default(), None).await?;\n    let tm = TimeManager::default();\n    let mut fps_time = -1;\n\n    // 主循环\n    'app: loop {\n        let frame_start = tm.real_time(); // 记录当前帧开始时间\n        let res = || -&gt; Result&lt;()&gt; {\n            main.update()?; // 更新主场景\n            main.render(&amp;mut painter)?; // 渲染主场景\n            if let Ok(paused) = rx.try_recv() { // 接收暂停恢复消息\n                if paused {\n                    main.pause()?; // 暂停主场景\n                } else {\n                    main.resume()?; // 恢复主场景\n                }\n            }\n            Ok(())\n        }();\n        if let Err(err) = res { // 处理错误\n            error!(\"uncaught error: {err:?}\");\n            show_error(err);\n        }\n        if main.should_exit() { // 判断是否退出游戏\n            break 'app;\n        }\n\n        if let Ok(code) = aa_rx.try_recv() { // 接收防沉迷消息\n            info!(\"anti addiction callback: {code}\");\n            match code {\n                500 =&gt; {\n                    anti_addiction_action(\"enterGame\", None);\n                }\n                1001 =&gt; {\n                    anti_addiction_action(\"exit\", None);\n                    get_data_mut().me = None;\n                    get_data_mut().tokens = None;\n                    let _ = save_data(); // 保存数据\n                    sync_data(); // 同步数据\n                    use crate::login::L10N_LOCAL;\n                    show_message(crate::login::tl!(\"logged-out\")).ok(); // 显示退出登录提示\n                }\n                1030 =&gt; {\n                    show_and_exit(\"你当前为未成年账号，已被纳入防沉迷系统。根据国家相关规定，周五、周六、周日及法定节假日 20 点 - 21 点之外为健康保护时段。当前时间段无法游玩，请合理安排时间。\");\n                    exit_time = frame_start;\n                }\n                1050 =&gt; {\n                    show_and_exit(\"你当前为未成年账号，已被纳入防沉迷系统。根据国家相关规定，周五、周六、周日及法定节假日 20 点 - 21 点之外为健康保护时段。你已达时间限制，无法继续游戏。\");\n                    exit_time = frame_start;\n                }\n                9002 =&gt; {\n                    show_and_exit(\"必须实名认证方可进行游戏。\");\n                    exit_time = frame_start;\n                }\n                _ =&gt; {}\n            }\n        }\n\n        let t = tm.real_time(); // 获取当前时间\n\n        if t &gt; exit_time + 5. { // 判断是否达到退出条件\n            break;\n        }\n\n        let fps_now = t as i32; // 计算当前帧率\n        if fps_now != fps_time { // 如果帧率发生变化，更新帧率计时器\n            fps_time = fps_now;\n            info!(\"FPS {}\", (1. / (t - frame_start)) as u32);\n        }\n\n        next_frame().await; // 等待下一帧\n    }\n    Ok(())\n}</code></pre>\n</div>\n<p><a href=\"https://blog.redish101.top/article/phira-source-code-1#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1702762992}, {"title": "2023年年终总结", "author": "Redish101博客", "pubDate": "2023-12-15 03:08:54", "link": "https://blog.redish101.top/article/2023-summary", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/2023-summary\">https://blog.redish101.top/article/2023-summary</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">又至年末，又到了作年终总结的时候了。本来不想写年末总结的，但是看看这更新日期以及屈指可数的文章，还是写一篇为好。</p>\n<h2>博客数据</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度博客程序部分进行了两次大改版，第一次于本年3月由Hexo至Next.js Pages Router，后于七月重构至Next.js App Router，但核心的数据管理部分未做更改。而在ui设计方面使用了苏卡卡大佬的设计，但由于闭源，均为亲自实现。并于最近使用vite整理封装为react组件库(@recomponents/react)，但组件较少，缺失Input，List等实用组件，一般建议在如博客等场景中应用，而其中Card组件可自定义参数较多，可以实现较高程度的定制化。组件库使用了style9实现了预编译的原子化css，自npm下载使用时无需进行编译器层面的配置，但生产环境下类名经过处理，不易调试。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">新博客在Markdown渲染上会尝试接入尚未完成的由rust编写的Markdown解析器，主要用作练手使用。</p>\n<h2>服务商的选择</h2>\n<h3>服务端</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">由于vercel平台在管理自动部署等方面相较于其它服务商较好的优化，并且对于Next.js项目有极好的支持，所以至今所有web服务均部署在vercel上。</p>\n<h3>CDN</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">八月份Jason送了初七云亚太加速包，速度很好，但是配置方面实在不易学习，故又更换为Cloudflare，而Cloudflare在中国内地的访问速度并为太过于无法接受，且在配置方面有更好的效果，用起来还是十分不错的。</p>\n<h2>新技能</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">2022年目标中的新技能列表如下:</p>\n<ul>\n<li>Rust</li>\n<li>Unity</li>\n<li>Blender</li>\n<li>Pytorch</li>\n<li>K8S</li>\n<li>Latex</li>\n</ul>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">其中已经实现的有:</p>\n<ul>\n<li>Rust</li>\n<li>Blender</li>\n<li>Ltex</li>\n</ul>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">生命不息，奋斗不止</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">真的有认真在学啊！！！可是学不会，我是废物啊啊啊！</p>\n<h2>项目</h2>\n<h3>Retalk</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">大规模重构ing.....</p>\n<h3>remake-rs</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在写js相关操作</p>\n<h3>远期规划</h3>\n<ul><li>基于Rust的Minecraft: Bedrock Edition服务端</li></ul>\n<pre class=\"\"><code class=\"\">\n</code></pre>\n</div>\n<p><a href=\"https://blog.redish101.top/article/2023-summary#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1702580934}, {"title": "浅谈Quest3", "author": "Yume.KISEKI", "pubDate": "2023-11-25 15:41:21", "link": "https://www.monoko.jp/about-quest3/", "description": "\n<p>入手quest3 当初想买quest2时发现已经出了有两年了，对于vr这种可有可无的设备干脆就等quest3了 […]</p>\n<p><a href=\"https://www.monoko.jp/about-quest3/\">浅谈Quest3</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "quest3", "vr"], "time": 1700898081}, {"title": "Windows电脑音频大优化！杜比音效+Fx Sound双调教！", "author": "小N同学的博客", "pubDate": "2023-10-29 11:56:50", "link": "https://www.imcharon.com/8447/", "description": "作为一名离开音乐会死星人，windows没有任何调教的声音听着真的很难受，但是单杜比的效果又有点差强人意，那怎 […]", "categories": ["往日余生", "教程", "精选", "资源分享", "windows", "音效"], "time": 1698551810}, {"title": "2023年QQBOT防风控小妙招", "author": "轻音时雨的博客", "pubDate": "2023-09-25 11:20:37", "link": "https://www.594594.xyz/2023/09/25/qqbot_anti_risk/", "description": "<p>本文内容禁止抄袭、转载、搬运</p>", "categories": ["游戏相关", "教程"], "time": 1695612037}, {"title": "关于站点的未来，和最近的状况", "author": "小N同学的博客", "pubDate": "2023-09-01 15:19:47", "link": "https://www.imcharon.com/8436/", "description": "最近的时间非常少，站点几乎处于无维护状态。 首先！我要向申请友链的小伙伴们说声对不起，因为太忙导致没时间更新！ […]", "categories": ["往日余生"], "time": 1693552787}, {"title": "CloudFlare warp 优选", "author": "wututu-blog", "pubDate": "2023-08-12 15:20:04", "link": "https://blog.wututu.cn/cloudflare-warp-%E4%BC%98%E9%80%89/", "description": "博客原文地址：https://blog.misaka.rest/2023/03/12/cf-warp-yxip cloudflar ...", "categories": ["未分类"], "time": 1691824804}, {"title": "各大frp内网穿透评测", "author": "wututu-blog", "pubDate": "2023-08-06 02:41:43", "link": "https://blog.wututu.cn/%E5%90%84%E5%A4%A7frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%AF%84%E6%B5%8B/", "description": "只做评测排名不分上下 1.LoCyan Frp 此家frp坚持100%免费不做任何收费项目，如果有能力的话可以捐赠此项目 官网：h ...", "categories": ["内网穿透", "评测"], "time": 1691260903}, {"title": "termux 安装 aircrak-ng", "author": "Utermux博客", "pubDate": "2023-07-23 03:48:26", "link": "https://blog.utermux.dev/ut/aircrack-ng.html", "description": "pkg i tur-repo -ypkg i aircrack-ng -y", "categories": [], "time": 1690055306}, {"title": "termux 安装 mdk4", "author": "Utermux博客", "pubDate": "2023-07-23 03:47:53", "link": "https://blog.utermux.dev/ut/mdk4.html", "description": "pkg i tur-repo -ypkg i mdk4 -y", "categories": [], "time": 1690055273}, {"title": "将我的博客迁移到Next.js App Router与React Server Components", "author": "Redish101博客", "pubDate": "2023-07-13 05:03:10", "link": "https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-component", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230712213628.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131357.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131238.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-component\">https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-component</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在今年三月初，我使用 Next.js 重构了我的博客。现在，随着 Next.js AppRouter 的稳定，我又将博客从 Next.js Pages Router 迁移到了 Next.js 13 AppRouter 与 React Server Components，同时，我也做了大量的底层重构以及样式重构。</p>\n<h2>性能优化: React Server Components</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在 React 18 之前，所有的组件均为 <code>Client Components</code>，即客户端组件。顾名思义，客户端组件中的所有逻辑均在客户端执行。浏览器渲染客户端组件需要从服务端获取 chunk，然后渲染组件到页面。即使是在 SSR 中，也需要等待客户端组件所对应的 bundle 完成加载才能让页面具有逻辑，能够交互。而我们的一些操作并不需要在客户端调用：如获取数据，大量的类似的逻辑，大大提高了 bundle 的体积，使得页面加载相对较慢，而 <code>React Server Components</code>（以下简称 <code>RSC</code>）的出现很好的解决了这一问题。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">RSC 不同于客户端组件，RSC 在服务端的 React 执行，客户端所收到的是服务端的执行结果，也就是说，客户端不会加载任何 RSC 的逻辑代码，以此我们就能缩小 Client Bundle。因为 RSC 是在服务端执行的，所以理所当然，RSC 内能够调用 node 环境，我们也就不必通过 <code>getStaticProps</code>等 api 获取数据。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">之前的文章提到过，我将博客从 Hexo 迁移到了基于文件的 CMS，以往博客版本是这样获取数据的：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export async function getStaticPaths() {\n  const posts = getAllPosts([\"slug\"]);\n\n  return {\n    paths: posts.map((post) =&gt; {\n      return {\n        params: {\n          slug: post.slug,\n        },\n      };\n    }),\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }: any) {\n  const post = getPostBySlug(params.slug, [\"title\", \"date\", \"slug\", \"content\"]);\n  const content = await markdownToHtml(post.content || \"\");\n  await generateRss();\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content,\n      },\n    },\n  };\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">而在使用 RSC 后，我们可以直接获取数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default async function Post({ params }: { params: { slug: string } }) {\n  const post = getPostBySlug(params.slug, [\n    \"title\",\n    \"date\",\n    \"slug\",\n    \"cover\",\n    \"content\",\n  ]);\n  if (!post.title) {\n    return notFound();\n  }\n  const content = await markdownToHtml(post.content || \"\");\n  return (\n    &lt;&gt;\n      &lt;Card title={post.title} cover={post.cover} label={post.date.toString()}&gt;\n        &lt;div dangerouslySetInnerHTML={{ __html: content }} /&gt;\n      &lt;/Card&gt;\n    &lt;/&gt;\n  );\n}\n\nexport async function generateStaticParams() {\n  const posts = getAllPosts([\"slug\"]);\n  return posts.map((post) =&gt; ({\n    slug: post.slug,\n  }));\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">可以看见，使用 RSC 后的页面相比于不使用 RSC 的页面大幅减少了代码长度。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但正因 RSC 是在 node 环境运行的，所以我们不能在 RSC 使用浏览器的 api，也无法使用 <code>useState</code>等 api，也就是说，RSC 不能直接响应用户的交互。而当我们需要调用浏览器api时，可以通过在组件代码前加上 <code>\"use client\";</code>将组件更改为客户端组件，就能调用浏览器api。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">值得一提的是，我们可以在RSC中引入客户端组件：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;div&gt;\n  This is a RSC\n  &lt;ClientComponent /&gt;\n&lt;/div&gt;</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但我们不能在客户端组件内引入RSC：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;ClientComponent&gt;\n  &lt;ServerComponent /&gt;\n&lt;/ClientComponent&gt;</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但我们依然有办法在客户端组件内直接调用RSC。前文提到，RSC在渲染过程中需要node的参与，但是返回结果是相当于静态的，所以我们可以通过Props的方式向客户端组件传入RSC的返回值实现：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;ServerComponent&gt;\n  const res = &lt;AnotherSC /&gt;\n  &lt;ClientComponent aprop={res} /&gt;\n&lt;/ServerComponent&gt;</code></pre>\n<h2>布局优化： Next.js App Router</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在 Next.js 13 中，Next.js 新增了一种新的路由方式：<code>App Router</code>。它基于 <code>React Server Components</code>开发，支持共享布局，加载状态，嵌套路由，错误处理等。其中对我而言最重要的更新就是嵌套路由。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">App Router 将路由拆分为布局与内容两部分，其中布局支持嵌套，大大减少了代码冗余。例如我们要实现 AB 两个页面，二者都包含一个导航栏和一个侧边栏，B 页面在以上的基础下又包含其自身所需要的布局，即需要布局嵌套，在 <code>Pages Router</code>中，我们需要这样：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// A.tsx\nexport default function A() {\n  return (\n    &lt;LayoutA&gt;\n      &lt;Content /&gt;\n    &lt;/LayoutA&gt;\n  );\n}</code></pre>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// B.tsx\nexport default function B() {\n  return (\n    &lt;LayoutA&gt;\n      &lt;LayoutB&gt;\n        &lt;Content /&gt;\n      &lt;/LayoutB&gt;\n    &lt;/LayoutA&gt;\n  );\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">只有两层情况就已经如此糟糕，倘若有三层，四层.......代码的可读性将大大降低。但在 App Router 中，我们可以这样做:</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// app/a/layout.tsx\nexport default RootLayout({ children }: { children: ReactNode }) {\n  return (\n      &lt;html lang=\"zh-CN\"&gt;\n      &lt;body&gt;\n        &lt;NavBar /&gt;\n        &lt;div&gt;\n          &lt;LayoutA&gt;{children}&lt;/LayoutA&gt;\n        &lt;/div&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  )\n}</code></pre>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// app/a/b/layout.tsx\nexport default LayoutB({ children }: { children: ReactNode }) {\n  return &lt;LayoutA&gt;{children}&lt;/LayoutA&gt;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">此时，b 页面的布局会自动继承 a 的布局，并在其基础上新增其自身布局，代码会十分简洁。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">除了语法更加简洁，我们也可以通过AppRouter实现共享布局。</p>\n<h2>服务端: 从 SSG 迈向 SSR</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在<a href=\"https://blog.redish101.top/post/blog-v5\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">「使用 Next.js 重构我的博客」</a>一文中我提到，我将博客核心所使用的 CMS 从 <code>Hexo</code>迁移到自研的基于文件的 CMS，在构建时使用 <code>Next.js Pages Router</code>提供的 <code>getStaticProps</code>等一系列 api 在构建时从本地获取文章并渲染，但在我迁移博客到 <code>Next.js App Router</code>时这样的做法无法通过构建，原因是 App Router 并不支持使用 <code>getStaticProps</code>等 api 获取数据。同时，在构建时渲染 Markdown 也会导致构建速度很慢，在考虑之下，我决定放弃 SSG，迈向 SSR。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但是，如果在每次访问都渲染一次文章，就会导致服务器压力激增，客户端访问速度直线上升。显然，这种做法是极其不明智的。好在，React 18 中提供了一个 <code>cache</code>方法，被 <code>cache</code>包裹的方法，在传参不变的情况下不会执行方法，而是直接返回缓存值，例如：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { cache } from \"react\";\n\nconst add = (a: number, b: number) =&gt; {\n  return a + b;\n};\n\nconst cacheAdd = cache(add);\n\ncacheAdd(1, 2); // 3\ncacheAdd(1, 2); // 3</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果参数不变，多次调用 <code>cacheAdd</code>方法，并不会执行 <code>add</code>方法，而是会直接返回缓存值。上面的代码也可以写成这样：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { cache } from \"react\";\n\nconst add = cache((a: number, b: number) =&gt; {\n  return a + b;\n});\n\nadd(1, 2); // 3\nadd(1, 2); // 3</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">接下来的事情就简单了，只需要在读取和渲染文章的方法外包裹 <code>cache</code>就能提高性能：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">export const getPostBySlug = cache((slug: string, fields: string[] = []) =&gt; {\n  // ...\n});</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">顺便提一下，本人参与开发的评论系统「retalk」也大量使用了缓存提高性能</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但现在依然有一个问题，现在服务端在收到请求后，会根据请求路径中的 slug 查找文章，并读取文章内容，但当文件不存在时，node 的 fs api 就会抛出错误，使 <code>getPostBySlug</code>方法没有返回任何内容，进而导致服务端返回 500，所以我们需要在 <code>getPostBySlug</code>方法中检测 slug 是否存在，若不存在则返回空对象而不是没有返回值：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">if (!fs.existsSync(fullPath)) {\n  return items;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在调用时检测返回对象是否包含 slug：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">if (!post.title) {\n  return notFound();\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>notFound()</code>是 Next.js 提供的方法，可以手动返回 404。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这时，我们再尝试访问不存在的文章，服务端会返回 404，而非 500。</p>\n<h2>元数据: 从 next/head 到 Next Metadata</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在 Pages Router 中，我们可以在页面中返回 <code>Head</code>组件自定义页面的元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import Head from \"next/head\";\n\nexport default function PageA() {\n  return (\n    &lt;Head&gt;\n      &lt;title&gt;Your Title&lt;/title&gt;\n    &lt;/Head&gt;\n  );\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">而在 App Router 中，我们可以通过导出 <code>metadata</code>的方法设置元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"Your Title\",\n};</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">简介等属性同理</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">除了静态导出，我们还可以通过导出 <code>generateMetadata</code>函数实现动态设置元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export async function generateMetadata({\n  params,\n}: {\n  params: { slug: string };\n}): Promise&lt;Metadata&gt; {\n  const post = getPostBySlug(params.slug, [\"title\", \"content\"]);\n  if (!post.title) {\n    return {\n      title: `404 - ${config.name}`,\n    };\n  }\n  return {\n    title: `${post.title} - ${config.name}`,\n    description: post.content.slice(0, 200),\n  };\n}</code></pre>\n<h2>Markdown 渲染: 从 remark 到 marked</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在以往的版本中，我使用 <code>remark</code>完成 Markdown 的渲染，但我逐渐发现，remark 逐渐无法满足我的需求，所以更换到 <code>marked</code>。marked 支持自定义渲染器，可以更方便的修改渲染逻辑。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本站的 markdown 渲染被封装到了一个 <code>markdownToHtml</code>函数，所以更改渲染器十分方便：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">export default async function markdownToHtml(markdown: string) {\n  const renderer = new marked.Renderer();\n\n  renderer.code = function (code, language) {\n    // 添加hljs类和data-language属性\n    let lang = language ? language.toUpperCase() : \"\";\n    if (!language) {\n      lang = \"TEXT\";\n    }\n    if (language == \"\") {\n      language = \"plaintext\";\n    }\n    const highlightedCode = highlightjs(code, language);\n    return `&lt;pre class=\"hljs language-${lang}\" data-language=\"${lang}\"&gt;\n      &lt;code&gt;${highlightedCode}&lt;/code&gt;\n    &lt;/pre&gt;`;\n  };\n  return marked.parse(markdown, { mangle: false, headerIds: false, renderer });\n}</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">完整的渲染器代码较长，此处仅展示部分代码，可能无法单独使用</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">React 无法直接将 html 嵌入到组件作为子元素使用，但提供了属性 <code>dangerouslySetInnerHTML</code>供开发者显示 html 字符串，所以在这里可以这样写：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default async function Post({ params }: { params: { slug: string } }) {\n  const post = getPostBySlug(params.slug, [\n    \"title\",\n    \"date\",\n    \"slug\",\n    \"cover\",\n    \"content\",\n  ]);\n  if (!post.title) {\n    return notFound();\n  }\n  const content = await markdownToHtml(post.content || \"\");\n  return (\n    &lt;&gt;\n      &lt;Card title={post.title} cover={post.cover} label={post.date.toString()}&gt;\n        &lt;div&gt;\n          &lt;div&gt;{post.desc}&lt;/div&gt;\n          &lt;div dangerouslySetInnerHTML={{ __html: content }} /&gt;\n        &lt;/div&gt;\n      &lt;/Card&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<h2>代码高亮: 自定义主题</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以往版本中，正文部分所使用的代码高亮主题是由 <code>github-markdown-css</code>提供的，我逐渐发现其设计不满足我的需求，便进行了自定义。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">代码高亮配色我觉得没有必要更改，但是 <code>highlight.js</code>提供的主题不支持深色模式，我就不得不手写配色。我将包含深色模式的配色放到了全局变量中：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">:root {\n  --pre: #fafafa;\n  --pre-comment: #6a737d;\n  --pre-string: #032f62;\n  --pre-literal: #032f62;\n  --pre-keyword: #d73a49;\n  --pre-function: #6f42c1;\n  --pre-deleted: #24292e;\n  --pre-class: #22863a;\n  --pre-property: #005cc5;\n  --pre-namespace: #6f42c1;\n  --pre-punctuation: #24292e;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --pre-comment: #757575;\n    --pre-string: #977cdc;\n    --pre-literal: #c64640;\n    --pre-keyword: #77b7d7;\n    --pre-function: #86d9ca;\n    --pre-deleted: #fff;\n    --pre-class: #dfab5c;\n    --pre-property: #77b7d7;\n    --pre-namespace: #86d9ca;\n    --pre-punctuation: #fff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">然后在 highlight.js 提供的默认主题基础上做修改，将颜色从固定值改为变量：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.hljs {\n  color: var(--text);\n  background: var(--pre);\n}\n.hljs-doctag,\n.hljs-keyword,\n.hljs-meta .hljs-keyword,\n.hljs-template-tag,\n.hljs-template-variable,\n.hljs-type,\n.hljs-variable.language_ {\n  color: var(--pre-keyword);\n}\n.hljs-title,\n.hljs-title.class_,\n.hljs-title.class_.inherited__,\n.hljs-title.function_ {\n  color: var(--pre-function);\n}</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">此处因篇幅原因只展示部分</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">原有代码块并没有直接显示语言，容易产生歧义。出现了以下设计方案：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230712213628.png\" alt=\"两种方案\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">显然第一种更显眼并具有设计感。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">具体实现我使用了 <code>before</code>伪类的方式，通过 <code>attr(data-language)</code>读取自定义渲染器所输入的语言名称：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">return `&lt;pre class=\"hljs language-${lang}\" data-language=\"${lang}\"&gt;\n      &lt;code&gt;${highlightedCode}&lt;/code&gt;\n    &lt;/pre&gt;`;</code></pre>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">pre::before {\n  color: var(--text-l);\n  opacity: 0.25;\n  content: attr(data-language);\n  font-size: 1.625rem;\n  font-weight: 700;\n  position: absolute;\n  right: 0.5rem;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">至此完成了代码块的修改。</p>\n<h2>CSS: Atomic CSS In JS</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">传统的css在使用重复布局时回产生大量冗余，例如以下三个类：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.a {\n  padding: 1.125rem;\n  color: pink;\n}\n\n.b {\n  padding: 1.125rem;\n  color: skyblue;\n}\n\n.c {\n  margin: 1.125rem;\n  color: pink;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">可以看见，<code>pading: 1.125rem</code>与 <code>color: pink</code>被在css中出现了多次，现在这个css文件共有6个属性。我们可以将它们拆分，封装成4个类：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.p-125 {\n  pading: 1.125rem;\n}\n\n.color-pink {\n  color: pink;\n}\n\n.color-skyblue {\n  color: skyblue;\n}\n\n.m-125 {\n  margin: 1.125rem;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在html中我们可以直接使用这些类的组合实现与第一种方式相同的效果，这就是原子化css。使用原子化设计的css只出现了4个属性。不难看出，原子化css能够减少css的体积。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在实际使用中，我们往往会使用已经绑定好的原子化css库，例如tailwindcss等。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但是，这种做法会导致代码中有一大串的类名，显然不够优雅。所以，我使用了 <code>style9</code>，实现atomic css in js，您可以打开devtools查看效果。</p>\n<h2>布局设计: 拥抱双飞翼</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以往版本的博客使用单栏设计，只留出中间一栏展示所有信息，这样做实现简单，但会导致比较单调。在新博客的设计中，我采用了「双飞翼」布局，即三栏布局：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131357.png\" alt=\"三栏布局\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">将布局拆分为 <code>Sidebar</code>与 <code>Content</code>，使用Next App Router可以实现路由跳转只加载 <code>Content</code>。具体实现使用 <code>CSS Flex</code>布局。</p>\n<h2>基础设计: Card</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如你所见，本站现在的所有组件都是卡片，基础是一个具有 <code>title</code>，<code>label</code>，<code>content</code>，<code>size</code>，<code>cover</code>等众多属性的组件：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131238.png\" alt=\"布局演示\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以此保证样式的统一。</p>\n<h2>深色模式: CSS变量</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">深色模式能够提高用户体验，为了实现深色模式，我为深色模式单独设计了配色，并通过 <code>@media (prefers-color-scheme: dark)</code>实现根据系统设置自动切换。</p>\n<h2>友情链接: 从静态到动态</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以往的友情链接是静态储存的，这样做难免会有局限性，在新版博客中，我将友情链接数据迁移到了GitHub仓库，并通过 <code>Chuqi CDN</code>实时获取友情链接信息。</p>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">你想与101互换友情链接吗，那就看看下面的步骤吧</p></blockquote>\n<h3>前置条件</h3>\n<ul>\n<li>友情链接，先友后链，所以最好是101比较眼熟的朋友</li>\n<li>您的网站不是免费域名，包括但不限于：\n<ul>\n<li>由Freenom公司运营的 <code>.tk</code>，<code>.ml</code>等免费域名（不包括付费购买的域名）</li>\n<li>由 Joshua Anderson 运营的 Afraid FreeDNS 提供的免费子域名</li>\n<li>其他不包含在 Public Suffix List 中的 <strong>免费子域名</strong> 服务</li>\n<li>\n<code>*.github.io</code>，<code>*.gitee.io</code>等域名</li>\n</ul>\n</li>\n<li>不能是采集站！！！！！！！！！</li>\n<li>有三篇以上的原创文章（包括三篇）</li>\n<li>站点上有我的链接</li>\n</ul>\n<h3>我的信息</h3>\n<pre class=\"language-json lang-json\"><code class=\"language-json lang-json\">{\n  \"name\": \"Redish101 Blog\",\n  \"desc\": \"人文 科技 白日梦\",\n  \"icon\": \"https://blog.redish101.top/favicon.ico\",\n  \"link\": \"https://blog.redish101.top\"\n}</code></pre>\n<h3>添加</h3>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">仓库: <a href=\"https://github.com/Redish101/friend-links\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">https://github.com/Redish101/friend-links</a></p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果你满足前置条件，就可以开始提交。</p>\n<ol start=\"1\">\n<li>Fork本仓库</li>\n<li>更改data.json</li>\n<li>添加你的网站</li>\n<li>向本仓库提交pr</li>\n<li>等待审核</li>\n<li>审核完成后将会在Redish101 Blog下次构建时生效</li>\n</ol>\n<h2>尾声</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">感谢阅读</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-component#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1689195790}, {"title": "Termux 安装xLog", "author": "Utermux博客", "pubDate": "2023-05-06 10:04:00", "link": "https://blog.utermux.dev/ut/xLog.html", "description": "Termux 安装xLog", "categories": [], "time": 1683338640}, {"title": "Termux安装各版本gcc", "author": "Utermux博客", "pubDate": "2023-04-30 08:32:00", "link": "https://blog.utermux.dev/ut/gcc.html", "description": "Termux安装各版本gcc", "categories": [], "time": 1682814720}, {"title": "Termux安装Vscode以及code-server", "author": "Utermux博客", "pubDate": "2023-04-30 08:29:15", "link": "https://blog.utermux.dev/ut/vscode.html", "description": "Termux安装Vscode以及code-server", "categories": [], "time": 1682814555}, {"title": "使用Fiber Starter开始一个Golang Web后端项目", "author": "Redish101博客", "pubDate": "2023-04-16 07:11:45", "link": "https://blog.redish101.top/article/fiber-starter", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230416152822.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/fiber-starter\">https://blog.redish101.top/article/fiber-starter</a>\n</blockquote>\n<div>\n<h2>什么是Fiber</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Fiber是一个轻量级的Golang Web框架。</p>\n<h2>什么是Fiber Starter</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">不同于Java Web开发，开始一个Golang Web框架是很繁琐的，你需要: 设计目录结构、制作许多简单但繁琐的小工具..........如果项目更复杂些，你还需要: docker、docker-compose、make......... 这个初始化的过程往往耗费时间。为了解决这个问题，我把自己的起手模板稍微修改了下，并公开到Github：<a href=\"https://github.com/Redish101/fiber-starter\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">Redish101/fiber-starter</a>，帮助大家解决这个问题。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这个项目包含了基于Git的版本信息获取，Make构建、Docker&amp;Docker Compose、CLI等实用的功能。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { remark } from \"remark\";\nimport html from \"remark-html\";\n\nexport default async function markdownToHtml(markdown: string) {\n  const result = await remark().use(html).process(markdown);\n  return result.toString();\n}</code></pre>\n<pre class=\"\"><code class=\"\">XHU4YmY3XHU1NzI4XHU2M2E3XHU1MjM2XHU1M2YwXHU2MjY3XHU4ODRjXHUwMDZiXHUwMDY1XHUwMDc5XHU1MWZkXHU2NTcw</code></pre>\n<h2>项目目录结构</h2>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">├── Makefile # Make配置文件(本项目使用Make管理构建)\n├── bin # 构建输出目录\n│   └── fiber-starter\n├── cmd # CLI\n│   ├── root.go\n│   └── server.go\n├── config # 一些配置文件\n│   ├── app.go # 应用程序相关\n│   └── version.go # 版本信息，会在构建时通过Git获取\n├── docker-compose.yml # Docker Compose 配置文件\n├── dockerfile # Dockerfile\n├── go.mod\n├── go.sum\n├── internal # 核心部分\n│   ├── handler # handler\n│   │   └── home.go # 默认的demo\n│   ├── server # 服务器相关操作\n│   │   ├── route.go\n│   │   └── server.go\n│   └── utils # 零碎的小工具\n│       └── res.go # 格式化相应\n└── main.go</code></pre>\n<h2>如何使用</h2>\n<h3>准备工作</h3>\n<ul>\n<li>能够熟练使用ide进行查找与替换</li>\n<li>基本的Git使用经验</li>\n<li>Github账号</li>\n<li>Make(本项目使用Make管理构建，所有构建操作请使用Make执行，否则可能会出现许多问题)</li>\n</ul>\n<h3>获取代码</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Github提供了方便的模板功能，进入本项目<a href=\"https://github.com/Redish101/fiber-starter\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">仓库</a>，点击右上角的<code>Use this template</code></p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230416152822.png\" alt=\"image-20230416152821767\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">点击<code>Create a new repository</code>，在接下来的页面内更改仓库信息，完成后，点击下方<code>Create repository from template</code>。</p>\n<h3>修改信息</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">你需要在修改这几个文件，完成初始化:</p>\n<h4>Makefile</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">修改文件开头的部分变量:</p>\n<ul>\n<li>APP_NAME 应用程序名称</li>\n<li>PKG_NAME 包名</li>\n<li>BIN_NAME 构建输出路径</li>\n</ul>\n<h4>go.mod</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">修改第一行的包名，与上一步在Makefile中设置的一致。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">修改包名后，你需要使用ide的替换功能，将目录内所有的<code>github.com/Redish101/fiber-starter</code>替换为你修改的包名。</p>\n<h4>dockerfile</h4>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果不需要Docker，请忽略此项</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">将21行的<code>/bin/fiber-starter</code>更改为在Makefile中设置的<code>BIN_NAME</code>。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">修改最后一行的<code>fiber-starter</code>，设置为在Makefile中设置的<code>BIN_NAME</code></p>\n<h4>docker-compose</h4>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果不需要docker-compose，请忽略此项</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">根据需求更改。</p>\n<h4>internal/utils/res.go</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">根据需要，修改第五行的返回数据格式。</p>\n<h4>config/app.go</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">修改<code>AppName</code>，可以选择性的删除后面的版本号。</p>\n<h3>开发</h3>\n<h4>Handler</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">handler应存放在<code>internal/handler</code>，每个handler应该是这样的格式:</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">package handler\n\nimport (\n    \"github.com/Redish101/fiber-starter/internal/utils\"\n    \"github.com/gofiber/fiber/v2\"\n)\n\nfunc Home(c *fiber.Ctx) error {\n    return utils.Res(c, true, \"Fiber Starter成功启动\", nil)\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">其中<code>utils.Res</code>函数是标准化响应工具，需要传入这几个参数：</p>\n<ul>\n<li>c handler的Ctx</li>\n<li>ok 操作是否成功</li>\n<li>msg 提示信息</li>\n<li>data 返回数据，可以为任何类型</li>\n</ul>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">完成后，应当在<code>internal/server/route.go</code>中注册路由。在<code>initRoutes</code>函数末尾增加路由注册代码，它看起来应该像这样：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">app.Get(\"/\", handler.Home)</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">其中<code>\"/\"</code>为路径，<code>handler.Home</code>为Handler函数。</p>\n<h3>开发运行</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">运行<code>make dev</code>。</p>\n<h3>开发构建</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">运行<code>make build-debug</code>。使用本命令构建的可执行文件可以使用gdb进行调试，且版本号为<code>dev-xxxxxx</code>。</p>\n<h3>生产构建</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">运行<code>make all</code>。使用本命令构建的可执行文件不可以使用gdb进行调试，且版本号为最新的标签。</p>\n<h3>构建Docker镜像</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">运行<code>make build-docker</code>。</p>\n<h2>结语</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这篇文章就到这里了，如果觉得项目还不错的话就点点Star吧，谢谢了。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/fiber-starter#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1681600305}, {"title": "为我的网站添加深色模式", "author": "Redish101博客", "pubDate": "2023-03-28 13:06:55", "link": "https://blog.redish101.top/article/darkmode", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/darkmode\">https://blog.redish101.top/article/darkmode</a>\n</blockquote>\n<div>\n<h2>我们为什么需要「深色模式」</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">不可避免的，我们在很多时候需要在黑暗的环境下访问网站，而在黑暗的环境下，如果网站依然有大部分亮色区域，会在瞬间使眼睛受到刺激，极大的降低了用户体验。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">同时，深色模式能减少OLED屏幕的功耗，延长设备的使用时间这也是很多人在白天也依然打开深色模式的原因。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如今，很多操作系统已经支持了深色模式，macos也提供了很好的深色模式支持。Chrome、FireFox等主流浏览器也已经支持通过<code>prefers-color-scheme</code>单独定义深色模式下的样式，这也降低了我们制作深色模式的难度。</p>\n<h2>「深色模式」的切换逻辑</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">前面提到，我们可以通过<code>prefers-color-scheme</code>来单独定义深色模式的样式，而<code>prefers-color-scheme</code>是跟随系统的，显然，这种方式可以较好符合用户的个人喜好。</p>\n<h3>\n<code>prefers-color-scheme</code>的兼容问题</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">的确，<code>prefers-color-scheme</code>对于低版本的浏览器适配并不友好，但是考虑到本站用户群体，这种问题几乎不会发生(其实是我懒)，所以就没有做过多处理。</p>\n<h2>「深色模式」的前端实现</h2>\n<h3>单独编写样式</h3>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">body {\n  color: #000;\n}\n\n@media (prefers-color-scheme: dark) {\n  body {\n    color: #fff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">显然，这种方式繁琐且复杂。</p>\n<h3>使用CSS Variable</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本站的配色信息都是以CSS Variable的形式存放在一个单独的css(global.css)中的，并在其他的css文件中可以直接通过<code>var(xxxx)</code>引用，所以，我们可以为深色模式和亮色模式设计两种配色，并通过第一种方法实现，就可以实现自动的深色模式切换。</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">:root {\n  --bg: #f2f5f8;\n  --card-bg: #fff;\n  --text: #000;\n  --link: #007bff;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --bg: #0d1117;\n    --card-bg: #161b22;\n    --text: #c9d1d9;\n    --link: #58a6ff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本站就是用的这种方法，在你的系统设置中切换配色即可体验。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/darkmode#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1679980015}, {"title": "使用Next.js重构我的博客", "author": "Redish101博客", "pubDate": "2023-03-04 04:33:10", "link": "https://blog.redish101.top/article/blog-v5", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193114.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193416.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/blog-v5\">https://blog.redish101.top/article/blog-v5</a>\n</blockquote>\n<div>\n<h2>技术选型</h2>\n<h3>React VS Vue</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在这两者之间，我对React的使用更加熟练些，而且我认为使用TSX开发React应用的体验是愉悦的，所以选择React。</p>\n<h3>Gatsby VS Next.js</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这两者都是十分优秀的React框架，但我一直无法成功配置Gatsby环境，而且考虑到应用以后可能使用服务端渲染，所以选择Next.js。</p>\n<h3>SSR VS SSG</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">博客目前并没有一些复杂的功能需要使用SSR实现，为了节省性能，选择了Next.js的SSG（以后会计划开发管理后台，所以以后可能会更换为SSR）。</p>\n<h2>UI设计</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">为了提高界面主题的美观，降低实现的难度，我设计了较为简单（简陋）的ui，并做了移动端适配，尽量让移动端的用户能有较好的体验。</p>\n<h2>内容管理</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">最开始，我准备效仿苏卡卡，使用hexo管理文章，但在进行一段时间的开发后，发现我对hexo api的了解无法满足使用。最后，我选择将文章储存为Markdown文件，并在每次更新后将其渲染为静态页面。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在众多Markdown渲染库中，我选择使用比较简单易用的 <code>remark</code>将markdown渲染为html：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { remark } from \"remark\";\nimport html from \"remark-html\";\n\nexport default async function markdownToHtml(markdown: string) {\n  const result = await remark().use(html).process(markdown);\n  return result.toString();\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">搞定正文的渲染，还有一个问题，由于并没有使用数据库文章信息，所以需要将文章信息放到 <code>front matter</code>内，再在构建时解析，转换为js能够读取的数据格式，并储存到页面的 <code>props</code>中，供前端使用。在处理 <code>front-matter</code>中，我选择了 <code>gray-matter</code>。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在读取Markdown并处理后，需要将文章数据传递给前端，供前端使用，但我并没有使用SSR，所以无法做到获取实时的文章数据，但得益于强大的Next.js，我们可以通过 <code>getStaticProps</code>，<code>getStaticPaths</code>在执行构建时获取数据，储存到props中，例如文章详情页的数据可以这样获取：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">export async function getStaticPaths() {\n  const posts = getAllPosts([\"slug\"]);\n\n  return {\n    paths: posts.map((post) =&gt; {\n      return {\n        params: {\n          slug: post.slug,\n        },\n      };\n    }),\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }: any) {\n  const post = getPostBySlug(params.slug, [\"title\", \"date\", \"slug\", \"content\"]);\n  const content = await markdownToHtml(post.content || \"\");\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content,\n      },\n    },\n  };\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这样在前端就可以十分方便的使用数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default function Post(props: props) {\n  const router = useRouter();\n  const post = props.post;\n  const title = `${post.title} | Redish101 Blog`;\n  if (!router.isFallback &amp;&amp; !post?.slug) {\n    return &lt;Error404 /&gt;;\n  }\n  return (\n    &lt;&gt;\n      &lt;Head&gt;\n        &lt;title&gt;{title}&lt;/title&gt;\n      &lt;/Head&gt;\n      &lt;PostBody title={post.title} date={post.date} content={post.content} /&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<h2>样式实现</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在众多css in js库中，我选择了 <code>griffel</code>，它可以自动生成随机的类名，对于我这种起名困难党算是个福音，其次，它使用起来也十分的顺畅，只需要使用 <code>makeStyles()</code>定义样式，即可通过 <code>useStyles()</code>使用样式。使用它定义样式，在编码过程中ide会给出效果较好的代码提示：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193114.png\" alt=\"\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在开发的过程中节约了很多时间，生成的随机类名可以很好的避免类名重复导致的错误：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193416.png\" alt=\"\"><h2>一言</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在新版博客的首页，我将原来固定的副标题替换为从一言api获取一句质量较高的话作为副标题，数据的获取与文章数据的获取一样，都使用 <code>getStaticProps</code>在构建时获取，所以一言的更新频率完去取决于我的更新频率。</p>\n<h2>部署</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">网站的部署有以下几个选择：服务器部署，vercel，netlify。前面说过，本站是静态网站，所以如果选择服务器部署，在每次内容更新后都需要上传到服务器，浪费时间，即使使用ci，服务器由于地域原因也无法从GitHub拉取网站源码进行构建，所以率先出局。在vercel和netlify中我选择vercel，一是使用熟练，二是对Next.js有较好的支持，若是以后更改为ssr也很方便。</p>\n<h2>重构博客给我带来了什么</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Nextjs SSG网站的性能明显是要好于动态博客的，而且构建速度也比之前用Hexo的时候更快。而且自己造的轮子，自己肯定更熟悉，改起来也方便。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/blog-v5#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1677875590}, {"title": "非4k显示器开启hidpi", "author": "Yume.KISEKI", "pubDate": "2023-02-11 04:29:27", "link": "https://www.monoko.jp/enable-hidpi/", "description": "\n<p>macOS想要完美体验hidpi只能是换上4k及以上显示器，如果用上苹果自家的6K Pro Display X […]</p>\n<p><a href=\"https://www.monoko.jp/enable-hidpi/\">非4k显示器开启hidpi</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "BetterDisplay", "hidpi", "macOS"], "time": 1676060967}, {"title": "Artalk公益服务 已阵亡", "author": "小N同学的博客", "pubDate": "2023-02-04 16:49:39", "link": "https://www.imcharon.com/1505/", "description": "自从4月15日以来，服务器经受了长期DDoS，目前已经彻底放弃抵抗了，没办法了。", "categories": ["往日余生", "公益服务"], "time": 1675500579}, {"title": "Pro App 教育套装", "author": "Yume.KISEKI", "pubDate": "2023-02-02 14:24:50", "link": "https://www.monoko.jp/pro-app/", "description": "\n<p>一个Final Cut Pro多少钱？是1998元 一个教育优惠套装多少钱？是1298元(前几年是1543元) […]</p>\n<p><a href=\"https://www.monoko.jp/pro-app/\">Pro App 教育套装</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "Apple教育优惠", "Final Cut Pro"], "time": 1675319090}, {"title": "memos纯公益代部署服务", "author": "小N同学的博客", "pubDate": "2023-02-02 03:01:14", "link": "https://www.imcharon.com/1467/", "description": "具体memos参考基于Memos实现说说和清单功能。 | Leonus 云备份，每天备份数据至onedrive […]", "categories": ["往日余生", "公益服务"], "time": 1675278074}, {"title": "windows手动安装哪吒探针客户端", "author": "wututu-blog", "pubDate": "2023-01-30 18:30:31", "link": "https://blog.wututu.cn/nztz-for-windows/", "description": "以针会友，几乎成了吃灰服务器的标配行为，得益于最近火起来的哪吒探针，我也搭建了自己的探针平台，数据直观且美观，兼具实用与装 13特 ...", "categories": ["未分类"], "time": 1675074631}, {"title": "网站迁移完成，如有BUG欢迎留言", "author": "wututu-blog", "pubDate": "2023-01-30 18:04:37", "link": "https://blog.wututu.cn/gx/", "description": "", "categories": ["未分类"], "time": 1675073077}, {"title": "一款好用的摄影包——Bellroy Venture Sling 10L", "author": "Yume.KISEKI", "pubDate": "2023-01-15 13:40:21", "link": "https://www.monoko.jp/bellroy-venture-sling-10l/", "description": "\n<p>终于还是灭门了佳能，转而马上投入大法的怀抱，真香。话说都2023年了确实早已是无反的时代了，还好我的5d4和它 […]</p>\n<p><a href=\"https://www.monoko.jp/bellroy-venture-sling-10l/\">一款好用的摄影包——Bellroy Venture Sling 10L</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "Bellroy"], "time": 1673761221}, {"title": "Termux安装maturin模块", "author": "Utermux博客", "pubDate": "2023-01-09 06:15:00", "link": "https://blog.utermux.dev/ut/maturin.html", "description": "Termux安装maturin模块", "categories": [], "time": 1673216100}, {"title": "Termux安装mitmproxy", "author": "Utermux博客", "pubDate": "2022-12-26 07:08:00", "link": "https://blog.utermux.dev/ut/mitmproxy.html", "description": "Termux安装mitmproxy", "categories": [], "time": 1672009680}, {"title": "解决acme.sh签发SSL证书失败", "author": "Yume.KISEKI", "pubDate": "2022-12-18 04:39:26", "link": "https://www.monoko.jp/create-ssl-with-acme-sh/", "description": "\n<p>前段时间在甲骨文云成功开了台arm的机器后一直闲置没用，最近看到甲骨文云开始有回收清理白嫖机器的动作了，吓得我 […]</p>\n<p><a href=\"https://www.monoko.jp/create-ssl-with-acme-sh/\">解决acme.sh签发SSL证书失败</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["vps", "acme.sh"], "time": 1671309566}, {"title": "「古典文法」推量系の助動詞の関係性", "author": "Yume.KISEKI", "pubDate": "2022-12-04 07:34:51", "link": "https://www.monoko.jp/suiryokei-no-jyodoushi/", "description": "\n<p>不难发现在助动词中有那么一堆词都带有推定的意思，我们可以称之为推量系助动词，对于这些词之间的关系总结如下图，可 […]</p>\n<p><a href=\"https://www.monoko.jp/suiryokei-no-jyodoushi/\">「古典文法」推量系の助動詞の関係性</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["古典文法", "助动词", "推量系", "日语古文"], "time": 1670110491}, {"title": "好用的ssh客户端工具—electerm", "author": "Yume.KISEKI", "pubDate": "2022-11-30 14:13:22", "link": "https://www.monoko.jp/ssh-electerm/", "description": "\n<p>前段时间偶然发现一款开源ssh客户端——electerm，三大平台全能型，多语言支持，支持sftp并且能直接编 […]</p>\n<p><a href=\"https://www.monoko.jp/ssh-electerm/\">好用的ssh客户端工具—electerm</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["software", "electerm"], "time": 1669788802}, {"title": "异常低价的CleanMyMac X", "author": "Yume.KISEKI", "pubDate": "2022-11-20 02:30:00", "link": "https://www.monoko.jp/low-price-of-cleanmymac/", "description": "\n<p>近期需要用到笔记本电脑一段时间，也就突然想到还有台14款的mbp正好可以拿来用段时间，系统是一代代升级到了最终 […]</p>\n<p><a href=\"https://www.monoko.jp/low-price-of-cleanmymac/\">异常低价的CleanMyMac X</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["software", "CleanMyMac X"], "time": 1668882600}, {"title": "遭遇xmrig挖矿病毒", "author": "Yume.KISEKI", "pubDate": "2022-10-21 15:39:10", "link": "https://www.monoko.jp/cryptojacking-xmrig/", "description": "\n<p>起因 前段时间conoha为纪念突破50万用户大搞活动，看着优惠力度和近期的日元汇率是真的香！但太久没用con […]</p>\n<p><a href=\"https://www.monoko.jp/cryptojacking-xmrig/\">遭遇xmrig挖矿病毒</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["vps", "xmrig"], "time": 1666337950}, {"title": "Linux/Windows系统安装最新版JAVA教程", "author": "wututu-blog", "pubDate": "2022-10-18 18:00:18", "link": "https://blog.wututu.cn/linux-windows-install-java/", "description": "<div class=\"wp-block-jetpack-markdown\">\n<h2>说明</h2>\n<p>我们很多时候都需要用到JAVA环境，这里博主就记录下安装过程。</p>\n<h2>1、获取最新版JAVA下载链接</h2>\n<p>首先进入JAVA下载地址：点击进入，再点击中间框框右下角的<code>JDK Download</code>按钮进入下载界面，然后点击<code>Accept License Agreement</code>，这时候就可以点击一下对应版本的<code>JAVA JDK</code>包，浏览器下载器会弹出来文件下载，这时候就可以复制下载链接了。\n注意别直接将<code>jdk</code>包的超链接当成下载链接，这样下载会出错的。</p>\n<h2>2、Linux安装</h2>\n<p>这里<code>CentOS</code>、<code>Debian</code>、<code>Ubuntu</code>等常见Linux系统都可以用以下方法安装JAVA。</p>\n<pre><code>#下载JAVA JRE包，将你获取的链接替换到后面，下载链接通常为http://xx/jdk_linux-x64.tar.gz?AuthParam=xx\nwget -O jdk.tar.gz http://xx/jdk_linux-x64.tar.gz?AuthParam=xx\n#解压文件\ntar -zxvf jdk.tar.gz\n#记住这时候解压出的文件夹路径，比如目前为/root/jdk1.8.0_191\n</code></pre>\n<p>编辑<code>/etc/profile</code>文件：</p>\n<pre><code>编辑/etc/profile文件：\n</code></pre>\n<p>在后面添加以下代码：</p>\n<pre><code>#前2行后面的参数为解压出的JAVA文件夹路径\nJAVA_HOME=/root/jdk1.8.0_191\nexport JRE_HOME=/root/jdk1.8.0_191/jre \nexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH \nexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH\n</code></pre>\n<p>使配置生效：</p>\n<pre><code>source /etc/profile\n</code></pre>\n<p>查看JAVA版本：</p>\n<pre><code>java -version\n</code></pre>\n<h2>3、Windows系统安装</h2>\n<p>获取JAVA JRE包的方法参考上面，然后直接下载Win版本的点击安装即可。</p>\n</div>", "categories": ["教程", "软件"], "time": 1666087218}, {"title": "Linux VPS一键添加/删除Swap虚拟内存", "author": "wututu-blog", "pubDate": "2022-10-17 17:55:42", "link": "https://blog.wututu.cn/linux-vps-swap/", "description": "\n<div class=\"wp-block-jetpack-markdown\">\n<h2>脚本</h2>\n<p>提示：脚本不支持<code>OpenVZ</code>架构，安装会自动退出。\n运行命令：\n国外机器</p>\n<pre><code>wget https://cdn.jsdelivr.net/gh/wututua/file@master/swap.sh &amp;&amp; bash swap.sh\n</code></pre>\n<p>国内机器</p>\n<pre><code>wget https://gitee.com/wututua/file-storage-warehouse/raw/master/swap.sh &amp;&amp; bash swap.sh\n</code></pre>\n<p>然后根据选项进行操作，记得添加<code>swap</code>的时候填写纯数字，默认单位为<code>M</code>。</p>\n</div>\n\n\n\n<figure class=\"wp-block-image size-large\"><img decoding=\"async\" src=\"https://i0.wp.com/cdn.jsdelivr.net/gh/wututua/image@master/img/swap_add.png?w=640&amp;ssl=1\" alt=\"\" data-recalc-dims=\"1\"></figure>\n", "categories": ["未分类"], "time": 1666000542}, {"title": "主流 Markdown 编辑器推荐", "author": "wututu-blog", "pubDate": "2022-10-16 17:54:57", "link": "https://blog.wututu.cn/markdown/", "description": "开头 Markdown ，2004年由 John Gruberis 设计和开发，是一种可以使用普通文本编辑器编写的标记语言，通过简 ...", "categories": ["软件"], "time": 1665914097}, {"title": "iptables一键配置端口转发脚本，支持tcp和udp", "author": "wututu-blog", "pubDate": "2022-10-15 17:50:01", "link": "https://blog.wututu.cn/iptables/", "description": "<div class=\"wp-block-jetpack-markdown\">\n<h2>iptables</h2>\n<p>iptables是一款非常强大的防火墙管理工具，同样支持端口转发，同时也支持端口段转发。上一篇文章使用iptables进行端口转发配置对于小白非常不友好，自然在网络上面找到了一键脚本，对小白非常友好，可视化的UI配置界面。</p>\n<h2>系统要求</h2>\n<p>支持Centos / Debian / Ubuntu 14.04 +\n推荐 Debian / Ubuntu，这个是我一直使用的系统，我的脚本在这个系统上面出错率最低。\nCentOS 7 默认的防火墙是 firewall，要使用本脚本，请先卸载或关闭 firewall 服务器，并安装 iptables 全套软件。</p>\n<h2>安装说明</h2>\n<p>下载iptables一键配置端口转发脚本，并赋予执行权限运行</p>\n<pre><code>wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/iptables-pf.sh &amp;&amp; chmod +x iptables-pf.sh &amp;&amp; bash iptables-pf.sh\n</code></pre>\n<p>下载并运行脚本后，先选择 1. 安装 iptables ，会检测是否安装 iptables 同时也会进行 iptables 防火墙开机启动加载等配置。</p>\n<h2>使用方法</h2>\n<pre><code>./iptables-pf.sh\n</code></pre>\n<p>运行脚本后，会显示菜单：</p>\n<pre><code>iptables 端口转发一键管理脚本 [vx.x.x]\n \n-- Toyo | doub.io/wlzy-20 --\n \n0. 升级脚本\n \n————————————\n \n1. 安装 iptables\n \n2. 清空 iptables 端口转发\n \n————————————\n \n3. 查看 iptables 端口转发\n \n4. 添加 iptables 端口转发\n \n5. 删除 iptables 端口转发\n \n————————————\n</code></pre>\n<p>注意：初次使用前请请务必执行 1. 安装 iptables(不仅仅是安装)\n请输入数字 [0–5]:\n选择 <code>4. 添加 iptables</code> 端口转发 后，会提示你依次输入 欲转发IP、欲转发端口、本地监听端口、本地IP、转发类型：</p>\n<pre><code>(默认端口: 10000-11000):\n \n本地监听端口 : 10000-11000\n \n请输入 本服务器的 公网IP网卡IP(注意是网卡绑定的IP，而不仅仅是公网IP，回车自动检测):\n \n本服务器IP : 1.1.1.1\n \n请输入数字 来选择 iptables 转发类型:\n \n1. TCP\n \n2. UDP\n \n3. TCP+UDP\n \n(默认: TCP+UDP):\n \n——————————————————————————————\n \n请检查 iptables 端口转发规则配置是否有误 !\n \n本地监听端口 : 10000-11000\n \n服务器 IP : 2.2.2.2\n \n欲转发的端口 : 10000-11000\n \n欲转发 IP : 1.1.1.1\n \n转发类型 : TCP+UDP\n \n——————————————————————————————\n</code></pre>\n<p>最后会提示你确认配置是否有误，如果没有问题就按任意键继续，启动成功后就会提示：</p>\n<pre><code>——————————————————————————————\n \niptables 端口转发规则配置完成 !\n \n本地监听端口 : 10000:11000\n \n服务器 IP : 1.1.1.1\n \n欲转发的端口 : 10000:11000\n \n欲转发 IP : 2.2.2.2\n \n转发类型 : TCP+UDP\n \n——————————————————————————————\n</code></pre>\n<p>选择 <code>3. 查看 iptables 端口转发</code> 后，会显示如下：</p>\n<pre><code>当前有 2 个 iptables 端口转发规则。\n \n1. 类型: tcp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000\n \n2. 类型: udp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000\n</code></pre>\n<p>选择 <code>5. 删除 iptables 端口转发</code> 后，也会显示列表，然后让你选择 要删除的端口转发规则序号。\n就这些啦</p>\n</div>", "categories": ["教程"], "time": 1665827401}, {"title": "Navicat Premium 12安装教程(完整激活版)", "author": "wututu-blog", "pubDate": "2022-10-14 17:49:00", "link": "https://blog.wututu.cn/navicat-premium-12/", "description": "开始 本文所有文件下载 下载地址1 下载地址2 1.安装 1.双击安装，点击下一步： 2.同意协议，点击下一步： 3.选择安装位置 ...", "categories": ["破解"], "time": 1665740940}, {"title": "Navicat Premium 15安装教程(完整激活版)", "author": "wututu-blog", "pubDate": "2022-10-08 17:45:00", "link": "https://blog.wututu.cn/navicat-premium-15/", "description": "写在前面 之前一直忙着工作，趁着休假，加上身边的小伙伴想尝鲜一把最新版的Navicat Premium 15，官网说，最新一版的N ...", "categories": ["未分类"], "time": 1665222300}, {"title": "[通知] 我们的Termux镜像", "author": "Utermux博客", "pubDate": "2022-07-19 08:47:00", "link": "https://blog.utermux.dev/ut/mirror.html", "description": "[通知] 我们的Termux镜像", "categories": [], "time": 1658191620}, {"title": "Github Codespaces初体验", "author": "Redish101博客", "pubDate": "2022-06-10 10:52:04", "link": "https://blog.redish101.top/article/github-codespaces", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610210634.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610211120.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/github-codespaces\">https://blog.redish101.top/article/github-codespaces</a>\n</blockquote>\n<div>\n<h1>这是什么</h1>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在去年，GitHub上线了一个的新功能：<code>Codespaces</code>，使用Codespaces可以随时随地在浏览器里编辑、调试、运行托管在GitHub的代码。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在前几天，GitHub将此功能开放公测，任何用户都能申请使用，我，于是就有了这篇文章。</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610210634.png\" alt=\"邮件\"><h1>性能</h1>\n<h2>硬件配置</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">先说性能，GitHub面对个人项目提供了一台4Cores 8RAM的设备，这性能对于普通的开发那是绰绰有余，话不多说，上bench截图：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610211120.png\" alt=\"测试结果\"><h2>网络</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">配置虽好值得夸赞，但这网络之遭也十分的影响使用，在笔者试用的时候，2个小时中断线了将近十次。虽然大部分时间下编辑器的使用没有发现明显卡顿，但终端在使用时的卡顿是真的让人无法忍受。</p>\n<h2>终端相关</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Github Codespaces的终端是可以通过<code>sudo su</code>进入root用户的，也可以直接通过<code>sudo</code>命令来运行需要root权限的服务。</p>\n<h2>自动休眠</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这是非常重要的一个点，是我们白嫖之路的最大绊脚石，在一段时间（暂未明确结果）内如果编辑器没有活跃，codespace就会自动关闭。</p>\n<h1>写代码</h1>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Codespaces使用了web版本的VS Code，所以说编辑体验是与直接在本地使用Code编辑并无不同，经过测试，也能完美的适配各种插件。运行时方面也无需担心，已经自动预装了docker、python、node、c/cpp等大部分语言的开发环境。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">同时，如果在终端里启动程序的开发服务器时编辑器会自动发现开放的端口并映射到公网，默认是私有的，只有codespace的所有者才能访问，但是可以在图中的这个位置中更改穿透为对外公开，但是101奉劝各位早点死了用这个搭建什么服务的心吧，同GitHub一样，几乎是无法访问，在速度这方面，甚至比不上GitHub Pages。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/github-codespaces#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1654829524}, {"title": "你问我答 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-05-25 14:28:40", "link": "https://www.594594.xyz/2022/05/25/xqa/", "description": "<p>一个适用hoshinobot的你问我答插件</p>", "categories": ["hoshino插件", "功能拓展"], "time": 1653460120}, {"title": "适用小白的快速搭建QQ机器人的超详细教程(可选带马娘插件)2023-10-13更新", "author": "轻音时雨的博客", "pubDate": "2022-03-05 03:10:37", "link": "https://www.594594.xyz/2022/03/05/uma_bot/", "description": "<p>适用小白的快速搭建一个QQ机器人(可选带马娘插件)</p>", "categories": ["游戏相关", "教程", "赛马娘"], "time": 1646421037}, {"title": "docsify - 一个优雅的静态文档生成器", "author": "Redish101博客", "pubDate": "2022-03-04 16:00:00", "link": "https://blog.redish101.top/article/docsify", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/docsify\">https://blog.redish101.top/article/docsify</a>\n</blockquote>\n<div>\n<h2>docsify好在哪里</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">docsify相比于其他的静态文档站点生成器相比更加的简洁，易用。</p>\n<h3> </h3>\n<h4>Sphinx</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">先拿Sphinx来说吧，Sphinx因背后有python的驱动，功能十分强大，但是rst的语法还是比较复杂的</p>\n<h4>Vuepress</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">vuepress更适合大型项目的文档编写，而且维护成本高。</p>\n<h2>使用</h2>\n<h3>安装</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">全局安装Docsify-cli:</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">yarn global add docsify-cli\n# 或者使用npm</code></pre>\n<h3>开始一个项目</h3>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">docsify init &lt;项目路径&gt;</code></pre>\n<h3>配置</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本文不再对配置方面进行过多的论述，可以参考<a href=\"https://docsify.js.org/#/zh-cn/configuration\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">配置项 (docsify.js.org)</a></p>\n<h3>编写</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">docsify会自动识别目录下的所有markdown文件，所以在docs目录新增markdown文件即可编写文档</p>\n<h4>路径问题</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这里要注意一下路径：</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">假设你的目录结构如下：</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">.\n└── docs\n├── README.md\n├── guide.md\n└── zh-cn\n├── README.md\n└── guide.md</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">那么渲染后的路径就是：</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">docs/README.md        =&gt; http://domain.com\ndocs/guide.md         =&gt; http://domain.com/guide\ndocs/zh-cn/README.md  =&gt; http://domain.com/zh-cn/\ndocs/zh-cn/guide.md   =&gt; http://domain.com/zh-cn/guide</code></pre>\n<h2>部署</h2>\n<h3>Github Pages</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">将Github Pages的工作目录设置到docsify所在目录。</p>\n<h3>Vercel</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">选中docsify所在仓库，点击下面的deploy</p>\n<h3>服务器</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">将docsify所在文件夹上传到网站目录即可</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/docsify#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1646380800}, {"title": "马娘功能插件整合版v2.0.1 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-03-04 07:36:40", "link": "https://www.594594.xyz/2022/03/04/uma_plugin/", "description": "<p>一个适用hoshinobot的马娘功能插件整合版</p>", "categories": ["hoshino插件", "赛马娘"], "time": 1646350600}, {"title": "赛马娘模拟抽卡 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-02-05 03:43:40", "link": "https://www.594594.xyz/2022/02/05/uma_gacha_for_hoshino/", "description": "<p>一个适用hoshinobot的赛马娘模拟抽卡插件</p>", "categories": ["hoshino插件", "赛马娘"], "time": 1644003820}, {"title": "ZeroTier One搭建MOON服务器", "author": "轻音时雨的博客", "pubDate": "2022-02-03 03:30:40", "link": "https://www.594594.xyz/2022/02/03/moon_for_zerotier/", "description": "<p>完美解决Tabletop等和好友P2P联机延迟高的解决办法及相关踩坑</p>", "categories": ["游戏相关"], "time": 1643830240}, {"title": "Windows实用小工具教程", "author": "Utermux博客", "pubDate": "2022-01-23 07:55:00", "link": "https://blog.utermux.dev/win/Windows-utilities.html", "description": "Windows实用小工具教程", "categories": [], "time": 1642895700}, {"title": "UTermux/ZeroTermux/TermuxWatch下载链接", "author": "Utermux博客", "pubDate": "2021-12-26 06:53:00", "link": "https://blog.utermux.dev/ut/download.html", "description": "UTermux/ZeroTermux/TermuxWatch下载链接", "categories": [], "time": 1640472780}, {"title": "早安晚安 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:16:12", "link": "https://www.594594.xyz/2021/10/24/good_morning_for_hoshino/", "description": "<p>一个适用hoshinobot的 早安晚安 插件</p>", "categories": ["hoshino插件", "pcr"], "time": 1635016572}, {"title": "pcr签到黄历 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:09:12", "link": "https://www.594594.xyz/2021/10/24/pcr_almanac_for_hoshino/", "description": "<p>一个适用hoshinobot的 pcr签到黄历 插件</p>", "categories": ["hoshino插件", "pcr"], "time": 1635016152}, {"title": "mc数据查询监控 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:00:12", "link": "https://www.594594.xyz/2021/10/24/mc_status_for_hoshino/", "description": "<p>一个适用hoshinobot的 mc数据查询监控 插件</p>", "categories": ["hoshino插件", "mc"], "time": 1635015612}, {"title": "github仓库更新提醒 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-08-23 04:00:12", "link": "https://www.594594.xyz/2021/08/23/github_reminder_for_hoshino/", "description": "<p>一个适用hoshinobot的 github仓库更新提醒 插件</p>", "categories": ["hoshino插件", "github"], "time": 1629662412}, {"title": "职场浮生纪修改器发布", "author": "小N同学的博客", "pubDate": "2021-08-08 17:59:53", "link": "https://www.imcharon.com/54/", "description": "先打开游戏，然后使用管理员身份启动修改器即可。 之前能改很多东西的，现在为什么只能加钱了。 -因为很多基址当时 […]", "categories": ["往日余生", "教程", "精选", "修改器", "职场浮生纪"], "time": 1628416793}]