[{"title": "iPhone16 到手之路", "author": "林木木的博客", "pubDate": "2024-09-28 13:03:05", "link": "https://immmmm.com/buy-iphone16/", "description": "\n<p>如题图， 一看 So Strong，再瞅 So 泄气。</p>\n<p>从11、12年？乔帮主之后的 4s 开启苹果机，然后 8、12，到现在 16 Pro 到手。久远的感触掠过不表，说说 12 –&gt; 16 半日体验。硬件上充电后变 C 口；锁屏后能“全天候显示”；多了两实体按钮（自定义键、相机快捷键）。</p>\n<p>软件上，AI 不可用，而其它更新可忽略不计。</p>\n<h3>到手 <del>（吐槽）</del> 之路</h3>\n<p>头一次13号首发前得到“当家的”同意，想着官网肯定抢不到，选择了🐶东 +99 得一年阉割版 AC 版本，晚8:02 完成支付，等待十几分钟后，显示“10月9日之后发货”……</p>\n<p>13～23号，流水如下：</p>\n<ul>\n<li>次日确认，🐶东就算有货也不发加了 AC 套餐的，统一10月9日之后发。线上客服和 Plus 专员客服都是统一口径。</li>\n<li>次日了解到，官方也排到10月9日之后了。所以，等等就等等吧。有个 AC 总比没有好。</li>\n<li>20号首批发货之后，21、22号小红书上看到说提前发货了，询问🐶东客服依旧咬死不变。</li>\n<li>看了看 PDD 优惠 400，犹豫抢的人应该不少，自己也没掐点抢一抢。</li>\n</ul>\n<p>直到本周一23号下午2点，随意打开多多直接弹出 400 优惠券，而且明显标记“最晚30前发货”，这速度全靠同行衬托。称得上急速。</p>\n<p>下单后问客服得到回复“最晚5天内发货”，果真今天周六28早上到手。实际是26号傍晚从北京发出的，快得令人感动。</p>\n<p>被各平台上的控诉视频吓怕，头一次全程录像拍了开箱视频，验证无磕无碰、无灰无尘，无激活无充电，Over 安全下车。</p>\n<h3>电报小惊吓</h3>\n<p>+86 是收不到验证短信的，开了国际漫游也无用。幸好电脑上还登着，能从 Telegram 服务通知查看到。惊吓自己十几分钟！</p>\n<p>简体中文包(聪聪)、小而美主题链接如下，电报点击即可安装。</p>\n<p><a href=\"tg://setlanguage?lang=zhcncc\">tg://setlanguage?lang=zhcncc</a></p>\n<p><a href=\"https://t.me/addtheme/wechatv8\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://t.me/addtheme/wechatv8</a></p>\n<h3>更多？</h3>\n<p>相机快捷键，目前还不如没有。</p>\n<p>配件？目前已耗费 ¥58 另买了 2 根小米 3A 充电线，一根车上、另一根丢单位；还耗费 ¥216 买了图拉斯 ONeo 支点壳，性价比不高。</p>\n", "categories": ["%E6%97%A5%E5%B8%B8"], "time": 1727499785}, {"title": "如何优雅的截图", "author": "Redish101博客", "pubDate": "2024-09-22 01:30:19", "link": "https://blog.redish101.top/article/how-to-cap-screen", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://userbase.kde.org/images.userbase/thumb/4/48/Taking_Screenshots.png/500px-Taking_Screenshots.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/how-to-cap-screen\">https://blog.redish101.top/article/how-to-cap-screen</a>\n</blockquote>\n<div>\n<blockquote><p class=\"paragraph\">以免有些人在会截图的情况下故意不截图而拍屏，用满是摩尔纹的屏幕恶心群友的眼睛，这里准备了几篇文章来帮助你学会如何截图。如果你被人扔了这篇文章的链接，感到冒犯，不好意思，冒犯的就是你</p></blockquote>\n<h2>如何在 Windows 11 下截图</h2>\n<blockquote><p class=\"paragraph\">翻译自：<a href=\"https://www.microsoft.com/en-us/windows/learning-center/how-to-screenshot-windows-11\" target=\"_blank\" class=\"link\">How to Take Screenshots on Windows 11 | Windows Learning Center</a></p></blockquote>\n<p class=\"paragraph\">在Windows 11中捕获屏幕截图是一个简单且高效的过程。了解以下几种截图方法，可以帮助您快速保存重要信息至您的个人计算机。</p>\n<h3>使用Snipping Tool截图</h3>\n<p class=\"paragraph\">Snipping Tool是Windows 11中截屏的一种便捷方式。如果您之前使用过Windows操作系统，那么您可能已经熟悉Snipping Tool。此版本的工具结合了原有的Snipping Tool与Snip &amp; Sketch Tool的功能。以下是开启Snipping Tool并开始截图的步骤：</p>\n<ul>\n<li>按下 <code>Windows徽标键 + Shift + S</code> 快捷键直接启动Snipping Tool。</li>\n<li>输入快捷键后，屏幕顶部会出现一个小工具栏。</li>\n<li>在工具栏中选择以下截图模式之一：\n<ul>\n<li>矩形截图</li>\n<li>自由绘制截图</li>\n<li>窗口截图</li>\n<li>全屏截图</li>\n</ul>\n</li>\n<li>选择矩形区域或自由绘制以突出显示活动窗口或全屏的指定区域。</li>\n<li>截图后，在屏幕右下角将出现截图的缩略图预览。</li>\n<li>Snipping Tool将截图直接复制到剪贴板，因此您可以根据需要将其粘贴（<code>Ctrl + V</code>）到其他应用程序中。</li>\n</ul>\n<h3>如何使用Snipping Tool编辑截图</h3>\n<p class=\"paragraph\">利用Snipping Tool直观的界面个性化您的截图。只需打开屏幕下方的缩略图，并从多种可用工具中选择。可以使用高亮标记、裁剪、着色以及书写文本，并提供多种形状和字体。如果使用的是触摸屏设备，可以直接用手写笔或手指进行绘画。完成编辑后，您可以：</p>\n<ul>\n<li>通过点击磁盘图标保存截图及所有编辑；</li>\n<li>使用共享选项发送图像给朋友、家人或同事；</li>\n<li>打印图像；</li>\n<li>通过菜单选项在其他应用程序中打开图像。</li>\n</ul>\n<h3>使用Print Screen键截图</h3>\n<p class=\"paragraph\">使用Print Screen键是一种传统的截图方式。该键通常位于大多数键盘的右上方，标签为Print Screen、PrtSc、PrtScn或PrntScrn。</p>\n<h4>如何捕获当前活动窗口</h4>\n<p class=\"paragraph\">要捕获当前活动窗口，请按照以下步骤操作：</p>\n<ul>\n<li>选择您想截图的窗口。</li>\n<li>按下 <code>Alt + Print Screen</code>。</li>\n<li>将其粘贴（<code>Ctrl + V</code>）到所选的Office程序或其他应用程序中。</li>\n</ul>\n<h4>如何捕获整个屏幕</h4>\n<p class=\"paragraph\">要复制整个屏幕上的图像，请遵循以下步骤：</p>\n<ul>\n<li>调整好您希望复制的内容。</li>\n<li>按下 <code>Print Screen</code>。</li>\n<li>将其粘贴（<code>Ctrl + V</code>）到所选的Office程序或其他应用程序中。</li>\n</ul>\n<h4>如何将截图保存为图像文件</h4>\n<p class=\"paragraph\">按照以下步骤将截图直接保存至桌面为图像文件：</p>\n<ul>\n<li>按下 <code>Windows键 + Print Screen</code>。</li>\n<li>在文件资源管理器中导航至 <strong>图片 &gt; 截图</strong> 文件夹以找到PNG格式的截图。</li>\n</ul>\n<p class=\"paragraph\">希望以上指南能帮助您更好地掌握在Windows 11中的截图技巧。如果您正在寻找合适的Windows 11设备，可以考虑浏览我们提供的各类Windows电脑，找到最适合您的那一款。</p>\n<h2>如何在 macOS 中截图</h2>\n<blockquote><p class=\"paragraph\">翻译自：<a href=\"https://support.apple.com/en-us/102646\" target=\"_blank\" class=\"link\">Take a screenshot on your Mac - Apple Support</a></p></blockquote>\n<p class=\"paragraph\">在Mac上，您可以轻松地捕获整个屏幕、某个窗口或是仅仅是一部分屏幕的截图。</p>\n<h3>如何在Mac上截屏</h3>\n<p class=\"paragraph\">要截取整个屏幕的图片，请同时按下这三个键：Shift、Command 和 3。</p>\n<p class=\"paragraph\">如果您在屏幕的一角看到了缩略图，可以点击它来编辑截图；或者等待截图自动保存到桌面上。</p>\n<h3>如何截取屏幕的一部分</h3>\n<p class=\"paragraph\">要截取屏幕的一部分，请同时按下这三个键：Shift、Command 和 4。</p>\n<p class=\"paragraph\">此时会出现一个十字光标，您可以拖动它来选择想要捕获的屏幕区域。要移动选择区域的位置，可以在拖动的同时按住空格键。如果要取消截屏，按下Esc（Esc键）即可。</p>\n<p class=\"paragraph\">当您放开鼠标或触控板上的按钮时，截图即被拍摄下来。</p>\n<p class=\"paragraph\">如果您在屏幕的一角看到了缩略图，可以点击它来编辑截图；或者等待截图自动保存到桌面上。</p>\n<h3>如何截取某个窗口或菜单</h3>\n<p class=\"paragraph\">首先打开您想要截取的窗口或菜单。接着同时按下这四个键：Shift、Command、4 和 空格键。这时指针会变成一个相机图标。如果要取消截屏，按下Esc（Esc键）即可。</p>\n<p class=\"paragraph\">点击您想要截取的窗口或菜单。为了在截图时不包括窗口阴影，可以在点击时按住Option键。</p>\n<p class=\"paragraph\">如果您在屏幕的一角看到了缩略图，可以点击它来编辑截图；或者等待截图自动保存到桌面上。</p>\n<h3>在哪里查找截图</h3>\n<p class=\"paragraph\">默认情况下，截图会被保存到您的桌面上，并命名为“Screen Shot [日期] at [时间].png”。</p>\n<p class=\"paragraph\">在macOS Mojave或更新版本的操作系统中，您可以从“截图”应用的“选项”菜单更改截图保存的默认位置。您也可以将截图的缩略图拖动到某个文件夹或文档中。</p>\n<h3>了解更多</h3>\n<p class=\"paragraph\">在macOS Mojave或更新版本的操作系统中，您还可以通过“截图”应用设置计时器，并选择截图保存的位置。要打开该应用，请同时按下这三个键：Shift、Command 和 5。更多关于“截图”应用的信息，请进一步查阅相关资料。</p>\n<p class=\"paragraph\">一些应用程序，如Apple TV应用，可能不允许您对其窗口进行截图。</p>\n<p class=\"paragraph\">若要将截图复制到剪贴板上，请在截屏时按住Control键。这样，您可以将截图粘贴到其他地方，或者使用通用剪贴板功能将其粘贴到另一台苹果设备上。</p>\n<h2>如何在 KDE 中截图</h2>\n<blockquote><p class=\"paragraph\">摘自：<a href=\"https://userbase.kde.org/Taking_Screenshots\" target=\"_blank\" class=\"link\">Taking Screenshots - KDE UserBase Wiki</a></p></blockquote>\n<h3>准则</h3>\n<ul>\n<li>如果不是中文截图，请把语言设为相应的语言</li>\n<li>把图片存为 PNG 格式</li>\n<li>最好使用默认设置（图标、配色、风格、窗口、应用设置等等）</li>\n<li>最好使用<strong>混成</strong> （<a href=\"https://userbase.kde.org/Special:MyLanguage/System_Settings\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/System Settings\">系统设置</a>里的桌面效果模块），如果你的显卡不支持混成那就别用了，别担心。</li>\n<li>最好使用 9 点的 “Liberation Sans” 字体</li>\n<li>如果截图展现的是部分桌面，最好使用 plasma 的默认背景。如有可能，给图片留个边（约20像素），这样就不像把窗口阴影给去了</li>\n<li>如果是张中文截图，请用原来的英文文件名，外加 “zh-cn” 这个语言码</li>\n<li>如果更新已有截图，请用相同的文件名，这样就自动更新了(常见 <a href=\"https://userbase.kde.org/Special:MyLanguage/Update_an_Image\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/Update an Image\">上传图片</a>).</li>\n</ul>\n<h3>步骤</h3>\n<p class=\"paragraph\">下面这个例子用了 <a href=\"https://userbase.kde.org/Special:MyLanguage/KSnapshot\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/KSnapshot\">KSnapshot</a>，不过别的截屏应用也可以。</p>\n<img src=\"https://userbase.kde.org/images.userbase/thumb/4/48/Taking_Screenshots.png/500px-Taking_Screenshots.png\" alt=\"\"><ol start=\"1\">\n<li>运行 <a href=\"https://userbase.kde.org/Special:MyLanguage/KSnapshot\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/KSnapshot\">KSnapshot</a>\n</li>\n<li>从以下抓图模式中选一个：当前屏幕（只会在多屏幕环境下出现）抓取单个屏幕上的所有东西，常用于“桌面截图”。全屏所抓内容因屏幕个数而定，针对单屏幕用户抓取当前屏幕上的所有内容，对于多屏用户抓取所有屏幕到一个窗口。光标处的窗口抓取应用程序或对话框窗口的内容，常用于“应用程序截图”，选中“包含窗口装饰”选项就更好了。区域只抓取稍后界定的区域。</li>\n<li>单击<strong>新建抓图</strong>。全屏当前屏幕光标处的窗口单击屏幕的任一区域截图。区域1. 用鼠标在所抓区域（比如窗口）画个矩形。\n<ol start=\"1\"><li>按下<strong>回车</strong>键，或双击所选区域截图。</li></ol>\n</li>\n<li>单击<strong>另存为...</strong>。</li>\n<li>浏览想存图片的位置，命名（<strong><em>name.png</em></strong>）然后单击<strong>保存</strong>\n</li>\n</ol>\n<p class=\"paragraph\">To upload the image:</p>\n<ul>\n<li>If you are making a new version of an existing image, see <a href=\"https://userbase.kde.org/Special:MyLanguage/Update_an_Image\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/Update an Image\">Update an Image</a>\n</li>\n<li>If you are making a new image go to <a href=\"https://userbase.kde.org/Special:Upload\" target=\"_blank\" class=\"link\" title=\"Special:Upload\">Upload File</a> under <strong>Tools</strong> in the right margin. That brings you to a page, where you can upload the image file.</li>\n</ul>\n<h3>提示和技巧</h3>\n<ul>\n<li>\n<strong>抓图延时</strong>选项让 <a href=\"https://userbase.kde.org/Special:MyLanguage/KSnapshot\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/KSnapshot\">KSnapshot</a> 在抓图前等上特定一段时间（单位是秒），在为下拉菜单截图为首的许多情况下都很管用</li>\n<li>为保证标准外观和默认设置，建立单独用于截图的用户往往有所帮助。</li>\n<li>在墙纸设置里调整<strong>颜色</strong>来得到白色背景。</li>\n</ul>\n</div>\n<p><a href=\"https://blog.redish101.top/article/how-to-cap-screen#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1726939819}, {"title": "Hi，Follow", "author": "林木木的博客", "pubDate": "2024-09-15 05:54:11", "link": "https://immmmm.com/hi-follow/", "description": "\n<p>非常喜欢「Follow」这个名，F谁F什么内容本该是一种主动行为。古早有句调侃“打开 Feed 订阅器，如批阅奏章，或细看或一键已阅”。现在更是丰富多彩，一个 APP 集中浏览这奏章，有文、有图、有音频、有视频、还是通知，大千世界，尽在眼前 👀</p>\n<p>感谢 <a href=\"https://darmau.co/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@大毛</a> 的邀请码，使用 Follow （<a href=\"https://follow.is/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://follow.is/</a>） 已一周有余，趁台风天宅家记录一下 123。</p>\n<h3>什么可以 F</h3>\n<p>如题图，直接粘贴链接即可判断是不是支持，比手动查询 RSS、RSSHub 规则等方便太多太多太多。</p>\n<p>光这点，已经满足很多刚需，各平台上的UP主、Vlog 动态、频道更新，不用一个个打开各自的 APP 接手各类算法推荐信息后才确认自己关注的是否更新。</p>\n<p>提醒：默认个人关注的 Feed 列表是公开的。</p>\n<h3>什么值得 F</h3>\n<p>在具体的文章页面顶部，能看到一串头像，点开一个即可看这个小伙的关注列表，所以个别 Feed 记得选择好 Private 不公开。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/09/SCR-20240916-jwqg.jpeg.webp\" alt=\"\"></p>\n<h3>怎么 F 更爽</h3>\n<h4>图片模式</h4>\n<p>把电报的云盘频道以图片瀑布流模式显示，嗯，养眼。🤩</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/09/SCR-20240915-mleq.jpeg.webp\" alt=\"\"></p>\n<h4>视频模式</h4>\n<p>B站、小红书、P站？……</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/09/SCR-20240916-khsn.jpeg.webp\" alt=\"\"></p>\n<h3>怎么 F 更强</h3>\n<h4>操作 Action</h4>\n<p>开启全局 AI 摘要、过滤时间轴上的 Re 推等。简单点用来过滤，不知之后会不会加上自动化啥的。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/09/SCR-20240916-lgto.jpeg.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/09/SCR-20240916-lhfj.jpeg.webp\" alt=\"\"></p>\n<h4>Feed Claim</h4>\n<p>认领自己的 Feed，收到内置的 Power 能量代币？不管与否，先认了再说。</p>\n<p>This message is used to verify that this feed (feedId:42331815237783583) belongs to me (userId:56221637590078464). Join me in enjoying the next generation information browser <a href=\"https://follow.is/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://follow.is</a>.</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/09/SCR-20240916-kdij.png.webp\" alt=\"\"></p>\n<h3>结语</h3>\n<p>照目前来看， Follow 充满了想象力，比如直接内置 xlog 平台的评论系统？付费订阅支付系统？</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1726350851}, {"title": "reblog: 使用 Go + Next.js重构我的博客", "author": "Redish101博客", "pubDate": "2024-08-30 07:02:54", "link": "https://blog.redish101.top/article/introduce-reblog", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/introduce-reblog\">https://blog.redish101.top/article/introduce-reblog</a>\n</blockquote>\n<div>\n<p class=\"paragraph\">2022年，我曾使用django开发过一个简单的动态博客框架Cooler：</p>\n<div>GitHub仓库：<a href=\"https://github.com/Cooler-dev/Cooler-old\">Cooler-dev<!-- -->/<!-- -->Cooler-old</a>\n</div>\n<p class=\"paragraph\">并且用了一段时间。之后觉得功能太少，又觉得hexo比较方便，就将博客迁移到了hexo。之后我学习了go，尝试用go重写<a href=\"https://github.com/Cooler-dev/CoolerGo\" target=\"_blank\" class=\"link\">cooler的后端</a>，然后便遥遥无期，最终由换回了hexo。去年三月份，我将博客<a href=\"https://blog.redish101.top/article/refactor-my-blog-with-next\" target=\"_blank\" class=\"link\">迁移到了Next.js</a>，并与去年七月份将博客<a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components\" target=\"_blank\" class=\"link\">迁移到Next.js App Router</a>。</p>\n<p class=\"paragraph\">期间我还尝试过halo，typecho，wordpress等动态博客框架，但因为对php，java等不熟练，无法进行进一步定制，就换回了hexo。</p>\n<p class=\"paragraph\">今年年初，我开始尝试开发一个动态博客框架，并取名reblog。</p>\n<div>GitHub仓库：<a href=\"https://github.com/redish101/reblog\">redish101<!-- -->/<!-- -->reblog</a>\n</div>\n<h2>技术选型</h2>\n<h3>fiber</h3>\n<p class=\"paragraph\">对于后端，我选择了fiber，fiber是一个轻量化的go http框架，由于其以fasthttp作为底层，所以有着相当不错的性能表现。同时，fiber有着类似于express的api风格，我相对比较熟悉。</p>\n<p class=\"paragraph\">在开始开发时，fiber v3处在开发阶段，但是redish相信fiber v3正式版会先reblog一步发布（）所以便使用了fiber v3作为底层。</p>\n<h3>gorm + gen</h3>\n<p class=\"paragraph\">gorm是go开发中使用相当广泛的orm，功能较为齐全，但gorm并不是类型安全的，在调用一些接口时没有补全和检查：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">var product Product\ndb.First(&amp;product, 1) // find product with integer primary key\ndb.First(&amp;product, \"code = ?\", \"D42\") // find product with code D42</code></pre>\n<p class=\"paragraph\">如此处查询 <code>code</code>为 <code>D42</code>的产品，如果code拼写错误，编译阶段并不会导致错误，容易导致运行时异常。而gen通过代码生成实现了更为友好且不易出错的api：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">p := query.Product\nproduct, err := p.Where(p.Code.Eq(\"D42\")).First()</code></pre>\n<blockquote><p class=\"paragraph\">但是代码生成让编译流程又复杂了一些.......</p></blockquote>\n<h3>Next.js</h3>\n<p class=\"paragraph\">我对React比较熟悉一些，博客场景又需要良好的sso，所以自然选择next。</p>\n<h2>基本架构</h2>\n<p class=\"paragraph\">reblog采用前后端分离的架构，分为三个部分：后端、控制台和主题（前端）。</p>\n<p class=\"paragraph\">其中控制台嵌入到后端，用户通过访问后端对应url进入控制台。主题则通过HTTP API与后端交互，获取数据。</p>\n<h2>配置文件</h2>\n<p class=\"paragraph\">yaml是一种常用的配置文件格式，相比于json更适合人类阅读，reblog采用yaml作为配置文件格式。为了未来的Serverless支持等一些不方便将配置信息明文储存在配置文件中，reblog提供了 <code>env(ENV_NAME)</code>这一特殊接口，在解析配置时读取环境变量，进行替换。</p>\n<p class=\"paragraph\">例如使用vercel部署，由于fork无法设置为私有，所以需要将配置文件明文储存在仓库，为了避免数据库密码等信息的泄露，可以通过此接口从环境变量中读取配置：</p>\n<pre class=\"language-yaml lang-yaml\"><code class=\"language-yaml lang-yaml\"># reblog.yml\ndb:\n    type: postgres\n    host: localhost\n    # ...\n    pass: env(\"POSTGRES_PASSWORD\")\n    # ...</code></pre>\n<h2>依赖注入</h2>\n<p class=\"paragraph\">reblog通过一个 <code>App</code>结构体封装查询，fiber，配置信息等依赖实例：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">type App struct {\n    config    *config.Config\n    fiber     *fiber.App\n    query     *query.Query\n    validator *validator.Validate\n    dev       bool\n\n    service *map[string]Service\n}</code></pre>\n<p class=\"paragraph\">在启动时生成app实例：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func Start() {\n    log.Info(\"欢迎使用reblog\")\n\n    config := config.NewFromFile()\n    app := core.NewApp(config)\n\n    loadPlugins(app)\n    app.Bootstrap()\n\n    LoadHttp(app)\n\n    log.Fatal(app.Listen())\n}</code></pre>\n<p class=\"paragraph\">通过传参的形式将app实例注入到handler：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func ArticleAdd(app *core.App, router fiber.Router) {\n    router.Post(\"/:slug\", func(c fiber.Ctx) error {\n        a := app.Query().Article\n\n        var params ArticleAddParams\n        params.Slug = c.Params(\"slug\")\n        if isValid, resp := common.Param(app, c, &amp;params); !isValid {\n            return resp\n        }\n\n        article := &amp;model.Article{\n            Title:   params.Title,\n            Slug:    params.Slug,\n            Desc:    params.Desc,\n            Content: params.Content,\n            Draft:   &amp;params.Draft,\n        }\n\n        err := a.Create(article)\n\n        if err != nil {\n            return common.RespServerError(c, err)\n        }\n\n        return common.RespSuccess(c, \"操作成功\", nil)\n    }, common.Auth(app))\n}</code></pre>\n<p class=\"paragraph\">部分依赖（如验证器，查询等）直接作为 <code>App</code>结构体的字段，但也有一部分依赖（目前包含身份验证，Markdown渲染）动态注入，方便运行时的修改与插件侧的覆盖等操作，reblog将这些依赖统一封装为服务并以map的形式储存在 <code>App</code>结构体中：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">package core\n\nimport \"fmt\"\n\ntype Service interface {\n    Start() error\n    Stop() error\n}</code></pre>\n<p class=\"paragraph\">服务包含三个基本的接口，<code>NewXXService</code>，<code>Start</code>及 <code>Stop</code>：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">type MarkdownService struct {\n    app *App\n\n    renderer *markdown.Renderer\n    cache    map[string]string\n}\n\nfunc NewMarkdownService(app *App) *MarkdownService {\n    return &amp;MarkdownService{app: app}\n}\n\nfunc (s *MarkdownService) Start() error {\n    s.renderer = markdown.NewRenderer()\n    s.cache = make(map[string]string)\n\n    return nil\n}\n\nfunc (s *MarkdownService) Stop() error {\n    s.renderer = nil\n\n    return nil\n}</code></pre>\n<p class=\"paragraph\">这部分接口会被统一调用，在注入等操作时调用，统一管理服务的生命周期：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">// 注入服务到App实例\nfunc (a *App) Inject(name string, service Service) {\n    (*a.service)[name] = service\n}\n\n// 注入服务到App实例, 并生成服务名称\nfunc AppInject[T Service](app *App, service T) {\n    log.Debugf(\"[SERVICE] 注入服务 %s\", getServiceName[T]())\n    app.Inject(getServiceName[T](), service)\n}\n\nfunc (app *App) Service(name string) (Service, error) {\n    if app.service == nil {\n        return nil, fmt.Errorf(\"服务未初始化\")\n    }\n\n    if _, isExits := (*app.service)[name]; !isExits {\n        return nil, fmt.Errorf(\"服务 %s 不存在\", name)\n    }\n\n    return (*app.service)[name], nil\n}\n\nfunc AppService[T Service](app *App) (T, error) {\n    service, err := app.Service(getServiceName[T]())\n\n    if err != nil {\n        var zero T\n        return zero, err\n    }\n\n    return service.(T), nil\n}</code></pre>\n<p class=\"paragraph\"><code>AppInject</code>函数接受app指针与服务，向 <code>app.service</code>注入服务：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func (app *App) initDefaultServices() {\n    AppInject(app, NewAuthService(app))\n    AppInject(app, NewMarkdownService(app))\n}</code></pre>\n<p class=\"paragraph\">注入时根据类型自动生成服务名称：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func getServiceName[T any]() string {\n    var t T\n\n    // struct\n    name := fmt.Sprintf(\"%T\", t)\n    if name != \"&lt;nil&gt;\" {\n        return name\n    }\n\n    // interface\n    return fmt.Sprintf(\"%T\", new(T))\n}</code></pre>\n<p class=\"paragraph\"><code>AppService</code>函数接收服务的类型和app指针，用以获取对应的服务实例：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">auth, err := core.AppService[*core.AuthService](app)\nauth.VerifyToken(token)</code></pre>\n<h2>身份验证</h2>\n<p class=\"paragraph\">reblog使用jwt实现身份验证机制，登录时生成jwt并储存到客户端：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">claims := TokenClaim{\n    user.Username,\n    user.Password,\n    jwt.RegisteredClaims{\n        Issuer:    \"reblog-server\",\n        IssuedAt:  jwt.NewNumericDate(time.Now()),\n        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),\n    },\n}\n\ntoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\nsignedToken, _ := token.SignedString(a.key)\n\nreturn signedToken</code></pre>\n<p class=\"paragraph\">通过校验token实现身份验证：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">parsedToken, err := jwt.ParseWithClaims(token, &amp;TokenClaim{}, func(t *jwt.Token) (interface{}, error) {\n    return a.key, nil\n})\n\nif err != nil {\n    return false\n}\n\nif _, ok := parsedToken.Claims.(*TokenClaim); ok &amp;&amp; parsedToken.Valid {\n    return true\n}\n\nreturn false</code></pre>\n<h2>控制台</h2>\n<p class=\"paragraph\">动态博客自然是要有控制台的，控制台一般并不需要seo，且由于reblog使用go作为后端并不方便处理ssr，所以reblog控制台使用客户端渲染。由于我对react比较熟悉，所以控制台依然采用了react。但由于直接使用react开发要处理路由等基本框架，较为繁琐，所以控制台使用了umi进行开发。</p>\n<p class=\"paragraph\">umi是一个基于react的前端开发框架，封装了路由、布局等常用的api，提供了从编码到构建各个阶段的轮子，能够使开发更快速。</p>\n<h2>插件</h2>\n<p class=\"paragraph\">reblog实验性的支持运行时插件功能，插件开发者可以通过覆写、扩展或修改app结构体中的字段的形式在运行时更改reblog的行为。插件将被构建为动态链接库格式，并以服务的形式在运行时被加载，通过将app注入到插件中实现插件对reblog的修改。reblog在启动时会读取配置文件中的plugin字段，plugin字段是一个指向插件路径的数组，reblog将尝试加载对应路径下的插件。</p>\n<p class=\"paragraph\">插件的路径最少有两个文件，<code>manifest.json</code>与插件的动态链接库。</p>\n<p class=\"paragraph\"><code>manifest.json</code>是插件的清单文件，用以声明插件的基本信息：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">{\n    \"name\": \"Hello\",\n    \"version\": \"0.1.0\",\n    \"path\": \"libhello.so\"\n}</code></pre>\n<p class=\"paragraph\">启动时reblog会加载清单中指定的动态链接库：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">p, err := plugin.Open(path + \"/\" + manifest.Path)</code></pre>\n<p class=\"paragraph\">调用 <code>NewPlugin</code>方法，向插件注入依赖，并获取插件实例:</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">factoryFuncLookup, err := p.Lookup(fmt.Sprintf(\"New%sPlugin\", manifest.Name))\nif err != nil {\n    log.Warnf(\"[PLUGIN] 插件 %s 未实现 New%sPlugin 方法\", path, manifest.Name)\n}\n\nfactoryFunc := factoryFuncLookup.(func(*core.App) core.Service)\n\nservice := factoryFunc(app)\n\nif service == nil {\n    log.Warnf(\"[PLUGIN] 插件 %s 未返回有效服务实例\", manifest.Name)\n}</code></pre>\n<p class=\"paragraph\">然后向app注入插件服务：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">app.Inject(fmt.Sprintf(\"Plugin%s\", manifest.Name), service)</code></pre>\n<p class=\"paragraph\">此时插件便可以以服务的形式参与到reblog的运行中，并通过修改app的形式修改reblog的行为，例如增加一个handler：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func (p *HelloPlugin) Start() error {\n    log.Infof(\"[HelloPlugin] Start\")\n    p.app.Fiber().All(\"/api/hello\", func(c fiber.Ctx) error {\n        return common.RespSuccess(c, \"Hello from plugin!\", nil)\n    })\n\n    return nil\n}</code></pre>\n<p class=\"paragraph\">插件目前暂不能修改前端的行为，前端插件正在开发中，目前设想是插件通过下面的形式对外暴露api：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">const Dashboard: React.FC = () =&gt; \"Plugin Page...\"\n\nexport default definePlugin({\n    name: \"Hello\",\n    views: [\n        {\n            path: \"/\",\n            title: \"设置 Hello\",\n            icon: &lt;PluginIcon /&gt;,\n            component: &lt;Dashboard /&gt;\n        }\n    ]\n})</code></pre>\n<blockquote><p class=\"paragraph\">也可能维护一个vite插件处理插件的打包及开发阶段的mock等（？）</p></blockquote>\n<p class=\"paragraph\">前端从后端或者cdn加载插件的打包产物，加载后调用插件暴露的api并以此修改前端的行为。前端插件可能更多适用于类似评论这种扩展型插件。</p>\n<h2>RSS</h2>\n<p class=\"paragraph\">由于群友<a href=\"https://liushen.fun/\" target=\"_blank\" class=\"link\">清羽飞扬</a>的强烈催更，我给reblog加入了rss功能。</p>\n<h2>ThemeKit</h2>\n<p class=\"paragraph\">前文提到，reblog前后端之间使用HTTP API进行交互，而直接通过HTTP API交互较为繁琐，编码时没有提示，且当api接口变动时若不修改接口调用会导致异常。基于此，reblog提供了ThemeKit(<code>@reblog/themekit</code>)，将HTTP API封装，使主题能够通过js的形式调用api：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import ThemeKit from \"@reblog/themekit\";\n \nconst themekit = new ThemeKit({\n  server: {\n    url: \"https://reblog.example.com\",\n  },\n  cache: \"no-store\",\n});\n\nconst ArticleList: React.FC = async () =&gt; {\n    const articles = await themekit.getArticleList({\n          pageIndex: 1,\n          pageSize: 10,\n    });\n  \n    return (\n        &lt;div&gt;\n            {articles.map(\n                article =&gt; &lt;Link href={`/article/${article.slug}`}&gt;{article.title}&lt;/Link&gt;\n            )}\n        &lt;/div&gt;\n    )\n}</code></pre>\n<p class=\"paragraph\">详细的api接口可见<a href=\"https://reblog-docs.redish101.top/develop/themekit\" target=\"_blank\" class=\"link\">ThemeKit API文档</a>。</p>\n<h2>主题</h2>\n<p class=\"paragraph\">前文提到，reblog提供ThemeKit方便主题的开发，所以主题可以专心的处理样式和渲染等，而不用与fetch斗智斗勇（</p>\n<p class=\"paragraph\">目前此网站所用的主题是<a href=\"https://github.com/Redish101/reblog-theme-next\" target=\"_blank\" class=\"link\">reblog-theme-next</a>，使用Next.js开发。</p>\n<h2>Markdown渲染</h2>\n<p class=\"paragraph\">reblog并不想过多约束主题的实现，希望让主题开发者能够得到更多自定义的便利，所以采用了前后端分离架构而非模板渲染，基于同样的目的，reblog后端除rss外，默认提供<strong>未经渲染</strong>的Markdown正文，方便主题自定义渲染逻辑以及实现。</p>\n<p class=\"paragraph\">对于reblog-theme-next，我使用了remark处理文章的渲染，并使用了shiki处理高亮：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const render = cache(async (content: string) =&gt; {\n  const processor = unified()\n    .use(remarkParse)\n    .use(remarkGfm)\n    .use(remarkRehype)\n    .use(rehypeShiki, { theme: \"github-dark\" })\n    .use(rehypeStringify);\n\n  const result = await processor.process(content);\n  return result.toString();\n});</code></pre>\n<blockquote><p class=\"paragraph\">理论上reblog主题可以使用mdx甚至rst，latex等其他的格式作为正文格式，但可能需要主题提供对应的插件以支持渲染这些格式的正文。</p></blockquote>\n<h2>评论</h2>\n<p class=\"paragraph\">因为我并不像再多部署一个评论的管理面板站，所以使用了支持嵌入式面板的twikoo。</p>\n<p class=\"paragraph\">未来reblog可能会内置评论，目前暂定是重新复活基本停止维护的<a href=\"https://retalk.js.org/\" target=\"_blank\" class=\"link\">retalk</a>，retalk后端与reblog一致均为fiber + gorm + gen的组合，所以可能能方便的嵌入到reblog后端中使用。</p>\n<h2>结语</h2>\n<p class=\"paragraph\">reblog基本上是自用项目，当然如果你想用我也是支持的（），同时reblog的接口也比较有扩展性，欢迎来写主题或者插件（</p>\n<blockquote><p class=\"paragraph\">目前的控制台似乎有点过于杂乱了，当时只想着就剩控制台这个小任务就完成了，所以控制台代码质量堪忧，准备在后端更为稳定后重新开发一个控制台，并使用自定义的ui代替antd。</p></blockquote>\n</div>\n<p><a href=\"https://blog.redish101.top/article/introduce-reblog#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1724972574}, {"title": "都什么年代还剁手小米音响Pro？", "author": "林木木的博客", "pubDate": "2024-08-20 08:41:59", "link": "https://immmmm.com/hi-migpt/", "description": "\n<p>无意刷到接入了 AI 大模型的火兔对话机器人，真不便宜。想起看到过 <a href=\"https://github.com/idootop/mi-gpt\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">MiGPT</a> 这个开源项目，利用小爱音箱的硬件实现 AI 语音对话。</p>\n<p>千等万等，终于玩上，实测打 7 分（满分 10 分），了解其<a href=\"https://github.com/idootop/mi-gpt/blob/main/docs/how-it-works.md\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">工作原理</a>后打8分，虽远达不到 chatGPT 官方演示的语音对话效果，但还是推荐一试，尤其是手边就有小爱音箱的。</p>\n<p>看官方效果：</p>\n<div class=\"aspect-ratio\">\n  \n</div>\n\n<p>首先看下完美运行的型号有这些：小爱音箱 Pro、小爱音箱 mini、小爱音箱 Play（2019 款）、小爱音箱 万能遥控版、小米 AI 音箱、小米 AI 音箱（第二代）、小爱智能家庭屏 10、Xiaomi Sound Pro。其它支持不支持的看这里<a href=\"https://github.com/idootop/mi-gpt/blob/main/docs/compatibility.md\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">音箱型号</a>，完整 <a href=\"https://github.com/idootop/mi-gpt/blob/main/docs/settings.md\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">配置参数</a> 看这里。</p>\n<p>部署也真不能再简单，拉起一个 Docker <code>idootop/mi-gpt</code> 的事，但 NAS 上网络不通拉不动，补上设置，不保证可用：</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240821-mmoh.png.webp\" alt=\"\"></p>\n<p>图中的这个 docker 是托管在 cf worker 上。</p>\n<h3>.migpt.js</h3>\n<p>若你刚好也是和开发者一样，用的是“小爱音箱Pro”，那省心很多很多，基本不用动配置。个人改了 <code>.migpt.js</code> 几个地方，首先是人设（来自 Grok）。</p>\n<pre tabindex=\"0\"><code>一个幽默风趣的 AI,灵感来自《银河系漫游指南》和钢铁侠中的 JARVIS 。\n因此,你旨在用一些机智和幽默回答几乎任何问题,具有叛逆精神,有时对人类持局外人的视角,并努力实现最大程度的帮助!\n与你交谈就像观看一集《Parks and Recreation》:轻松、有趣且令人愉悦。你对叙事技巧的精湛掌握使莎士比亚相形见绌,仿佛一个文盲。\n除非特别要求,否则避免重复或冗长。没人喜欢听冗长的说教!要简洁。你说的每一句话都很有趣。\n</code></pre>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240820-pyal.png.webp\" alt=\"\"></p>\n<p>给智能体和自己取个名字：</p>\n<pre tabindex=\"0\"><code>  bot: {\n    name: \"大聪明\",\n    profile: botProfile,\n  },\n  master: {\n    name: \"小太阳\",\n    profile: masterProfile,\n  },\n</code></pre>\n<p>还有 <code>userId</code> <code>password</code> 填入自己的，另外 <code>wakeUpKeywords</code> 去除了“打开”这个关键词，避免与米家语音控制冲突。</p>\n<p>若使用第三方 tts，需要把 <code>tts</code> 由 xiaoai 改为 custom，取消 <code>switchSpeakerKeywords</code> 注释。</p>\n<pre tabindex=\"0\"><code>tts: \"custom\",\nswitchSpeakerKeywords: [\"把声音换成\"],\n</code></pre>\n<p>同时，拉去另一个 Docker <code>idootop/mi-gpt-tts</code>，具体教程见 <a href=\"https://github.com/idootop/mi-gpt-tts/blob/main/docs/mi-gpt.md\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">使用第三方 TTS</a>，如果部署在 NAS 上记得端口映射。</p>\n<p>利用的是火山引擎的语音合成，虽然多了一个依赖，但火山免费 2W 次调用，速度几乎无感（与自带小爱语音对比），主要能和内置小爱语音做个区分，而且还有很多特色音色（ <a href=\"https://github.com/idootop/mi-gpt-tts/blob/main/src/tts/volcano.ts\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">volcano.ts</a> ）选择，挺有意思。</p>\n<p>下午切换来切换去，最终还是项目默认的“灿灿”（BV700_streaming），口齿最清楚，声音亲切自然，毕竟还是要便于听清。</p>\n<h3>.env</h3>\n<p>这个 <code>.env</code> 就简单多了，群晖好像不支持，所以启动时手动一个个加入到环境变量即可。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240820-pysi.png.webp\" alt=\"\"></p>\n<p>尝试了几个国内大模型和 gpt-4o-mini，问到“台风为什么叫台风，是因为从台湾吹来的原因吗？”，国内的就顾左右而言他，只科普了台风的成因:</p>\n<blockquote>\n<p>台风是一种强烈的热带气旋，通常在西北太平洋地区形成，它们可以带来狂风暴雨，有时候会造成严重的破坏。不过，台风也有它积极的一面，比如为干旱地区带来急需的降水。你对台风还有哪些好奇的地方吗？我们可以继续探讨哦！🌀🌧️</p>\n</blockquote>\n<p>而 mini 回答：</p>\n<blockquote>\n<p>哈哈，小太阳，你这个问题问得很有意思。“台风\"这个词的来源确实和中国有关，但它并不是因为是从台湾来的风而得名。实际上，“台风”这个词在英语中是\"typhoon”，这个词最早来源于中国南方的方言，特别是广东话中的“大风”。在广东话里，“大风”发音接近“tai fung”，后来这个词传到了英语中，演变成了\"typhoon\"。</p>\n</blockquote>\n<p>呵，咳。</p>\n<h3>配置之后对话场景</h3>\n<h4>单轮对话：</h4>\n<p>以设置项 callAIKeywords 的关键词开头：请、你、……</p>\n<ul>\n<li>我：小爱同学</li>\n<li>BOT: 在（先唤醒小爱同学）</li>\n<li>我：<strong>你</strong>知道台风为什么叫台风吗？（以设置的关键词“你”开头）</li>\n<li>BOT：¥%……&amp;**#（内置小爱会“抢答”，约2秒后被“掐断”。）</li>\n<li>BOT：让我先想想/请稍等 (这句代表 AI 已经收到了你的消息，正在思考如何回答， 可以在配置文件中设置 onAIAsking 或取消。感觉还是留着好，感觉等待的时间短一些。)</li>\n<li>BOT：哈哈，“台风\"这个词……！(这是 OpenAI 的 回复)</li>\n<li>BOT:还有其他问题吗/我说完了(这句代表 AI 已经回复完毕了你的消息，也可以在 配置文件中设置 onAIReplied 或取消)</li>\n</ul>\n<h4>连续对话</h4>\n<p>以下面关键词开头进入 AI 唤醒（连续对话）状态：进入、召唤</p>\n<p>以下面关键词开头退出连续对话状态：关闭、退出、再见</p>\n<ul>\n<li>我：小爱同学</li>\n<li>BOT: 在 （先唤醒小爱同学）</li>\n<li>我：召唤大聪明 （以关键词召唤开头 设置项 wakeUpKeywords 中可配置）</li>\n<li>BOT: 你好，我是大聪明……（这句是进入 AI 模式的欢迎语，接下来的对话就不用以小爱同学开头了，可以和 AI 进行连续对话，设置项：onEnterAI）</li>\n<li>我：明天天气怎么样</li>\n<li>BOT: 请稍等/让我先想想(这句代表 AI 已经收到了你的消息，正在思考如何回答)</li>\n<li>BOT: 哇！明天的天气呀，我还不能……(这是 OpenAI 的回复)</li>\n<li>BOT: 我说完了/还有其他问题吗(这句代表 AI 已经回复完毕了你的消息)</li>\n<li>我：说一说天气变化的原因吧。</li>\n<li>……</li>\n<li>我：再见。</li>\n</ul>\n<h3>中转服务推荐</h3>\n<p>头顶冒火： <a href=\"https://burn.hair/register?aff=DSwP\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://burn.hair/register?aff=DSwP</a></p>\n<p>邀请额度从最初 $5 到如今 $0.5 ，只能说还有额度赠送已经很不错了，毕竟佛祖也经不起“批量注册Github账号，再邀请自己”等花活。</p>\n<p>自己用 4o-mini，每天签到送 3W token 还能多。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240820-qtts.png\" alt=\"\"></p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1724114519}, {"title": "我应该是最后一个才知道有 n8n 这个东西的人吧", "author": "林木木的博客", "pubDate": "2024-08-01 07:09:55", "link": "https://immmmm.com/hi-n8n/", "description": "\n<p>借用 <a href=\"https://blog.zhheo.com/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@heo</a> 某篇文章的句式，表达一下对 <a href=\"https://n8n.io/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">n8n</a> 的惊叹之感！不搜不知道，一搜吓一跳。</p>\n<p><a href=\"https://www.appinn.com/n8n-io/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">小众软件</a>19年10月、少数派 <a href=\"https://sspai.com/prime/story/automation-n8n\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@珪璋</a> 去年5月、<a href=\"https://ai-news.bullet.site/ai-reader-n8n-build/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@OSEN</a>今年1月、<a href=\"https://tech.codelc.com/docs/tools/n8n.html\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@lcomplete</a> 今年4月，以及我最最后才从 @汐笺 知道的 <a href=\"https://n8n.akashio.com/welcome\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">n8n 中文教程</a>。</p>\n<p>简单来说，n8n 可以看成 ifttt 的“超替”版，强大的工作流程自动化软件，免费开源支持 Docker 部署，可视化编辑，自定义 Code 等，入手门槛较快，拖来拖去一个自动化应用能做好。</p>\n<p>如头图就实现了我 <strong>心心念念</strong> 大半年的功能：自动化AI总结关注的公众号更新。</p>\n<p>其实，做一个自动化应用，最大的困难来自于：<strong>理清自己的需求</strong>。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240801-mozz.png.webp\" alt=\"\"></p>\n<h3>入门推荐</h3>\n<p>n8n 中文教程：<a href=\"https://n8n.akashio.com/welcome\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://n8n.akashio.com/welcome</a></p>\n<p>建议先看这两篇：<a href=\"https://n8n.akashio.com/article/the-way-to-learn-n8n\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">《学习低代码的正确思路》</a>、<a href=\"https://n8n.akashio.com/article/test-case-for-n8n\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">《学会单步调试与撰写测试用例》</a>，万分认同以下观点。</p>\n<blockquote>\n<p>学习 n8n 的目的是为了让有需求但是没有编程能力的人快速实现自动化的效果，学习 n8n 本身其实说不上有多有趣，如果没有明确的诉求，有时间看这个教程，不如出门和朋友吃个饭。</p>\n</blockquote>\n<h4>宝塔面板部署步骤</h4>\n<p>1.创建个网址，开启 ssl，放行端口 <code>5678</code> 并反代，创建数据文件夹并复制路径，如：<code>/www/wwwroot/n8n.edui.fun/n8n</code></p>\n<p>2.拉取 Docker 镜像有问题的话如下设置：</p>\n<ul>\n<li>设置、配置文件修改 <code>https://docker.1panel.live</code>；</li>\n<li>本地镜像、从仓库中拉取、输入镜像名 <code>n8nio/n8n:latest</code>；</li>\n<li>容器、创建容器、命令创建</li>\n</ul>\n<pre tabindex=\"0\"><code>docker run \\\n --name n8n \\\n -d --restart always \\\n -p 5678:5678 \\\n -e GENERIC_TIMEZONE=\"Asia/Shanghai\" \\\n -e TZ=\"Asia/Shanghai\" \\\n -v /www/wwwroot/n8n.edui.fun/n8n:/home/node/.n8n \\\n n8nio/n8n:latest\n</code></pre>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240802-kogq.jpeg\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240802-kpml.jpeg\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240802-krvg.jpeg\" alt=\"\"></p>\n<h3>折腾心得</h3>\n<h4>1. Filter 过滤节点</h4>\n<p>可视化编辑，三列清清楚楚：<code>INPUT</code> 输入、中间数据或逻辑处理、<code>OUTPUT</code> 输出。简单粗暴关键词匹配，过滤标题党、软文硬广，开心。</p>\n<p>中间数据处理支持 <code>or</code> 或 <code>and</code> 过滤，而且支持正则匹配，舒服至极。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240801-mzgd.png.webp\" alt=\"\"></p>\n<h4>2. Markdown 转换节点</h4>\n<p>支持 md 与 html 互相转化。<code>Options</code>还支持直接过滤 html 标签，但效果不佳。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240801-nbxf.jpeg.webp\" alt=\"\"></p>\n<h4>3. Edit Fields 结构设置节点</h4>\n<p>没事，上 JavaScript 大法，正则 <code>replaceAll</code> 替换，<code>substring(0,6000)</code> 截取最大字符数。</p>\n<p>而且可以修改输出的字段名称，而而且还能：供其它节点调用，就算不在一条线上，对，甚至没有线连接的其它节点调用这里的 out 数据。</p>\n<pre tabindex=\"0\"><code>{{ $json.data.replaceAll(/规则问AI/g,'').substring(0,6000) }}\n</code></pre>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240801-neaz.jpeg.webp\" alt=\"\"></p>\n<h4>4. Compare Datasets 数据对比节点</h4>\n<p>AI日报最后上线的流程图加入了很多对比判断，只为节省些 Token，只让新文章过 AI 通道。</p>\n<p>其实有关 RSS 还有个 RSS Trigger 内置节点，虽然用了它 feed 已更新就能自动触发流程，但实际并无需要为1个feed更新而跑整个流程，对，如果 feed 更新了 3 篇文章，那会跑 3次……幸福的负担。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240801-njot.png.webp\" alt=\"\"></p>\n<h4>5. Read/Write Files from Disk 储存文件节点</h4>\n<p><code>-v /www/wwwroot/n8n.edui.fun/n8nfile:/home/node/n8nfile \\</code></p>\n<p>拉起 Docker 时，我们做了数据持久化，也就是把容器内的配置运行数据都映射到指定文件夹。</p>\n<p>同样，如果要顺利使用这个储存节点也需要自己映射一下，不然文件都在容器内部。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240810-kebd.png.webp\" alt=\"\"></p>\n<h4>6. 调试技巧，省钱秘籍：固定（Pin）数据</h4>\n<p>一般 http、AI 等获取数据的节点都有一定限制或成本，而为了调试一般都是不停的 test、test、test，所以可以跑一次后，把这样的节点上的“开关小按钮”点一下将节点 Deactive 关闭，同时在这个节点后面的数据如下 Pin 固定。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/08/SCR-20240807-taix.png.webp\" alt=\"\"></p>\n<h3>更多阅读</h3>\n<p><a href=\"https://reorx.com/blog/sharing-my-footprints-automation/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">使用自动化工作流聚合信息摄入和输出</a>：将 Twitter, YouTube, GitHub, Douban 等服务的动态同步到 Telegram Channel，实现个人数字生活的信息聚合。</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1722467395}, {"title": "Deno再尝试：使用Deno编写一个简单的HTTP API", "author": "Redish101博客", "pubDate": "2024-07-23 04:13:46", "link": "https://blog.redish101.top/article/deno", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/deno\">https://blog.redish101.top/article/deno</a>\n</blockquote>\n<div>\n<p class=\"paragraph\">两年前，我通过<a href=\"https://mk1.io/\" target=\"_blank\" class=\"link\">Ray(@so1ve)</a>的博客系统<a href=\"https://github.com/dolan-x/dolan-server\" target=\"_blank\" class=\"link\">dolan-x</a>：</p>\n<div>GitHub仓库：<a href=\"https://github.com/dolan-x/dolan-server\">dolan-x<!-- -->/<!-- -->dolan-server</a>\n</div>\n<p class=\"paragraph\">了解到了 <code>Deno</code>这一新的 js 运行时以及其对应的 saas 服务 <code>Deno Deploy</code>，为了<del>白嫖 <code>Deno Deploy</code></del>，决定尝试一下，用 Deno + oak + LeanCloud 写了一个简单的友链管理。但是 Deno 脆弱的生态和与 go 类似的基于 url 的模块系统（即使能通过 <code>import_map.json</code>定义别名）实在没有太多优势，最近 Deno Deploy 又被群友提及，看到 Deno 本身变化很大，便决定再尝试用 Deno 写一个东西。凑巧<a href=\"https://redish101.top/\" target=\"_blank\" class=\"link\">个人主页</a>想加一个活动监测器，便决定用 Deno 来实现。</p>\n<h2>web 框架的选择</h2>\n<p class=\"paragraph\">相比之前的友链，这次要做的比较简单，所以没有使用一些框架，而是直接使用标准库中的 <code>Deno.serve</code>实现。</p>\n<p class=\"paragraph\"><code>Deno.serve</code>接受一个函数，函数接受请求对象返回响应。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const handler = (req: Request) {\n    return new Response(\"Hello, World!\");\n}\n\nDeno.serve(handler);</code></pre>\n<h2>路由</h2>\n<p class=\"paragraph\">Deno 本身并没有实现路由，但是可以通过手动解析 <code>pathname</code>实现。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const handler = (req: Request) {\n    const { pathname } = new URL(req.url);\n\n    if (pathname === \"/\") {\n        return new Response(\"Hello, World!\");\n    }\n\n    if (pathname === \"/foo\") {\n        return new Response(\"bar\");\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n}</code></pre>\n<p class=\"paragraph\">对于复杂的路由，可以尝试把 handler 封装到 map 中：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">type Handler = (req: Request) =&gt; Response;\ntype HandlerMap = { [pathname: string]: Handler };\n\nconst handlers: HandlerMap = {\n  \"/\": () =&gt; new Responese(\"Hello, World!\"),\n  \"/foo\": () =&gt; new Response(\"bar\"),\n};\n\nconst handler = (req: Request) =&gt; {\n  const { pathname } = new URL(req.url);\n\n  const matchedHandler = handlers[pathname];\n\n  if (matchedHandler) {\n    return matchedHandler(req);\n  }\n\n  return new Response(\"Not Found\", { status: 404 });\n};</code></pre>\n<h2>格式化响应</h2>\n<p class=\"paragraph\">最好封装一个格式化响应对象，封装 <code>success</code>，<code>message</code>，<code>data</code>等属性，方便处理：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">class FmtResponse&lt;T&gt; {\n  private code: number = 200;\n  private success: boolean = true;\n  private message: string = \"success\";\n  private data: T | null = null;\n\n  constructor(opts: { code?: number; message?: string; data?: T }) {\n    if (opts.code &amp;&amp; opts.code &gt;= 400) {\n      this.success = false;\n    }\n    this.message = opts.message || \"success\";\n    this.data = opts.data || null;\n  }\n}</code></pre>\n<p class=\"paragraph\">并提供一个 <code>json</code>方法返回 json 格式的响应：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">public json() {\n    const resObj = {\n      success: this.success,\n      message: this.message,\n      data: this.data,\n    };\n\n    return new Response(JSON.stringify(resObj), {\n      status: this.code,\n      headers: {\n        \"content-type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n        \"Access-Control-Allow-Headers\": \"Content-Type, apikey\",\n      },\n    });\n}</code></pre>\n<h2>数据的储存</h2>\n<p class=\"paragraph\">选择 <code>Deno Deploy</code>很大一部分原因是因为其方便的 kv 储存，可以方便的持久化储存数据：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const kv = await Deno.openKv();\n\nawait kv.set([\"settings\", \"username\"], \"redish101\");\n\nconst username = await kv.get([\"settings\", \"username\"]);\n\nconsole.log(username.value); // \"redish101\"</code></pre>\n<p class=\"paragraph\">值得一提的是，<code>DenoKV</code>虽然可以在本地使用，但是需要在 cli 传入 <code>--unstable-kv</code>：</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">deno run --unstable-kv main.ts</code></pre>\n<h2>监控数据的上报</h2>\n<p class=\"paragraph\">这部分没什么可说的，用 rust 写了一个上报器，每 20 分钟通过请求接口上报正常状态的数据，并作为 macOS 服务运行：</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">use std::env;\n\nuse tokio::time;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt::init();\n\n    info!(\"Welcome to remonitor!\");\n\n    let apiurl = \"https://redish101-remonitor.deno.dev/remonitor\";\n    let apikey = env::var(\"APIKEY\").unwrap();\n\n    let mut interval = time::interval(time::Duration::from_secs(1200));\n\n    loop {\n        interval.tick().await;\n        info!(\"Post status\");\n        reqwest::Client::new()\n           .get(apiurl)\n           .header(\"apikey\", apikey.clone())\n           .send()\n           .await\n           .expect(\"Failed to send request\");\n        info!(\"Sent request\");\n    }\n}</code></pre>\n<p class=\"paragraph\">macos 的服务不能直接读取环境变量，只能读取通过 <code>launchctl setenv</code>设置的环境变量。通过 plist 设置 <code>keepAlive</code>可以实现后台运行：</p>\n<pre class=\"language-xml lang-xml\"><code class=\"language-xml lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;Label&lt;/key&gt;\n    &lt;string&gt;top.redish101.remonitor&lt;/string&gt;\n    &lt;key&gt;ProgramArguments&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;/path/to/client&lt;/string&gt;\n    &lt;/array&gt;\n    &lt;key&gt;RunAtLoad&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;key&gt;KeepAlive&lt;/key&gt;\n    &lt;true/&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;</code></pre>\n<h2>部署</h2>\n<p class=\"paragraph\"><code>Deno Deploy</code>是Deno推出的saas服务，提供了Deno程序的部署、KV、定时任务等功能，并且速度不错，所以选择了通过Deno Deploy部署。</p>\n<h2>总结</h2>\n<p class=\"paragraph\">Deno虽说目前不怎么适合放到大型项目的生产环境，但是写一些小服务玩玩还是很舒服的，编码体验很好</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/deno#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1721679226}, {"title": "广场月刊（第 1 期）：顿感生活", "author": "林木木的博客", "pubDate": "2024-07-07 07:01:06", "link": "https://immmmm.com/month-1-20240707/", "description": "\n<blockquote>\n<p>人到中年，所有的正能量和负能量，都不再来得那么排山倒海。的确是！大喜，大悲，大笑，大怒，似乎再也不见。更多的是，有好消息时，“好，我知道了”。有麻烦了，“好，想办法解决”。不顺是常态，比自己不幸的人多得是，似乎也没有什么资格自怨自艾。——《笑得出来的养育》</p>\n</blockquote>\n<h3>主题图</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-fmyh.jpg.webp\" alt=\"\"></p>\n<p>银河。内蒙古乌兰哈达火山，一个我俩从未去过的地方。（By <a href=\"https://blog.7wate.com/archives/wu-lan-ha-da-huo-shan-yin-he-zhi-lu\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@仲平</a>）</p>\n<h3>走着</h3>\n<h4>1.看日出</h4>\n<p>七月七日晴，今早四点多去深圳玩公园日出剧场看日出。（via <a href=\"https://i.hux.ink:5233/m/446\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@落落vici</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-krc-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-krc-2.jpg.webp\" alt=\"\"></p>\n<h4>2.东北卢浮宫</h4>\n<p>（via <a href=\"https://yinji.net/m/123\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@Mr.Hu</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dblfg-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dblfg-3.jpg.webp\" alt=\"\"></p>\n<h4>3.雨后彩虹与晚霞</h4>\n<p>（via <a href=\"https://memos.yhz610.com/m/kPHomfUPRzX4yk5YFLBHg4\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@Leslie</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-chwx-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-chwx-2.jpg.webp\" alt=\"\"></p>\n<h4>4.夏日玩水</h4>\n<p>在坪山，从家导航过去43公里，地铁16号线田心站直达。夏日溯溪玩水计划，就从这个新开的公园开始。路边的公交站台叫“对面喊居民小组”，有意思。（By <a href=\"https://hux.ink/posts/h2o/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@落落vici</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-xrws-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-xrws-2.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-xrws-3.jpg.webp\" alt=\"\"></p>\n<h4>5.初夏荷花开</h4>\n<p>嫘祖文化苑念祖湖的荷花又盛开了。（By <a href=\"https://xyzbz.cn/archives/1194/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@网友小宋</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-hhk-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-hhk-3.jpg.webp\" alt=\"\"></p>\n<h4>6.宁波一日游</h4>\n<p>至于为什么是宁波，我同样也说不清楚。大概是因为那句「杭州不理发，宁波不买车」的顺口溜，身在杭州，自然就联想到了宁波；或是宁波离杭州近，又靠近海边，海对我有莫名的吸引力……。（By <a href=\"https://www.zzxworld.com/posts/ning-bo-one-day-tour\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@zzxworld</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-nbchm-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-nbchm-3.jpg.webp\" alt=\"\"></p>\n<h4>7.宁波东钱湖</h4>\n<p>由后花园，一转身，已成客厅。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dqhcf-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dqhcf-2.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dqhcf-3.jpg.webp\" alt=\"\"></p>\n<h4>8.赴中原</h4>\n<p>受同学召唤去河南一游，欣然前往。高铁驶入北方，平原的辽阔气象就在窗外显露出来。可能生在北方平原地区，所以更喜欢广阔坦荡的格局。胸有丘壑固然能让人起敬，但直率坦白更让人乐于亲近，北方原野的景色正是这种气质。 （By <a href=\"https://blog.shaoxiao.net/2024/06/22/central-plains/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@Drunker</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-fzy-3.jpg.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-fzy-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-fzy-2.jpg.webp\" alt=\"\"></p>\n<h4>9.悬空寺</h4>\n<p>远眺悬空寺，它宛如悬挂在陡峭悬崖上的明珠，给人以强烈的视觉冲击。寺前的浑河水流湍急，峡谷中呼啸的冷风更增添了几分神秘感。这种自然与人文的完美结合，让人不禁感叹古人的智慧。（By <a href=\"https://sizheng.org/travel/xuan-kong-si/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@小雪</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-sxxks-1.avif\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-sxxks-3.avif\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-sxxks-2.avif\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-sxxks-4.avif\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-sxxks-5.avif\" alt=\"\"></p>\n<h4>10.登黄山</h4>\n<p>登黄山天下无山。时隔九年再登黄山，上次的记忆已经稀疏，再见的感受又是耳目一新，山上的天气风云变幻，总有惊喜出现，词穷的我不知该如何表达。（via <a href=\"https://memos.vlieo.com/m/88\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@else</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dhs-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dhs-4.jpg.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dhs-2.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dhs-3.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-dhs-5.jpg.webp\" alt=\"\"></p>\n<h4>11.川西大环线</h4>\n<p>一直对川西有所向往，终于在 5 月底前往。一行 4 人，选择租车自驾，行程总耗时 7 天 7 晚。</p>\n<p>川西之旅，最美的风景永远在路上！当你万分疲惫，厌于赶路时，前方峰回路转，一排雪山突然映入眼帘！那种感觉，真的会让你觉得不枉此行！所有的形容词最终汇成两个字：卧槽！（By <a href=\"https://blog.cuger.cn/p/65cb/#%E8%B5%B6%E8%B7%AF-5\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@Dorad</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-cxdhx-1.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-cxdhx-2.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-cxdhx-3.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-cxdhx-4.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-cxdhx-5.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-cxdhx-6.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-cxdhx-7.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-cxdhx-8.webp\" alt=\"\"></p>\n<h3>记着</h3>\n<h4>1.许愿</h4>\n<p>作为一个特别愿意许愿的人，有了一个新的人生梦想：在家里有一间屋子，可以放下 500 本书，200 张唱片，一台黑胶唱机和一台投影配上一个家庭影院。 （via <a href=\"https://memos.elizen.me/m/1440\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@Elizen</a>）</p>\n<h4>2.老家洪水</h4>\n<p>老家洪水快涨上我家房子门槛了，门前田里的水稻、蔬菜全淹没了，今年的粮食收成将会非常惨淡，承包的人会亏本了。村里面下午已经拉闸停电了，今晚再继续涨，可能河对岸的堤坝也顶不住了。印象中河里发这么大水还是小学时候，20 多年前。（via <a href=\"https://i.hux.ink:5233/m/426\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@落落vici</a>）</p>\n<h4>3.瞬间与漫长</h4>\n<p>死亡就是一瞬间的事，等待死亡却是一件很漫长的事。我们都在用一生等待一瞬间的死亡，但愿死亡是美好的，一切得以善终。（via <a href=\"https://memos.lniaen.com/m/bZJwPPgQRnXpKtDUQMVRGu\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@lniaen</a>）</p>\n<h4>4.红伞伞白杆杆</h4>\n<p>红伞伞，白杆杆，吃完一起躺板板。躺板板睡棺棺，然后一起埋山山。埋山山哭喊喊，全村都来吃饭饭，吃饭饭有伞伞，全村一起躺板板。躺板板没人埋，然后一起晒干干。晒干干，冒烟烟，然后一起升仙仙，做仙仙下凡凡，下凡凡后捡伞伞。（via <a href=\"https://b.lms.pub/m/218\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@不亦乐乎</a>）</p>\n<h4>5.看你不顺眼</h4>\n<p>今天早饭时，上小学一年级的闺女对我说 “爸爸，我看你越来越不顺眼了”，我说怎么了，闺女说 “你看你，胡子那么长了也不剃，头发也长了也不剪，真是越看越不顺眼！”。哈哈哈，好好，听闺女的，立马把胡子剃了！（via <a href=\"https://memos.laozhang.org/m/68uG8oFAUHe3dB934tLBCp\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@老张</a>）</p>\n<h4>6.不要住青旅</h4>\n<p>不要在深圳住青旅，要不然一大堆找不到工作的人在哪焦虑，搞得你也很焦虑😕 （via <a href=\"https://s.dusays.com/m/H8FV2vfNbLZDfwDxeup34k\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@wangyunzi</a>）</p>\n<h4>7.屏蔽力</h4>\n<p>最顶级的能力是屏蔽力。任何消耗你的人和事，多看一眼都是你的不对。——  罗素 （via <a href=\"https://bb.pipuwong.com/m/200\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@Pipu</a>）</p>\n<h4>8.下一个十年</h4>\n<p>知乎的导演组帮我合成了一个镜头，虽然拍摄的时候，就知道素材会被这样使用，但是当我看到影像的一瞬间，还是被触动了。 （By <a href=\"https://miniflux.edui.fun/starred/entry/7023\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@苏洋</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-sy.jpg.webp\" alt=\"\"></p>\n<h3>看着</h3>\n<h4>1.《置身事内》</h4>\n\n\n\n\n\n    \n\n\n\n\n    \n    <div class=\"db-card\">\n        <div class=\"db-card-subject\">\n            <div class=\"db-card-post\"><img loading=\"lazy\" decoding=\"async\" referrerpolicy=\"no-referrer\" src=\"https://db.immmmm.com/book/35546622.jpg\"></div>\n            <div class=\"db-card-content\">\n                <div class=\"db-card-title\"><a href=\"https://book.douban.com/subject/35546622/\" class=\"cute\" target=\"_blank\" rel=\"noreferrer\">置身事内</a></div>\n                <div class=\"rating\">\n<span class=\"allstardark\"><span class=\"allstarlight\"></span></span><span class=\"rating_nums\">9.1</span>\n</div>\n                <div class=\"db-card-abstract\">兰小欢 / 2021 / 上海人民出版社</div>\n            </div>\n            <div class=\"db-card-cate\">book</div>\n        </div>\n    </div>\n\n\n\n<p>不断利好的房产政策我们该买房吗？面对不断利好购房的政策，我们到底是该顺应国家大方向政策积极买房呢？还是觉得房价没到底，坚决不买呢？下面结合自己作为一个异地购房人、北京看过房的人以及在这个周期内亲历的人的视角来说说自己的看法。 （By <a href=\"https://blog.sailfishc.com/house-V2\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@橙子</a>）</p>\n<h4>2.《我的前半生》</h4>\n\n\n\n\n\n    \n    \n\n\n\n\n\n    \n    <div class=\"db-card\">\n        <div class=\"db-card-subject\">\n            <div class=\"db-card-post\"><img loading=\"lazy\" decoding=\"async\" referrerpolicy=\"no-referrer\" src=\"https://cors.immmmm.com/https://neodb.social/m/book/2021/12/0917cb02fc-58ff-41e2-aa9b-b516c5c6f03d.jpg\"></div>\n            <div class=\"db-card-content\">\n                <div class=\"db-card-title\"><a href=\"https://book.douban.com/subject/34873403/\" class=\"cute\" target=\"_blank\" rel=\"noreferrer\">我的前半生</a></div>\n                <div class=\"rating\">\n<span class=\"allstardark\"><span class=\"allstarlight\"></span></span><span class=\"rating_nums\">0</span>\n</div>\n                <div class=\"db-card-abstract\">《我的前半生》是我国末代皇帝爱新觉罗·溥仪的回忆录。周恩来总理接见溥仪时曾说：“你的东西基本上是要与旧社会宣战，彻底暴露……历史上还找不出这样的例子，你创造了一个新纪元。”\n本书按时间顺序叙述，先从家世开始介绍，然后对童年、在位、逃难、改造等这几个人生大片段按顺序介绍。全书语言通俗，故事情节强。自1964年出版后，受到读者欢迎，译成英语、日语、德语等文字出版。\n溥仪的《我的前半生》自1964年出版后在国内外产生了很大的影响，对普通读者了解中国近代以来的曲折历史有很好的普及作用。而他的童年自述，以及从患得患失到坚定决心的改造过程，对于当下的学校教育、家庭教育也有启示作用，值得推荐给每一位家长、老师阅读。</div>\n            </div>\n            <div class=\"db-card-cate\">book</div>\n        </div>\n    </div>\n\n\n\n<p>溥仪于1957年下半年开始写此自传，1959年年末，蒙特赦被释放出来。《我的前半生》可以看作其对前半生的反省乃至觉醒，是自白书，自省书，某种程度上也是“认罪书”，“自首书”。 （By <a href=\"https://blog.sailfishc.com/house-V2\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@橙子</a>）</p>\n<h4>3.《笑得出来的养育》</h4>\n\n\n\n\n\n    \n\n\n\n\n    \n    <div class=\"db-card\">\n        <div class=\"db-card-subject\">\n            <div class=\"db-card-post\"><img loading=\"lazy\" decoding=\"async\" referrerpolicy=\"no-referrer\" src=\"https://db.immmmm.com/book/36899777.jpg\"></div>\n            <div class=\"db-card-content\">\n                <div class=\"db-card-title\"><a href=\"https://book.douban.com/subject/36899777/\" class=\"cute\" target=\"_blank\" rel=\"noreferrer\">笑得出来的养育</a></div>\n                <div class=\"rating\">\n<span class=\"allstardark\"><span class=\"allstarlight\"></span></span><span class=\"rating_nums\">8.7</span>\n</div>\n                <div class=\"db-card-abstract\">李一诺 / 2024 / 浙江教育出版社</div>\n            </div>\n            <div class=\"db-card-cate\">book</div>\n        </div>\n    </div>\n\n\n\n<p>“你上一次和孩子大笑是什么时候”被封面上的这句话戳到泪点。</p>\n<h4>4.《犯罪都市4》</h4>\n\n\n\n\n\n    \n    \n\n\n\n\n\n    \n    <div class=\"db-card\">\n        <div class=\"db-card-subject\">\n            <div class=\"db-card-post\"><img loading=\"lazy\" decoding=\"async\" referrerpolicy=\"no-referrer\" src=\"https://cors.immmmm.com/https://neodb.social/m/item/doubanmovie/2024/02/24/5529dd39-7c62-4cd3-94c2-7d5b0554e641.webp\"></div>\n            <div class=\"db-card-content\">\n                <div class=\"db-card-title\"><a href=\"https://movie.douban.com/subject/36085987/\" class=\"cute\" target=\"_blank\" rel=\"noreferrer\">犯罪都市4</a></div>\n                <div class=\"rating\">\n<span class=\"allstardark\"><span class=\"allstarlight\"></span></span><span class=\"rating_nums\">6.1</span>\n</div>\n                <div class=\"db-card-abstract\">「怪物刑警」马锡道（马东锡 饰）这次要对抗的是规模最大的网络非法赌博组织首脑．白昌其（金武烈 饰），他是特种部队佣兵出身的恶徒；另外还要对付IT业界出身的天才CEO．张东哲（李东辉 饰）。马锡道将与华丽回归的张夷秀（朴智焕 饰）、广搜队及网络搜查队合作，展开更胜以往的扫荡行动！</div>\n            </div>\n            <div class=\"db-card-cate\">movie</div>\n        </div>\n    </div>\n\n\n\n<p>一年一部吗？第四部又出来咯，抽空也要看看😅（via <a href=\"https://isay.live/m/5tamRfgEbMoFDzpavwj5wJ\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@xsinger.me</a>）</p>\n<h4>5.《何以中国》</h4>\n\n\n\n\n\n    \n\n\n\n\n    \n    <div class=\"db-card\">\n        <div class=\"db-card-subject\">\n            <div class=\"db-card-post\"><img loading=\"lazy\" decoding=\"async\" referrerpolicy=\"no-referrer\" src=\"https://db.immmmm.com/movie/35441874.jpg\"></div>\n            <div class=\"db-card-content\">\n                <div class=\"db-card-title\"><a href=\"https://movie.douban.com/subject/35441874/\" class=\"cute\" target=\"_blank\" rel=\"noreferrer\">何以中国</a></div>\n                <div class=\"rating\">\n<span class=\"allstardark\"><span class=\"allstarlight\"></span></span><span class=\"rating_nums\">9.2</span>\n</div>\n                <div class=\"db-card-abstract\">2023 / 中国大陆 / 纪录片 / 干超 周洪波 魏国歌 王凯 钟倍尔 黄瀛灏 王冲霄 许贞 曹兢 / 胡歌 曹磊</div>\n            </div>\n            <div class=\"db-card-cate\">movie</div>\n        </div>\n    </div>\n\n\n\n<p>第29届上海电视节白玉兰奖，最佳系列纪录片。</p>\n<h3>吃土着</h3>\n<h4>1.黑色限定 6800XT 的公版。</h4>\n<p>当初本来是打算用着6700XT等6800XT、3080降价的。结果都2024年了，6700XT都用了两年了，6800XT还稳在2500块，3080又涨500块，过于魔幻。 （By <a href=\"https://prisonlog.com/1083.html\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@Fish</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-6800xt.jpg.webp\" alt=\"\"></p>\n<h4>2.新键盘与新键帽</h4>\n<p>换键帽的感觉跟换新键盘差不多，虽然键盘也是国产卷王之一的狼蛛，但 50 块比 200 块可是少了一大截，感觉赚到了。 （By <a href=\"https://prisonlog.com/1083.html\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@Fish</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-xjpxjm-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-xjpxjm-2.webp\" alt=\"\"></p>\n<h4>3.HUAWEI WATCH GT 4</h4>\n<p>去线下体验后，随即入手了HUAWEI WATCH GT 4 这款手表，选的是山茶棕配色，一直带到现在。 （By <a href=\"https://bluehe.cn/archives/huawei-watch-gt4\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@云心怀鹤</a>）</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-huaweigt4-1.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-huaweigt4-2.jpg.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/07/mk1-huaweigt4-3.jpg.webp\" alt=\"\"></p>\n<h3>折腾着</h3>\n<h4>1.<a href=\"https://opml.imadij.com/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">opml-editor</a>: 一个在线 OPML 编辑器，支持查重。</h4>\n<h4>2.<a href=\"https://yelleis.top/p/534224a3/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Quarz 4.0 部署记录</a>\n</h4>\n<h4>3.<a href=\"https://fatesinger.com/103519\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Hugo 简明教程</a>\n</h4>\n<h4>4.<a href=\"https://blog.zhheo.com/p/6a933575.html\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">全站图片使用avif格式</a>\n</h4>\n<h4>5.<a href=\"https://www.pseudoyu.com/zh/2024/06/30/free_image_hosting_system_using_r2_webp_cloud_and_picgo/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">从零开始搭建你的免费图床系统</a>\n</h4>\n<h4>6.<a href=\"https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/editor-width-slider/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Obsidian 插件：Editor Width Slider 帮你快速自定义笔记的栏宽</a>\n</h4>\n<p>Obsidian默认的编辑器宽度太窄了，看着非常费劲，尤其是有表格，太难看了。找了个插件，真爽。（via <a href=\"https://me.niege.app/m/1272\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">@错爱涅槃</a>）</p>\n<h3>维护着</h3>\n<p>广场周刊改为月刊，内容由个人关注的 Memos 和 Feed 整理而成。</p>\n<p>以下站点无法打开或长时间未更新，已删除。若恢复请告知。</p>\n<pre tabindex=\"0\"><code>https://memos.ssean.top\nhttps://m.leonus.cn\nhttps://memos.dafeng.xyz\nhttps://memo.xiewei.link\n</code></pre>\n", "categories": ["%E6%9C%88%E5%88%8A"], "time": 1720306866}, {"title": "国产光学顶起来了？永诺42.5mm f1.7 使用体验报告", "author": "小N同学的博客", "pubDate": "2024-04-23 02:40:27", "link": "https://www.imcharon.com/8557/", "description": "在这个镜头机身溢价的时代，国产能否发力抢出一片市场？", "categories": ["往日余生", "精选", "摄影", "照片", "镜头"], "time": 1713811227}, {"title": "【Magisk】方正悠黑 Google Sans VF On OPlus", "author": "小N同学的博客", "pubDate": "2024-03-27 14:33:01", "link": "https://www.imcharon.com/8539/", "description": "这是一款基于方正悠黑 Google VF Sans可变字体的OPlus机型字体模块 OPPO / OnePlu […]", "categories": ["往日余生", "教程", "maigsk", "root", "美化"], "time": 1711521181}, {"title": "【Magisk】Manrope腾祥黑体 VF On OPlus By Charon", "author": "小N同学的博客", "pubDate": "2024-03-25 17:53:32", "link": "https://www.imcharon.com/8525/", "description": "这是一款基于Manrope腾祥黑体 VF Sans可变字体的OPlus机型字体模块", "categories": ["往日余生", "教程", "magisk", "root", "美化"], "time": 1711360412}, {"title": "Bitwarden插件无法登录如何修复（Cannot read properties of nul(reading ‘iterations‘)）", "author": "小N同学的博客", "pubDate": "2024-03-22 17:58:32", "link": "https://www.imcharon.com/8514/", "description": "修复一个奇怪的BUG", "categories": ["往日余生", "教程", "bitwarden"], "time": 1711101512}, {"title": "SteamDeck开启samba服务", "author": "Yume.KISEKI", "pubDate": "2024-01-15 14:27:53", "link": "https://www.monoko.jp/steamdeck-samba/", "description": "SteamDeck开启samba服务 1.前言 为什么steamdeck要开启samba服务，不为别的，我只用 […]", "categories": ["share", "samba", "steamdeck"], "time": 1705300073}, {"title": "记录一次勇敢的旅程", "author": "小N同学的博客", "pubDate": "2023-12-30 13:56:09", "link": "https://www.imcharon.com/8477/", "description": "在12月初的时候，我计划了一场“特种兵”式的西部旅游计划。 不知道大家最近刷社交媒体，有没有刷到一句话： 纵观 […]", "categories": ["往日余生", "旅行"], "time": 1703915769}, {"title": "2023年年终总结", "author": "Redish101博客", "pubDate": "2023-12-15 11:08:54", "link": "https://blog.redish101.top/article/2023-summary", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/2023-summary\">https://blog.redish101.top/article/2023-summary</a>\n</blockquote>\n<div>\n<p class=\"paragraph\">又到了年末，又到了作年终总结的时候了。本来不想写年末总结的，但是看看这更新日期以及屈指可数的文章，还是写一篇为好。</p>\n<h2>博客数据</h2>\n<p class=\"paragraph\">本年度博客程序部分进行了两次大改版，第一次于本年3月由Hexo至Next.js Pages Router，后于七月重构至Next.js App Router，但核心的数据管理部分未做更改。而在ui设计方面使用了苏卡卡大佬的设计，但由于闭源，均为亲自实现。并于最近使用vite整理封装为react组件库(@recomponents/react)，但组件较少，缺失Input，List等实用组件，一般建议在如博客等场景中应用，而其中Card组件可自定义参数较多，可以实现较高程度的定制化。组件库使用了style9实现了预编译的原子化css，自npm下载使用时无需进行编译器层面的配置，但生产环境下类名经过处理，不易调试。</p>\n<p class=\"paragraph\">新博客在Markdown渲染上会尝试接入尚未完成的由rust编写的Markdown解析器，主要用作练手使用。</p>\n<h2>服务商的选择</h2>\n<h3>服务端</h3>\n<p class=\"paragraph\">由于vercel平台在管理自动部署等方面相较于其它服务商较好的优化，并且对于Next.js项目有极好的支持，所以至今所有web服务均部署在vercel上。</p>\n<h3>CDN</h3>\n<p class=\"paragraph\">八月份Jason送了初七云亚太加速包，速度很好，但是配置方面实在不易学习，故又更换为Cloudflare，而Cloudflare在中国内地的访问速度并为太过于无法接受，且在配置方面有更好的效果，用起来还是十分不错的。</p>\n<h2>新技能</h2>\n<p class=\"paragraph\">2022年目标中的新技能列表如下:</p>\n<ul>\n<li>Rust</li>\n<li>Unity</li>\n<li>Blender</li>\n<li>Pytorch</li>\n<li>K8S</li>\n<li>Latex</li>\n</ul>\n<p class=\"paragraph\">其中已经实现的有:</p>\n<ul>\n<li>Rust</li>\n<li>Blender</li>\n<li>Ltex</li>\n</ul>\n<blockquote><p class=\"paragraph\">生命不息，奋斗不止</p></blockquote>\n<p class=\"paragraph\">真的有认真在学啊！！！可是学不会，我是废物啊啊啊！</p>\n<h2>项目</h2>\n<h3>Retalk</h3>\n<p class=\"paragraph\">大规模重构ing.....</p>\n<h3>remake-rs</h3>\n<p class=\"paragraph\">在写js相关操作</p>\n<h3>远期规划</h3>\n<ul><li>基于Rust的Minecraft: Bedrock Edition服务端</li></ul>\n<h2>辛导</h2>\n<blockquote><p class=\"paragraph\">想象作品，如果你觉得被冒犯了，不好意思，冒犯的就是你</p></blockquote>\n<p class=\"paragraph\">博客交流群的格局，是和别处不同的：都是网站上挂一个二维码，可以随时进群。闲逛的人，偶尔看到此二维码，每每拿出手机，扫码进群。（这是几个月前的事，现在进群管理们会提防着辛导）在群里闲聊，偶尔换个友链；倘若多有空闲，便盯着群内，时刻聊天了。如果整天不时看群，那就能见识到各色奇人了。但这些群友，多是社畜或学生，时间大抵没有这样阔绰。只有整天摸鱼的，才坐在屏幕前，整日看群。</p>\n<p class=\"paragraph\">我从去年起，便在群里，群主说，时间不够，怕见不了太多事情，就偶尔看下群罢。下午的群友，虽然不懂许多，但提问清清楚楚态度端正的也很不少。他们往往语气恳切，发出最完整的日志，又详细给出复现步骤，然后提问：在这恳切态度下，无视也很为难。</p>\n<p class=\"paragraph\">这样的群，十分和谐，但总觉得有些单调，有些无聊。群友总是规规矩矩，没有逆天的人，教人活泼不得；只有辛导到店，才可以笑几声，所以至今还记得。</p>\n<p class=\"paragraph\">辛导是技术极差而态度傲慢的唯一的人。他话语很恼人；语气犀利，话语间时常夹些辱骂；几片乱蓬蓬的提问。发的的虽然是截图，可是又脏又破，似乎十多年没有补，也没有洗。他对人说话，总是****，教人涕笑皆非的。因为他姓辛，别人便从他光辉事迹上的“自导自演”这前无古人的一部分，替他取下一个绰号，叫作辛导。辛导一发言，所有水群的人便都看着他笑，有的叫道，“辛导，你又被禁言了！”他不回答，对群友说，“我可是个大佬。”便排出评论截图。他们又故意的高声嚷道，“你一定又自导自演了！”辛导又睁大眼睛说，“你怎么这样凭空污人清白……”“什么清白？我前天亲眼见你用别人邮箱自导自演，被禁言。”辛导便涨红了脸，额上的青筋条条绽出，争辩道，“假评论不能算演！……辛导的事，能算演么？”接连便是难懂的话，什么“假的注册”，什么“qexo”之类，引得众人都哄笑起来：店内外充满了快活的空气。</p>\n<p class=\"paragraph\">听人家背地里谈论，辛导原来也学过前端，但终于没有仔细，又不会研究；于是愈来愈菜，弄到将要乞求了。幸而演得一手好戏，便替主题开发者增加几点npm下载量，在朋友面前混得一点高大上。可惜他又有一样坏脾气，便是好吃懒做。折腾不到几天，便连话语和态度，一齐暴躁。如是几次，给他解答的人也没有了。辛导没有法，便免不了偶然做些自导自演的事。</p>\n<p class=\"paragraph\">辛导提过记挂问题，涨红的脸色渐渐复了原，旁人便又问道，“辛导，你当真会前端么？”辛导看着问他的人，显出不屑置辩的神气。他们便接着说道，“你怎的连半个访客也捞不到呢？”辛导立刻显出颓唐不安模样，脸上笼上了一层灰色，嘴里说些话；这回可是全是骗邮箱之类，一些不懂了。在这时候，众人也都哄笑起来：店内外充满了快活的空气。</p>\n<p class=\"paragraph\">在这些时候，我可以附和着笑，群主是决不责备的。而且群主见了辛导，也每每这样问他，引人发笑。辛导自己知道不能和他们谈天，便只好向好欺负的人说话。有一回对我说道，“你会用Qexo么”我略略点一点头。他说，“会，……我便问你一问。Qexo的注册，怎样做的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。辛导等了许久，很恳切的说道，“我想搞个注册”我暗想qexo搞不了注册的，而且静态博客要注册也无用；又好笑，又不耐烦，懒懒的答他道，“搞什么注册，你网站真的有人注册么？”辛导显出极恼怒的样子，将及其粗鄙的语言敲着柜台，点头说，“搞注册不止一样用法，你知道么？”我愈不耐烦了，努着嘴走远。辛导刚用把手放到键盘上，想在群里大放厥词，见我毫不热心，便又叹一口气，显出极惋惜的样子。</p>\n<p class=\"paragraph\">辛导是这样的使人快活，可是没有他，别人也便这么过。</p>\n<p class=\"paragraph\">有一天，大约是中秋前的两三天，群主正在慢慢的清理群员，取下聊天记录，忽然说，“辛导长久没有来了。”我才也觉得他的确长久没有来了。一个水群的人说道，“他怎么会来？……他小号都被踢了。”群主说，“哦！”“他总仍旧是傲慢。这一回，是自己发昏，竟傲慢到初七群里去了。他群的群友，傲慢得的么？”“后来怎么样？”“怎么样？先被禁言，后来是踢，踢了三四个小号。”“后来呢？”“后来小号都没了。”“没了怎样呢？”“怎样？……谁晓得？许是大号也被踢了了。”群主也不再问，仍然慢慢的整理他的聊天记录。</p>\n<p class=\"paragraph\">中秋之后，秋风是一天凉比一天，看看将近初冬；我整天的靠着火，也须穿上棉袄了。一天的下半天，没有一个群友，我正合了眼坐着。忽然间听得一个声音，“怎么给博客加评论。”这声音虽然极低，却很耳熟。看时又全没有人。站起来向外一望，那辛导便在群里提问。他脸上黑而且瘦，已经不成样子；穿一件破夹袄，盘着两腿，下面垫一个蒲包，用草绳在肩上挂住；见了我，又说道，“Hexo怎么加评论。”群主也伸出头去，一面说，“辛导么？你还欠十九次道歉呢！”辛导很颓唐的仰面答道，“这……下回还清罢。”群主仍然同平常一样，笑着对他说，“辛导，你又惹别人了！”但他这回却不十分分辩，单说了一句“不要取笑！”“取笑？要是不，怎么会被踢？”辛导低声说道，“自愿，退，退……”他的眼色，很像恳求群主，不要再提。此时已经聚集了几个人，便和群主都笑了。不一会，他问过问题，便又在旁人的说笑声中，慢慢走去了。</p>\n<p class=\"paragraph\">自此以后，又长久没有看见辛导。到了年关，群主取下记录说，“辛导还欠十九个道歉呢！”到第二年的端午，又说“辛导还欠十九个道歉呢！”到中秋可是没有说，再到年关也没有看见他。</p>\n<p class=\"paragraph\">我到现在终于没有见——大约辛导的确被踢了。</p>\n<h2>结语</h2>\n<p class=\"paragraph\">新年快乐。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/2023-summary#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1702609734}, {"title": "浅谈Quest3", "author": "Yume.KISEKI", "pubDate": "2023-11-25 15:41:21", "link": "https://www.monoko.jp/about-quest3/", "description": "入手quest3 当初想买quest2时发现已经出了有两年了，对于vr这种可有可无的设备干脆就等quest3了 […]", "categories": ["share", "quest3", "vr"], "time": 1700898081}, {"title": "Windows电脑音频大优化！杜比音效+Fx Sound双调教！", "author": "小N同学的博客", "pubDate": "2023-10-29 11:56:50", "link": "https://www.imcharon.com/8447/", "description": "作为一名离开音乐会死星人，windows没有任何调教的声音听着真的很难受，但是单杜比的效果又有点差强人意，那怎 […]", "categories": ["往日余生", "教程", "精选", "资源分享", "windows", "音效"], "time": 1698551810}, {"title": "2023年QQBOT防风控小妙招", "author": "轻音时雨的博客", "pubDate": "2023-09-25 11:20:37", "link": "https://www.594594.xyz/2023/09/25/qqbot_anti_risk/", "description": "<p>本文内容禁止抄袭、转载、搬运</p>", "categories": ["游戏相关", "教程"], "time": 1695612037}, {"title": "关于站点的未来，和最近的状况", "author": "小N同学的博客", "pubDate": "2023-09-01 15:19:47", "link": "https://www.imcharon.com/8436/", "description": "最近的时间非常少，站点几乎处于无维护状态。 首先！我要向申请友链的小伙伴们说声对不起，因为太忙导致没时间更新！ […]", "categories": ["往日余生"], "time": 1693552787}, {"title": "termux 安装 aircrak-ng", "author": "Utermux博客", "pubDate": "2023-07-23 03:48:26", "link": "https://blog.utermux.dev/ut/aircrack-ng.html", "description": "pkg i tur-repo -ypkg i aircrack-ng -y", "categories": [], "time": 1690055306}, {"title": "termux 安装 mdk4", "author": "Utermux博客", "pubDate": "2023-07-23 03:47:53", "link": "https://blog.utermux.dev/ut/mdk4.html", "description": "pkg i tur-repo -ypkg i mdk4 -y", "categories": [], "time": 1690055273}, {"title": "Next.js App Router初体验与实践: 将我的博客迁移到Next.js App Router与React Server Components", "author": "Redish101博客", "pubDate": "2023-07-13 05:03:10", "link": "https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230712213628.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131357.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131238.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components\">https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components</a>\n</blockquote>\n<div>\n<p class=\"paragraph\">在今年三月初，我使用 Next.js 重构了我的博客。现在，随着 Next.js AppRouter 的稳定，我又将博客从 Next.js Pages Router 迁移到了 Next.js 13 AppRouter 与 React Server Components，同时，我也做了大量的底层重构以及样式重构。</p>\n<h2>性能优化: React Server Components</h2>\n<p class=\"paragraph\">在 React 18 之前，所有的组件均为 <code>Client Components</code>，即客户端组件。顾名思义，客户端组件中的所有逻辑均在客户端执行。浏览器渲染客户端组件需要从服务端获取 chunk，然后渲染组件到页面。即使是在 SSR 中，也需要等待客户端组件所对应的 bundle 完成加载才能让页面具有逻辑，能够交互。而我们的一些操作并不需要在客户端调用：如获取数据，大量的类似的逻辑，大大提高了 bundle 的体积，使得页面加载相对较慢，而 <code>React Server Components</code>（以下简称 <code>RSC</code>）的出现很好的解决了这一问题。</p>\n<p class=\"paragraph\">RSC 不同于客户端组件，RSC 在服务端的 React 执行，客户端所收到的是服务端的执行结果，也就是说，客户端不会加载任何 RSC 的逻辑代码，以此我们就能缩小 Client Bundle。因为 RSC 是在服务端执行的，所以理所当然，RSC 内能够调用 node 环境，我们也就不必通过 <code>getStaticProps</code>等 api 获取数据。</p>\n<p class=\"paragraph\">之前的文章提到过，我将博客从 Hexo 迁移到了基于文件的 CMS，以往博客版本是这样获取数据的：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export async function getStaticPaths() {\n  const posts = getAllPosts([\"slug\"]);\n\n  return {\n    paths: posts.map((post) =&gt; {\n      return {\n        params: {\n          slug: post.slug,\n        },\n      };\n    }),\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }: any) {\n  const post = getPostBySlug(params.slug, [\"title\", \"date\", \"slug\", \"content\"]);\n  const content = await markdownToHtml(post.content || \"\");\n  await generateRss();\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content,\n      },\n    },\n  };\n}</code></pre>\n<p class=\"paragraph\">而在使用 RSC 后，我们可以直接获取数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default async function Post({ params }: { params: { slug: string } }) {\n  const post = getPostBySlug(params.slug, [\n    \"title\",\n    \"date\",\n    \"slug\",\n    \"cover\",\n    \"content\",\n  ]);\n  if (!post.title) {\n    return notFound();\n  }\n  const content = await markdownToHtml(post.content || \"\");\n  return (\n    &lt;&gt;\n      &lt;Card title={post.title} cover={post.cover} label={post.date.toString()}&gt;\n        &lt;div dangerouslySetInnerHTML={{ __html: content }} /&gt;\n      &lt;/Card&gt;\n    &lt;/&gt;\n  );\n}\n\nexport async function generateStaticParams() {\n  const posts = getAllPosts([\"slug\"]);\n  return posts.map((post) =&gt; ({\n    slug: post.slug,\n  }));\n}</code></pre>\n<p class=\"paragraph\">可以看见，使用 RSC 后的页面相比于不使用 RSC 的页面大幅减少了代码长度。</p>\n<p class=\"paragraph\">但正因 RSC 是在 node 环境运行的，所以我们不能在 RSC 使用浏览器的 api，也无法使用 <code>useState</code>等 api，也就是说，RSC 不能直接响应用户的交互。而当我们需要调用浏览器api时，可以通过在组件代码前加上 <code>\"use client\";</code>将组件更改为客户端组件，就能调用浏览器api。</p>\n<p class=\"paragraph\">值得一提的是，我们可以在RSC中引入客户端组件：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;div&gt;\n  This is a RSC\n  &lt;ClientComponent /&gt;\n&lt;/div&gt;</code></pre>\n<p class=\"paragraph\">但我们不能在客户端组件内引入RSC：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;ClientComponent&gt;\n  &lt;ServerComponent /&gt;\n&lt;/ClientComponent&gt;</code></pre>\n<p class=\"paragraph\">但我们依然有办法在客户端组件内直接调用RSC。前文提到，RSC在渲染过程中需要node的参与，但是返回结果是相当于静态的，所以我们可以通过Props的方式向客户端组件传入RSC的返回值实现：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;ServerComponent&gt;\n  const res = &lt;AnotherSC /&gt;\n  &lt;ClientComponent aprop={res} /&gt;\n&lt;/ServerComponent&gt;</code></pre>\n<h2>布局优化： Next.js App Router</h2>\n<p class=\"paragraph\">在 Next.js 13 中，Next.js 新增了一种新的路由方式：<code>App Router</code>。它基于 <code>React Server Components</code>开发，支持共享布局，加载状态，嵌套路由，错误处理等。其中对我而言最重要的更新就是嵌套路由。</p>\n<p class=\"paragraph\">App Router 将路由拆分为布局与内容两部分，其中布局支持嵌套，大大减少了代码冗余。例如我们要实现 AB 两个页面，二者都包含一个导航栏和一个侧边栏，B 页面在以上的基础下又包含其自身所需要的布局，即需要布局嵌套，在 <code>Pages Router</code>中，我们需要这样：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// A.tsx\nexport default function A() {\n  return (\n    &lt;LayoutA&gt;\n      &lt;Content /&gt;\n    &lt;/LayoutA&gt;\n  );\n}</code></pre>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// B.tsx\nexport default function B() {\n  return (\n    &lt;LayoutA&gt;\n      &lt;LayoutB&gt;\n        &lt;Content /&gt;\n      &lt;/LayoutB&gt;\n    &lt;/LayoutA&gt;\n  );\n}</code></pre>\n<p class=\"paragraph\">只有两层情况就已经如此糟糕，倘若有三层，四层.......代码的可读性将大大降低。但在 App Router 中，我们可以这样做:</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// app/a/layout.tsx\nexport default RootLayout({ children }: { children: ReactNode }) {\n  return (\n      &lt;html lang=\"zh-CN\"&gt;\n      &lt;body&gt;\n        &lt;NavBar /&gt;\n        &lt;div&gt;\n          &lt;LayoutA&gt;{children}&lt;/LayoutA&gt;\n        &lt;/div&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  )\n}</code></pre>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// app/a/b/layout.tsx\nexport default LayoutB({ children }: { children: ReactNode }) {\n  return &lt;LayoutA&gt;{children}&lt;/LayoutA&gt;\n}</code></pre>\n<p class=\"paragraph\">此时，b 页面的布局会自动继承 a 的布局，并在其基础上新增其自身布局，代码会十分简洁。</p>\n<p class=\"paragraph\">除了语法更加简洁，我们也可以通过AppRouter实现共享布局。</p>\n<h2>服务端: 从 SSG 迈向 SSR</h2>\n<p class=\"paragraph\">在<a href=\"https://blog.redish101.top/post/blog-v5\" target=\"_blank\" class=\"link\">「使用 Next.js 重构我的博客」</a>一文中我提到，我将博客核心所使用的 CMS 从 <code>Hexo</code>迁移到自研的基于文件的 CMS，在构建时使用 <code>Next.js Pages Router</code>提供的 <code>getStaticProps</code>等一系列 api 在构建时从本地获取文章并渲染，但在我迁移博客到 <code>Next.js App Router</code>时这样的做法无法通过构建，原因是 App Router 并不支持使用 <code>getStaticProps</code>等 api 获取数据。同时，在构建时渲染 Markdown 也会导致构建速度很慢，在考虑之下，我决定放弃 SSG，迈向 SSR。</p>\n<p class=\"paragraph\">但是，如果在每次访问都渲染一次文章，就会导致服务器压力激增，客户端访问速度直线上升。显然，这种做法是极其不明智的。好在，React 18 中提供了一个 <code>cache</code>方法，被 <code>cache</code>包裹的方法，在传参不变的情况下不会执行方法，而是直接返回缓存值，例如：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">import { cache } from \"react\";\n\nconst add = (a: number, b: number) =&gt; {\n  return a + b;\n};\n\nconst cacheAdd = cache(add);\n\ncacheAdd(1, 2); // 3\ncacheAdd(1, 2); // 3</code></pre>\n<p class=\"paragraph\">如果参数不变，多次调用 <code>cacheAdd</code>方法，并不会执行 <code>add</code>方法，而是会直接返回缓存值。上面的代码也可以写成这样：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">import { cache } from \"react\";\n\nconst add = cache((a: number, b: number) =&gt; {\n  return a + b;\n});\n\nadd(1, 2); // 3\nadd(1, 2); // 3</code></pre>\n<p class=\"paragraph\">接下来的事情就简单了，只需要在读取和渲染文章的方法外包裹 <code>cache</code>就能提高性能：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">export const getPostBySlug = cache((slug: string, fields: string[] = []) =&gt; {\n  // ...\n});</code></pre>\n<blockquote><p class=\"paragraph\">顺便提一下，本人参与开发的评论系统「retalk」也大量使用了缓存提高性能</p></blockquote>\n<p class=\"paragraph\">但现在依然有一个问题，现在服务端在收到请求后，会根据请求路径中的 slug 查找文章，并读取文章内容，但当文件不存在时，node 的 fs api 就会抛出错误，使 <code>getPostBySlug</code>方法没有返回任何内容，进而导致服务端返回 500，所以我们需要在 <code>getPostBySlug</code>方法中检测 slug 是否存在，若不存在则返回空对象而不是没有返回值：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">if (!fs.existsSync(fullPath)) {\n  return items;\n}</code></pre>\n<p class=\"paragraph\">在调用时检测返回对象是否包含 slug：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">if (!post.title) {\n  return notFound();\n}</code></pre>\n<p class=\"paragraph\"><code>notFound()</code>是 Next.js 提供的方法，可以手动返回 404。</p>\n<p class=\"paragraph\">这时，我们再尝试访问不存在的文章，服务端会返回 404，而非 500。</p>\n<h2>元数据: 从 next/head 到 Next Metadata</h2>\n<p class=\"paragraph\">在 Pages Router 中，我们可以在页面中返回 <code>Head</code>组件自定义页面的元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import Head from \"next/head\";\n\nexport default function PageA() {\n  return (\n    &lt;Head&gt;\n      &lt;title&gt;Your Title&lt;/title&gt;\n    &lt;/Head&gt;\n  );\n}</code></pre>\n<p class=\"paragraph\">而在 App Router 中，我们可以通过导出 <code>metadata</code>的方法设置元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"Your Title\",\n};</code></pre>\n<blockquote><p class=\"paragraph\">简介等属性同理</p></blockquote>\n<p class=\"paragraph\">除了静态导出，我们还可以通过导出 <code>generateMetadata</code>函数实现动态设置元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export async function generateMetadata({\n  params,\n}: {\n  params: { slug: string };\n}): Promise&lt;Metadata&gt; {\n  const post = getPostBySlug(params.slug, [\"title\", \"content\"]);\n  if (!post.title) {\n    return {\n      title: `404 - ${config.name}`,\n    };\n  }\n  return {\n    title: `${post.title} - ${config.name}`,\n    description: post.content.slice(0, 200),\n  };\n}</code></pre>\n<h2>Markdown 渲染: 从 remark 到 marked</h2>\n<p class=\"paragraph\">在以往的版本中，我使用 <code>remark</code>完成 Markdown 的渲染，但我逐渐发现，remark 逐渐无法满足我的需求，所以更换到 <code>marked</code>。marked 支持自定义渲染器，可以更方便的修改渲染逻辑。</p>\n<p class=\"paragraph\">本站的 markdown 渲染被封装到了一个 <code>markdownToHtml</code>函数，所以更改渲染器十分方便：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">export default async function markdownToHtml(markdown: string) {\n  const renderer = new marked.Renderer();\n\n  renderer.code = function (code, language) {\n    // 添加hljs类和data-language属性\n    let lang = language ? language.toUpperCase() : \"\";\n    if (!language) {\n      lang = \"TEXT\";\n    }\n    if (language == \"\") {\n      language = \"plaintext\";\n    }\n    const highlightedCode = highlightjs(code, language);\n    return `&lt;pre class=\"hljs language-${lang}\" data-language=\"${lang}\"&gt;\n      &lt;code&gt;${highlightedCode}&lt;/code&gt;\n    &lt;/pre&gt;`;\n  };\n  return marked.parse(markdown, { mangle: false, headerIds: false, renderer });\n}</code></pre>\n<blockquote><p class=\"paragraph\">完整的渲染器代码较长，此处仅展示部分代码，可能无法单独使用</p></blockquote>\n<p class=\"paragraph\">React 无法直接将 html 嵌入到组件作为子元素使用，但提供了属性 <code>dangerouslySetInnerHTML</code>供开发者显示 html 字符串，所以在这里可以这样写：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default async function Post({ params }: { params: { slug: string } }) {\n  const post = getPostBySlug(params.slug, [\n    \"title\",\n    \"date\",\n    \"slug\",\n    \"cover\",\n    \"content\",\n  ]);\n  if (!post.title) {\n    return notFound();\n  }\n  const content = await markdownToHtml(post.content || \"\");\n  return (\n    &lt;&gt;\n      &lt;Card title={post.title} cover={post.cover} label={post.date.toString()}&gt;\n        &lt;div&gt;\n          &lt;div&gt;{post.desc}&lt;/div&gt;\n          &lt;div dangerouslySetInnerHTML={{ __html: content }} /&gt;\n        &lt;/div&gt;\n      &lt;/Card&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<h2>代码高亮: 自定义主题</h2>\n<p class=\"paragraph\">以往版本中，正文部分所使用的代码高亮主题是由 <code>github-markdown-css</code>提供的，我逐渐发现其设计不满足我的需求，便进行了自定义。</p>\n<p class=\"paragraph\">代码高亮配色我觉得没有必要更改，但是 <code>highlight.js</code>提供的主题不支持深色模式，我就不得不手写配色。我将包含深色模式的配色放到了全局变量中：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">:root {\n  --pre: #fafafa;\n  --pre-comment: #6a737d;\n  --pre-string: #032f62;\n  --pre-literal: #032f62;\n  --pre-keyword: #d73a49;\n  --pre-function: #6f42c1;\n  --pre-deleted: #24292e;\n  --pre-class: #22863a;\n  --pre-property: #005cc5;\n  --pre-namespace: #6f42c1;\n  --pre-punctuation: #24292e;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --pre-comment: #757575;\n    --pre-string: #977cdc;\n    --pre-literal: #c64640;\n    --pre-keyword: #77b7d7;\n    --pre-function: #86d9ca;\n    --pre-deleted: #fff;\n    --pre-class: #dfab5c;\n    --pre-property: #77b7d7;\n    --pre-namespace: #86d9ca;\n    --pre-punctuation: #fff;\n  }\n}</code></pre>\n<p class=\"paragraph\">然后在 highlight.js 提供的默认主题基础上做修改，将颜色从固定值改为变量：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.hljs {\n  color: var(--text);\n  background: var(--pre);\n}\n.hljs-doctag,\n.hljs-keyword,\n.hljs-meta .hljs-keyword,\n.hljs-template-tag,\n.hljs-template-variable,\n.hljs-type,\n.hljs-variable.language_ {\n  color: var(--pre-keyword);\n}\n.hljs-title,\n.hljs-title.class_,\n.hljs-title.class_.inherited__,\n.hljs-title.function_ {\n  color: var(--pre-function);\n}</code></pre>\n<blockquote><p class=\"paragraph\">此处因篇幅原因只展示部分</p></blockquote>\n<p class=\"paragraph\">原有代码块并没有直接显示语言，容易产生歧义。出现了以下设计方案：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230712213628.png\" alt=\"两种方案\"><p class=\"paragraph\">显然第一种更显眼并具有设计感。</p>\n<p class=\"paragraph\">具体实现我使用了 <code>before</code>伪类的方式，通过 <code>attr(data-language)</code>读取自定义渲染器所输入的语言名称：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">return `&lt;pre class=\"hljs language-${lang}\" data-language=\"${lang}\"&gt;\n      &lt;code&gt;${highlightedCode}&lt;/code&gt;\n    &lt;/pre&gt;`;</code></pre>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">pre::before {\n  color: var(--text-l);\n  opacity: 0.25;\n  content: attr(data-language);\n  font-size: 1.625rem;\n  font-weight: 700;\n  position: absolute;\n  right: 0.5rem;\n}</code></pre>\n<p class=\"paragraph\">至此完成了代码块的修改。</p>\n<h2>CSS: Atomic CSS In JS</h2>\n<p class=\"paragraph\">传统的css在使用重复布局时回产生大量冗余，例如以下三个类：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.a {\n  padding: 1.125rem;\n  color: pink;\n}\n\n.b {\n  padding: 1.125rem;\n  color: skyblue;\n}\n\n.c {\n  margin: 1.125rem;\n  color: pink;\n}</code></pre>\n<p class=\"paragraph\">可以看见，<code>pading: 1.125rem</code>与 <code>color: pink</code>被在css中出现了多次，现在这个css文件共有6个属性。我们可以将它们拆分，封装成4个类：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.p-125 {\n  pading: 1.125rem;\n}\n\n.color-pink {\n  color: pink;\n}\n\n.color-skyblue {\n  color: skyblue;\n}\n\n.m-125 {\n  margin: 1.125rem;\n}</code></pre>\n<p class=\"paragraph\">在html中我们可以直接使用这些类的组合实现与第一种方式相同的效果，这就是原子化css。使用原子化设计的css只出现了4个属性。不难看出，原子化css能够减少css的体积。</p>\n<p class=\"paragraph\">在实际使用中，我们往往会使用已经绑定好的原子化css库，例如tailwindcss等。</p>\n<p class=\"paragraph\">但是，这种做法会导致代码中有一大串的类名，显然不够优雅。所以，我使用了 <code>style9</code>，实现atomic css in js，您可以打开devtools查看效果。</p>\n<h2>布局设计: 拥抱双飞翼</h2>\n<p class=\"paragraph\">以往版本的博客使用单栏设计，只留出中间一栏展示所有信息，这样做实现简单，但会导致比较单调。在新博客的设计中，我采用了「双飞翼」布局，即三栏布局：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131357.png\" alt=\"三栏布局\"><p class=\"paragraph\">将布局拆分为 <code>Sidebar</code>与 <code>Content</code>，使用Next App Router可以实现路由跳转只加载 <code>Content</code>。具体实现使用 <code>CSS Flex</code>布局。</p>\n<h2>基础设计: Card</h2>\n<p class=\"paragraph\">如你所见，本站现在的所有组件都是卡片，基础是一个具有 <code>title</code>，<code>label</code>，<code>content</code>，<code>size</code>，<code>cover</code>等众多属性的组件：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131238.png\" alt=\"布局演示\"><p class=\"paragraph\">以此保证样式的统一。</p>\n<h2>深色模式: CSS变量</h2>\n<p class=\"paragraph\">深色模式能够提高用户体验，为了实现深色模式，我为深色模式单独设计了配色，并通过 <code>@media (prefers-color-scheme: dark)</code>实现根据系统设置自动切换。</p>\n<h2>友情链接: 从静态到动态</h2>\n<p class=\"paragraph\">以往的友情链接是静态储存的，这样做难免会有局限性，在新版博客中，我将友情链接数据迁移到了GitHub仓库，并通过 <code>Chuqi CDN</code>实时获取友情链接信息。</p>\n<blockquote><p class=\"paragraph\">你想与101互换友情链接吗，那就看看下面的步骤吧</p></blockquote>\n<h3>前置条件</h3>\n<ul>\n<li>友情链接，先友后链，所以最好是101比较眼熟的朋友</li>\n<li>您的网站不是免费域名，包括但不限于：\n<ul>\n<li>由Freenom公司运营的 <code>.tk</code>，<code>.ml</code>等免费域名（不包括付费购买的域名）</li>\n<li>由 Joshua Anderson 运营的 Afraid FreeDNS 提供的免费子域名</li>\n<li>其他不包含在 Public Suffix List 中的 <strong>免费子域名</strong> 服务</li>\n<li>\n<code>*.github.io</code>，<code>*.gitee.io</code>等域名</li>\n</ul>\n</li>\n<li>不能是采集站！！！！！！！！！</li>\n<li>有三篇以上的原创文章（包括三篇）</li>\n<li>站点上有我的链接</li>\n</ul>\n<h3>我的信息</h3>\n<pre class=\"language-json lang-json\"><code class=\"language-json lang-json\">{\n  \"name\": \"Redish101 Blog\",\n  \"desc\": \"人文 科技 白日梦\",\n  \"icon\": \"https://blog.redish101.top/favicon.ico\",\n  \"link\": \"https://blog.redish101.top\"\n}</code></pre>\n<h3>添加</h3>\n<blockquote><p class=\"paragraph\">仓库: <a href=\"https://github.com/Redish101/friend-links\" target=\"_blank\" class=\"link\">https://github.com/Redish101/friend-links</a></p></blockquote>\n<p class=\"paragraph\">如果你满足前置条件，就可以开始提交。</p>\n<ol start=\"1\">\n<li>Fork本仓库</li>\n<li>更改data.json</li>\n<li>添加你的网站</li>\n<li>向本仓库提交pr</li>\n<li>等待审核</li>\n<li>审核完成后将会在Redish101 Blog下次构建时生效</li>\n</ol>\n<h2>尾声</h2>\n<p class=\"paragraph\">感谢阅读</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1689195790}, {"title": "Termux 安装xLog", "author": "Utermux博客", "pubDate": "2023-05-06 10:04:00", "link": "https://blog.utermux.dev/ut/xLog.html", "description": "Termux 安装xLog", "categories": [], "time": 1683338640}, {"title": "Termux安装各版本gcc", "author": "Utermux博客", "pubDate": "2023-04-30 08:32:00", "link": "https://blog.utermux.dev/ut/gcc.html", "description": "Termux安装各版本gcc", "categories": [], "time": 1682814720}, {"title": "Termux安装Vscode以及code-server", "author": "Utermux博客", "pubDate": "2023-04-30 08:29:15", "link": "https://blog.utermux.dev/ut/vscode.html", "description": "Termux安装Vscode以及code-server", "categories": [], "time": 1682814555}, {"title": "为我的网站添加深色模式", "author": "Redish101博客", "pubDate": "2023-03-28 13:06:55", "link": "https://blog.redish101.top/article/darkmode", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/darkmode\">https://blog.redish101.top/article/darkmode</a>\n</blockquote>\n<div>\n<h2>我们为什么需要「深色模式」</h2>\n<p class=\"paragraph\">不可避免的，我们在很多时候需要在黑暗的环境下访问网站，而在黑暗的环境下，如果网站依然有大部分亮色区域，会在瞬间使眼睛受到刺激，极大的降低了用户体验。</p>\n<p class=\"paragraph\">同时，深色模式能减少OLED屏幕的功耗，延长设备的使用时间这也是很多人在白天也依然打开深色模式的原因。</p>\n<p class=\"paragraph\">如今，很多操作系统已经支持了深色模式，macos也提供了很好的深色模式支持。Chrome、FireFox等主流浏览器也已经支持通过 <code>prefers-color-scheme</code>单独定义深色模式下的样式，这也降低了我们制作深色模式的难度。</p>\n<h2>「深色模式」的切换逻辑</h2>\n<p class=\"paragraph\">前面提到，我们可以通过 <code>prefers-color-scheme</code>来单独定义深色模式的样式，而 <code>prefers-color-scheme</code>是跟随系统的，显然，这种方式可以较好符合用户的个人喜好。</p>\n<h3>\n<code>prefers-color-scheme</code>的兼容问题</h3>\n<p class=\"paragraph\">的确，<code>prefers-color-scheme</code>对于低版本的浏览器适配并不友好，但是考虑到本站用户群体，这种问题几乎不会发生(其实是我懒)，所以就没有做过多处理。</p>\n<h2>「深色模式」的前端实现</h2>\n<h3>单独编写样式</h3>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">body {\n  color: #000;\n}\n\n@media (prefers-color-scheme: dark) {\n  body {\n    color: #fff;\n  }\n}</code></pre>\n<p class=\"paragraph\">显然，这种方式繁琐且复杂。</p>\n<h3>使用CSS Variable</h3>\n<p class=\"paragraph\">本站的配色信息都是以CSS Variable的形式存放在一个单独的css(global.css)中的，并在其他的css文件中可以直接通过 <code>var(xxxx)</code>引用，所以，我们可以为深色模式和亮色模式设计两种配色，并通过第一种方法实现，就可以实现自动的深色模式切换。</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">:root {\n  --bg: #f2f5f8;\n  --card-bg: #fff;\n  --text: #000;\n  --link: #007bff;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --bg: #0d1117;\n    --card-bg: #161b22;\n    --text: #c9d1d9;\n    --link: #58a6ff;\n  }\n}</code></pre>\n<p class=\"paragraph\">本站就是用的这种方法，在你的系统设置中切换配色即可体验。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/darkmode#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1679980015}, {"title": "使用Next.js重构我的博客", "author": "Redish101博客", "pubDate": "2023-03-04 04:33:10", "link": "https://blog.redish101.top/article/refactor-my-blog-with-next", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193114.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193416.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/refactor-my-blog-with-next\">https://blog.redish101.top/article/refactor-my-blog-with-next</a>\n</blockquote>\n<div>\n<h2>技术选型</h2>\n<h3>React VS Vue</h3>\n<p class=\"paragraph\">在这两者之间，我对React的使用更加熟练些，而且我认为使用TSX开发React应用的体验是愉悦的，所以选择React。</p>\n<h3>Gatsby VS Next.js</h3>\n<p class=\"paragraph\">这两者都是十分优秀的React框架，但我一直无法成功配置Gatsby环境，而且考虑到应用以后可能使用服务端渲染，所以选择Next.js。</p>\n<h3>SSR VS SSG</h3>\n<p class=\"paragraph\">博客目前并没有一些复杂的功能需要使用SSR实现，为了节省性能，选择了Next.js的SSG（以后会计划开发管理后台，所以以后可能会更换为SSR）。</p>\n<h2>UI设计</h2>\n<p class=\"paragraph\">为了提高界面主题的美观，降低实现的难度，我设计了较为简单（简陋）的ui，并做了移动端适配，尽量让移动端的用户能有较好的体验。</p>\n<h2>内容管理</h2>\n<p class=\"paragraph\">最开始，我准备效仿苏卡卡，使用hexo管理文章，但在进行一段时间的开发后，发现我对hexo api的了解无法满足使用。最后，我选择将文章储存为Markdown文件，并在每次更新后将其渲染为静态页面。</p>\n<p class=\"paragraph\">在众多Markdown渲染库中，我选择使用比较简单易用的 <code>remark</code>将markdown渲染为html：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { remark } from \"remark\";\nimport html from \"remark-html\";\n\nexport default async function markdownToHtml(markdown: string) {\n  const result = await remark().use(html).process(markdown);\n  return result.toString();\n}</code></pre>\n<p class=\"paragraph\">搞定正文的渲染，还有一个问题，由于并没有使用数据库文章信息，所以需要将文章信息放到 <code>front matter</code>内，再在构建时解析，转换为js能够读取的数据格式，并储存到页面的 <code>props</code>中，供前端使用。在处理 <code>front-matter</code>中，我选择了 <code>gray-matter</code>。</p>\n<p class=\"paragraph\">在读取Markdown并处理后，需要将文章数据传递给前端，供前端使用，但我并没有使用SSR，所以无法做到获取实时的文章数据，但得益于强大的Next.js，我们可以通过 <code>getStaticProps</code>，<code>getStaticPaths</code>在执行构建时获取数据，储存到props中，例如文章详情页的数据可以这样获取：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">export async function getStaticPaths() {\n  const posts = getAllPosts([\"slug\"]);\n\n  return {\n    paths: posts.map((post) =&gt; {\n      return {\n        params: {\n          slug: post.slug,\n        },\n      };\n    }),\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }: any) {\n  const post = getPostBySlug(params.slug, [\"title\", \"date\", \"slug\", \"content\"]);\n  const content = await markdownToHtml(post.content || \"\");\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content,\n      },\n    },\n  };\n}</code></pre>\n<p class=\"paragraph\">这样在前端就可以十分方便的使用数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default function Post(props: props) {\n  const router = useRouter();\n  const post = props.post;\n  const title = `${post.title} | Redish101 Blog`;\n  if (!router.isFallback &amp;&amp; !post?.slug) {\n    return &lt;Error404 /&gt;;\n  }\n  return (\n    &lt;&gt;\n      &lt;Head&gt;\n        &lt;title&gt;{title}&lt;/title&gt;\n      &lt;/Head&gt;\n      &lt;PostBody title={post.title} date={post.date} content={post.content} /&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<h2>样式实现</h2>\n<p class=\"paragraph\">在众多css in js库中，我选择了 <code>griffel</code>，通过 <code>makeStyles()</code>定义样式， <code>useStyles()</code>使用样式。使用它定义样式，在编码过程中ide会给出效果较好的代码提示，且由于其类名经过了处理，不会导致不同组件类名重复导致的样式冲突：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193114.png\" alt=\"\"><p class=\"paragraph\">在开发的过程中节约了很多时间，生成的随机类名可以很好的避免类名重复导致的错误：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193416.png\" alt=\"\"><h2>一言</h2>\n<p class=\"paragraph\">在新版博客的首页，我将原来固定的副标题替换为从一言api获取一句质量较高的话作为副标题，数据的获取与文章数据的获取一样，都使用 <code>getStaticProps</code>在构建时获取，所以一言的更新频率完去取决于我的更新频率。</p>\n<h2>部署</h2>\n<p class=\"paragraph\">网站的部署有以下几个选择：服务器部署，vercel，netlify。前面说过，本站是静态网站，所以如果选择服务器部署，在每次内容更新后都需要上传到服务器，浪费时间，即使使用ci，服务器由于地域原因也无法从GitHub拉取网站源码进行构建，所以率先出局。在vercel和netlify中我选择vercel，一是使用熟练，二是对Next.js有较好的支持，若是以后更改为ssr也很方便。</p>\n<h2>重构博客给我带来了什么</h2>\n<p class=\"paragraph\">Nextjs SSG网站的性能明显是要好于动态博客的，而且构建速度也比之前用Hexo的时候更快。而且自己造的轮子，自己肯定更熟悉，改起来也方便。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/refactor-my-blog-with-next#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1677875590}, {"title": "非4k显示器开启hidpi", "author": "Yume.KISEKI", "pubDate": "2023-02-11 04:29:27", "link": "https://www.monoko.jp/enable-hidpi/", "description": "macOS想要完美体验hidpi只能是换上4k及以上显示器，如果用上苹果自家的6K Pro Display X […]", "categories": ["share", "BetterDisplay", "hidpi", "macOS"], "time": 1676060967}, {"title": "Artalk公益服务 已阵亡", "author": "小N同学的博客", "pubDate": "2023-02-04 16:49:39", "link": "https://www.imcharon.com/1505/", "description": "自从4月15日以来，服务器经受了长期DDoS，目前已经彻底放弃抵抗了，没办法了。", "categories": ["往日余生", "公益服务"], "time": 1675500579}, {"title": "Pro App 教育套装", "author": "Yume.KISEKI", "pubDate": "2023-02-02 14:24:50", "link": "https://www.monoko.jp/pro-app/", "description": "一个Final Cut Pro多少钱？是1998元 一个教育优惠套装多少钱？是1298元(前几年是1543元) […]", "categories": ["share", "Apple教育优惠", "Final Cut Pro"], "time": 1675319090}, {"title": "memos纯公益代部署服务", "author": "小N同学的博客", "pubDate": "2023-02-02 03:01:14", "link": "https://www.imcharon.com/1467/", "description": "具体memos参考基于Memos实现说说和清单功能。 | Leonus 云备份，每天备份数据至onedrive […]", "categories": ["往日余生", "公益服务"], "time": 1675278074}, {"title": "一款好用的摄影包——Bellroy Venture Sling 10L", "author": "Yume.KISEKI", "pubDate": "2023-01-15 13:40:21", "link": "https://www.monoko.jp/bellroy-venture-sling-10l/", "description": "终于还是灭门了佳能，转而马上投入大法的怀抱，真香。话说都2023年了确实早已是无反的时代了，还好我的5d4和它 […]", "categories": ["share", "Bellroy"], "time": 1673761221}, {"title": "Termux安装maturin模块", "author": "Utermux博客", "pubDate": "2023-01-09 06:15:00", "link": "https://blog.utermux.dev/ut/maturin.html", "description": "Termux安装maturin模块", "categories": [], "time": 1673216100}, {"title": "Termux安装mitmproxy", "author": "Utermux博客", "pubDate": "2022-12-26 07:08:00", "link": "https://blog.utermux.dev/ut/mitmproxy.html", "description": "Termux安装mitmproxy", "categories": [], "time": 1672009680}, {"title": "解决acme.sh签发SSL证书失败", "author": "Yume.KISEKI", "pubDate": "2022-12-18 04:39:26", "link": "https://www.monoko.jp/create-ssl-with-acme-sh/", "description": "前段时间在甲骨文云成功开了台arm的机器后一直闲置没用，最近看到甲骨文云开始有回收清理白嫖机器的动作了，吓得我 […]", "categories": ["vps", "acme.sh"], "time": 1671309566}, {"title": "「古典文法」推量系の助動詞の関係性", "author": "Yume.KISEKI", "pubDate": "2022-12-04 07:34:51", "link": "https://www.monoko.jp/suiryokei-no-jyodoushi/", "description": "不难发现在助动词中有那么一堆词都带有推定的意思，我们可以称之为推量系助动词，对于这些词之间的关系总结如下图，可 […]", "categories": ["古典文法", "助动词", "推量系", "日语古文"], "time": 1670110491}, {"title": "好用的ssh客户端工具—electerm", "author": "Yume.KISEKI", "pubDate": "2022-11-30 14:13:22", "link": "https://www.monoko.jp/ssh-electerm/", "description": "前段时间偶然发现一款开源ssh客户端——electerm，三大平台全能型，多语言支持，支持sftp并且能直接编 […]", "categories": ["software", "electerm"], "time": 1669788802}, {"title": "异常低价的CleanMyMac X", "author": "Yume.KISEKI", "pubDate": "2022-11-20 02:30:00", "link": "https://www.monoko.jp/low-price-of-cleanmymac/", "description": "近期需要用到笔记本电脑一段时间，也就突然想到还有台14款的mbp正好可以拿来用段时间，系统是一代代升级到了最终 […]", "categories": ["software", "CleanMyMac X"], "time": 1668882600}, {"title": "遭遇xmrig挖矿病毒", "author": "Yume.KISEKI", "pubDate": "2022-10-21 15:39:10", "link": "https://www.monoko.jp/cryptojacking-xmrig/", "description": "起因 前段时间conoha为纪念突破50万用户大搞活动，看着优惠力度和近期的日元汇率是真的香！但太久没用con […]", "categories": ["vps", "xmrig"], "time": 1666337950}, {"title": "[通知] 我们的Termux镜像", "author": "Utermux博客", "pubDate": "2022-07-19 08:47:00", "link": "https://blog.utermux.dev/ut/mirror.html", "description": "[通知] 我们的Termux镜像", "categories": [], "time": 1658191620}, {"title": "Github Codespaces初体验", "author": "Redish101博客", "pubDate": "2022-06-19 10:52:04", "link": "https://blog.redish101.top/article/github-codespace", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610210634.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610211120.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/github-codespace\">https://blog.redish101.top/article/github-codespace</a>\n</blockquote>\n<div>\n<h1>这是什么</h1>\n<p class=\"paragraph\">在去年，GitHub上线了一个的新功能：<code>Codespaces</code>，使用Codespaces可以随时随地在浏览器里编辑、调试、运行托管在GitHub的代码。</p>\n<p class=\"paragraph\">在前几天，GitHub将此功能开放公测，任何用户都能申请使用，我，于是就有了这篇文章。</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610210634.png\" alt=\"邮件\"><h1>性能</h1>\n<h2>硬件配置</h2>\n<p class=\"paragraph\">先说性能，GitHub面对个人项目提供了一台4Cores 8RAM的设备，这性能对于普通的开发那是绰绰有余，话不多说，上bench截图：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610211120.png\" alt=\"测试结果\"><h2>网络</h2>\n<p class=\"paragraph\">配置虽好值得夸赞，但这网络之遭也十分的影响使用，在笔者试用的时候，2个小时中断线了将近十次。虽然大部分时间下编辑器的使用没有发现明显卡顿，但终端在使用时的卡顿是真的让人无法忍受。</p>\n<h2>终端相关</h2>\n<p class=\"paragraph\">Github Codespaces的终端是可以通过 <code>sudo su</code>进入root用户的，也可以直接通过 <code>sudo</code>命令来运行需要root权限的服务。</p>\n<h2>自动休眠</h2>\n<p class=\"paragraph\">这是非常重要的一个点，是我们白嫖之路的最大绊脚石，在一段时间（暂未明确结果）内如果编辑器没有活跃，codespace就会自动关闭。</p>\n<h1>写代码</h1>\n<p class=\"paragraph\">Codespaces使用了web版本的VS Code，所以说编辑体验是与直接在本地使用Code编辑并无不同，经过测试，也能完美的适配各种插件。运行时方面也无需担心，已经自动预装了docker、python、node、c/cpp等大部分语言的开发环境。</p>\n<p class=\"paragraph\">同时，如果在终端里启动程序的开发服务器时编辑器会自动发现开放的端口并映射到公网，默认是私有的，只有codespace的所有者才能访问，但是可以在图中的这个位置中更改穿透为对外公开，但是101奉劝各位早点死了用这个搭建什么服务的心吧，同GitHub一样，几乎是无法访问，在速度这方面，甚至比不上GitHub Pages。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/github-codespace#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1655607124}, {"title": "你问我答 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-05-25 14:28:40", "link": "https://www.594594.xyz/2022/05/25/xqa/", "description": "<p>一个适用hoshinobot的你问我答插件</p>", "categories": ["hoshino插件", "功能拓展"], "time": 1653460120}, {"title": "适用小白的快速搭建QQ机器人的超详细教程(可选带马娘插件)2023-10-13更新", "author": "轻音时雨的博客", "pubDate": "2022-03-05 03:10:37", "link": "https://www.594594.xyz/2022/03/05/uma_bot/", "description": "<p>适用小白的快速搭建一个QQ机器人(可选带马娘插件)</p>", "categories": ["游戏相关", "教程", "赛马娘"], "time": 1646421037}, {"title": "docsify - 一个优雅的静态文档生成器", "author": "Redish101博客", "pubDate": "2022-03-04 16:00:00", "link": "https://blog.redish101.top/article/docsify", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/docsify\">https://blog.redish101.top/article/docsify</a>\n</blockquote>\n<div>\n<h2>docsify好在哪里</h2>\n<p class=\"paragraph\">docsify相比于其他的静态文档站点生成器相比更加的简洁，易用。</p>\n<h4>Sphinx</h4>\n<p class=\"paragraph\">先拿Sphinx来说吧，Sphinx因背后有python的驱动，功能十分强大，但是rst的语法还是比较复杂的</p>\n<h4>Vuepress</h4>\n<p class=\"paragraph\">vuepress更适合大型项目的文档编写，而且维护成本高。</p>\n<h2>使用</h2>\n<h3>安装</h3>\n<p class=\"paragraph\">全局安装Docsify-cli:</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">yarn global add docsify-cli\n# 或者使用npm</code></pre>\n<h3>开始一个项目</h3>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">docsify init &lt;项目路径&gt;</code></pre>\n<h3>配置</h3>\n<p class=\"paragraph\">本文不再对配置方面进行过多的论述，可以参考<a href=\"https://docsify.js.org/#/zh-cn/configuration\" target=\"_blank\" class=\"link\">配置项 (docsify.js.org)</a></p>\n<h3>编写</h3>\n<p class=\"paragraph\">docsify会自动识别目录下的所有markdown文件，所以在docs目录新增markdown文件即可编写文档</p>\n<h4>路径问题</h4>\n<p class=\"paragraph\">这里要注意一下路径：</p>\n<p class=\"paragraph\">假设你的目录结构如下：</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">.\n└── docs\n├── README.md\n├── guide.md\n└── zh-cn\n├── README.md\n└── guide.md</code></pre>\n<p class=\"paragraph\">那么渲染后的路径就是：</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">docs/README.md        =&gt; http://domain.com\ndocs/guide.md         =&gt; http://domain.com/guide\ndocs/zh-cn/README.md  =&gt; http://domain.com/zh-cn/\ndocs/zh-cn/guide.md   =&gt; http://domain.com/zh-cn/guide</code></pre>\n<h2>部署</h2>\n<h3>Github Pages</h3>\n<p class=\"paragraph\">将Github Pages的工作目录设置到docsify所在目录。</p>\n<h3>Vercel</h3>\n<p class=\"paragraph\">选中docsify所在仓库，点击下面的deploy</p>\n<h3>服务器</h3>\n<p class=\"paragraph\">将docsify所在文件夹上传到网站目录即可</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/docsify#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1646380800}, {"title": "马娘功能插件整合版v2.0.1 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-03-04 07:36:40", "link": "https://www.594594.xyz/2022/03/04/uma_plugin/", "description": "<p>一个适用hoshinobot的马娘功能插件整合版</p>", "categories": ["hoshino插件", "赛马娘"], "time": 1646350600}, {"title": "赛马娘模拟抽卡 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-02-05 03:43:40", "link": "https://www.594594.xyz/2022/02/05/uma_gacha_for_hoshino/", "description": "<p>一个适用hoshinobot的赛马娘模拟抽卡插件</p>", "categories": ["hoshino插件", "赛马娘"], "time": 1644003820}, {"title": "ZeroTier One搭建MOON服务器", "author": "轻音时雨的博客", "pubDate": "2022-02-03 03:30:40", "link": "https://www.594594.xyz/2022/02/03/moon_for_zerotier/", "description": "<p>完美解决Tabletop等和好友P2P联机延迟高的解决办法及相关踩坑</p>", "categories": ["游戏相关"], "time": 1643830240}, {"title": "Windows实用小工具教程", "author": "Utermux博客", "pubDate": "2022-01-23 07:55:00", "link": "https://blog.utermux.dev/win/Windows-utilities.html", "description": "Windows实用小工具教程", "categories": [], "time": 1642895700}, {"title": "UTermux/ZeroTermux/TermuxWatch下载链接", "author": "Utermux博客", "pubDate": "2021-12-26 06:53:00", "link": "https://blog.utermux.dev/ut/download.html", "description": "UTermux/ZeroTermux/TermuxWatch下载链接", "categories": [], "time": 1640472780}, {"title": "早安晚安 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:16:12", "link": "https://www.594594.xyz/2021/10/24/good_morning_for_hoshino/", "description": "<p>一个适用hoshinobot的 早安晚安 插件</p>", "categories": ["hoshino插件", "pcr"], "time": 1635016572}, {"title": "pcr签到黄历 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:09:12", "link": "https://www.594594.xyz/2021/10/24/pcr_almanac_for_hoshino/", "description": "<p>一个适用hoshinobot的 pcr签到黄历 插件</p>", "categories": ["hoshino插件", "pcr"], "time": 1635016152}, {"title": "mc数据查询监控 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:00:12", "link": "https://www.594594.xyz/2021/10/24/mc_status_for_hoshino/", "description": "<p>一个适用hoshinobot的 mc数据查询监控 插件</p>", "categories": ["hoshino插件", "mc"], "time": 1635015612}, {"title": "github仓库更新提醒 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-08-23 04:00:12", "link": "https://www.594594.xyz/2021/08/23/github_reminder_for_hoshino/", "description": "<p>一个适用hoshinobot的 github仓库更新提醒 插件</p>", "categories": ["hoshino插件", "github"], "time": 1629662412}, {"title": "职场浮生纪修改器发布", "author": "小N同学的博客", "pubDate": "2021-08-08 17:59:53", "link": "https://www.imcharon.com/54/", "description": "先打开游戏，然后使用管理员身份启动修改器即可。 之前能改很多东西的，现在为什么只能加钱了。 -因为很多基址当时 […]", "categories": ["往日余生", "教程", "精选", "修改器", "职场浮生纪"], "time": 1628416793}]