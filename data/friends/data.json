[{"title": "绕过安全浏览器的监管", "author": "Chenxi", "pubDate": "2025-06-08 03:27:40", "link": "https://chenxi.in/post/rgaqllqdjg/", "description": "<p>Lockdown Browser（LDB） / Safe Exam Browser（SEB）等等诸如此类的安全浏览器一般用于考试，这类程序启动后会全屏锁定，不能切换到除该程序以外的窗口，会检测各类进程，检查当前硬件（如外接储存设备，多显示器，是否虚拟机），如不符合要求则不能启动。<br>\n博主尝试过，事先在机器上运行用msfvenon生成的vnc远程控制木马并不会触发检测，但在该类程序启动后进入全屏锁定模式后，虽然能控制鼠标键盘，但远程控制只看到全屏黑屏</p>", "categories": [], "time": 1749324460}, {"title": "Lucky-canvas 抽奖插件折腾记", "author": "林木木的博客", "pubDate": "2025-05-31 12:02:58", "link": "https://immmmm.com/lucky-everday/", "description": "\n<p>基于 <a href=\"https://github.com/buuing/lucky-canvas\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">「Lucky-canvas」</a> 抽奖插件，借助 <a href=\"https://www.trae.ai/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">字节跳动 trae</a> 做了个大转盘，全屏显示、替换背景、概率设置、一键导入、边框修改等能想到的和需要的功能都已实现，效果远超预期。</p>\n<p>体验地址：<a href=\"https://immmmm.com/dzp/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://immmmm.com/dzp/</a></p>\n<h3>使用手册 📚</h3>\n<p>1.打开网址， 右下角“全屏按钮”，右上角是“设置入口”。点击中间开始转动，结束时会弹出中奖内容，并伴有撒花。</p>\n<p>2.右上角点击进入“设置”。首次打开，点击安装字体“Aa 年度最可爱”。</p>\n<p>3.设置分层两列，左侧显示的奖项名称、中奖概率，可以直接修改或删除。说明：某一奖项的数值是这一项中奖率的“分子”，所有数值总和是“分母”。如“棒棒糖”的中奖率设置的 15，则中奖率是</p>\n<p><code>15/（10+10+……+15+10+10+5）</code></p>\n<p>4.左侧奖项列表下方是 4 个按钮。顾名思义，第 1、2、4 项试试就知。说明一下第 3 项“上传配置”，采用了“上传 txt 文件，一行一条内容”的形式，一键导入。如：本地新建了以下内容「姓氏+空格+中奖数值」</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-js\" data-lang=\"js\"><span><span><span>张</span> <span>1</span>\n</span></span><span><span><span>王</span> <span>1</span>\n</span></span><span><span><span>李</span> <span>1</span>\n</span></span><span><span><span>田</span> <span>1</span>\n</span></span><span><span><span>柳</span> <span>1</span>\n</span></span><span><span><span>石</span> <span>1</span>\n</span></span></code></pre></div>\n<p>点击“上传配置”，选择 txt 文件，导入即可。所以，如果要换电脑快速导入，只要编辑保存好自己的“奖项.txt”到别的电脑，导入即可。</p>\n<p>5.配置右侧，点击可更改转盘配色、指针、内外层转盘背景。</p>\n<p><em>随心搭配，换着玩儿～</em></p>\n<h3>致谢</h3>\n<p><a href=\"https://taoshu.in/web/lucky-canvas.html#%E8%80%81%E8%99%8E%E6%9C%BA\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">抽奖组件 lucky-canvas 素材大全</a></p>\n<p>🎉</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1748664178}, {"title": "沉迷“吉卜力”中……", "author": "林木木的博客", "pubDate": "2025-04-11 23:59:32", "link": "https://immmmm.com/ghiblio-enjoy/", "description": "\n<p>苦于官方网络、数量、版权等限制，4o 生图只能眼巴巴看别人分享。</p>\n<p>昨天看到 v2ex 上有牛人搞了套壳，免费 3 张，一试，效果极佳，一看定价，立马大会员支持。</p>\n<h3>邀请链接</h3>\n<p>当前价位（250412）：¥9.9（共20次）、¥19.9（共60次）、¥49.9（共200次）。</p>\n<p>注：开发大大说，成本太高，涨价在即。我的邀请链接（你付费后，我会得到 10 张额度。）：</p>\n<p><a href=\"https://ghiblio.art/?utm_source=P9ZKx72A8v4z\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://ghiblio.art/?utm_source=P9ZKx72A8v4z</a></p>\n<h3>沉溺其中</h3>\n<p>生图小体验：有人，多人，神情或动作丰富；照片本身颜色、层次丰富。</p>\n<p>小朋友自带奶萌奶萌，满满温情爆棚；小姐姐小哥哥立马帅气、魅力十足；中年嘛，装个可爱也不是不行。老年，有种返老还童之感。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-2.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-14.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-4.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-8.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-3.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-13.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-5.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-11.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-6.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-9.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-10.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/04/gpl-12.webp\" alt=\"\"></p>\n", "categories": ["%E6%97%A5%E5%B8%B8"], "time": 1744387172}, {"title": "懒到现在才安上肥羊 allinone", "author": "林木木的博客", "pubDate": "2025-03-08 08:27:31", "link": "https://immmmm.com/iptv-fixed/", "description": "\n<p>IPTV 直播源年前已废，包括用了很久的 ip6 的源。</p>\n<p>这不，偶尔想起，饭点来个背景音，缺无法播放，一点小难受。</p>\n<p>开干，怎么干其实也知道个大概。</p>\n<p>以下内容，流水记录。</p>\n<h3>群晖，终端 SSH 进后台拉取 Docker</h3>\n<pre tabindex=\"0\"><code>ssh myid@192.168.0.1 -p 22\nsudo -i\n</code></pre>\n<p>群晖里的注册表已废，加上一通测试可用的镜像代理 <code>image.cloudlayer.icu/</code></p>\n<p>拉下肥羊 allinone 镜像 <code>youshandefeiyang/allinone:latest</code></p>\n<pre tabindex=\"0\"><code>docker pull image.cloudlayer.icu/youshandefeiyang/allinone:latest\n</code></pre>\n<p>访问 <a href=\"https://imgtool.v1.mk/allinone.html\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://imgtool.v1.mk/allinone.html</a></p>\n<p>生成密钥，按照提示把这个密钥丢给电报机器人获取 <code>userid</code> <code>token</code> ，填回网页，获取部署命令，如：</p>\n<p>记得把生成的部署命令里的 <code>youshandefeiyang/allinone</code> 前加上镜像代理地址。</p>\n<pre tabindex=\"0\"><code>docker run -d --restart=always --net=host --privileged=true --name allinone image.cloudlayer.icu/youshandefeiyang/allinone -tv=true -aesKey=123123 -userid=123123 -token=123123123\n</code></pre>\n<h3>路由器添加端口 35455 转发，放行</h3>\n<p>略</p>\n<h3>Apple TV 添加直播源</h3>\n<p>个人使用的是 「IPTV」 这个 APP</p>\n<pre tabindex=\"0\"><code># IPTV聚合\nhttp://IP:35455/tv.m3u\n# 虎牙一起看\nhttp://IP:35455/huyayqk.m3u\n# BiliBili 生活\nhttp://IP:35455/bililive.m3u\n# 斗鱼一起看\nhttp://IP:35455/douyuyqk.m3u\n# YY轮播\nhttp://IP:35455/yylunbo.m3u\n</code></pre>\n", "categories": ["%E6%97%A5%E5%B8%B8"], "time": 1741393651}, {"title": "GN(Generate Ninja) 快速入门指南", "author": "Redish101博客", "pubDate": "2025-02-16 02:18:36", "link": "https://blog.redish101.top/article/gn-quick-start-guide", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/gn-quick-start-guide\">https://blog.redish101.top/article/gn-quick-start-guide</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">GN(Generate Ninja)是 Google 开发的元构建系统（类似 cmake），用以从配置文件生成 <code>build.ninja</code>文件。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">gn 在 Chromium、Fuchsia 以及 openharmony 等项目中均有使用，但是似乎远远比不上 cmake 使用的广泛，互联网上的资料也较少。这篇文章将通过使用 gn 构建一个简单的基于 glfw + glad 的 cpp 程序来介绍 gn 的使用。</p>\n<h2>0. 安装</h2>\n<h3>ninja</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">由于 gn 最终生成的是 ninja 的构建文件，所以需要安装 ninja。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">linux 下可以通过<a href=\"https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">包管理器</a></p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\"># Arch\npacman -S ninja\n\n# Ubuntu/Debian\napt-get install ninja-build\n\n# Fedora\ndnf install ninja-build</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">或<a href=\"https://github.com/ninja-build/ninja/releases\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">可执行文件</a>安装。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">macOS 下可以通过<a href=\"https://brew.sh/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">Homebrew</a>：</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">brew install ninja</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">也可以通过<a href=\"https://github.com/ninja-build/ninja/releases\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">可执行文件</a>安装。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">windows 下可以通过使用winget：</p>\n<pre class=\"language-powershell lang-powershell\"><code class=\"language-powershell lang-powershell\">winget install Ninja-build.Ninja</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">或通过<a href=\"https://github.com/ninja-build/ninja/releases\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">可执行文件</a>安装。</p>\n<h3>gn</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">gn 可以通过包管理器安装，如在 ubuntu 下：</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">sudo apt install generate-ninja</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在 arch 下：</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">sudo pacman -S gn</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">或通过编译安装：</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">git clone https://gn.googlesource.com/gn\ncd gn\npython build/gen.py # --allow-warning if you want to build with warnings.\nninja -C out</code></pre>\n<h3>编辑器插件</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">如果想要有更顺畅的编写体验，可以安装gn的编辑器插件以使编译器支持gn的语法高亮、自动补全等功能。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在 vscode 中，可以安装插件<a href=\"https://marketplace.visualstudio.com/items?itemName=msedge-dev.gnls\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">GN Language Server</a>。</p>\n<h2>1. 创建工程及配置编译工具链</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">首先在项目根目录下创建一个名为 <code>.gn</code>的文件，用于声明工作区的根目录，并引入构建配置。</p>\n<pre class=\"\"><code class=\"\"># .gn\nbuildconfig = \"//build/BUILDCONFIG.gn\"</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">gn 中可以通过//描述路径，//表示工作区根目录</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">gn <strong>并没有</strong> 像 cmake 默认配置好了编译工具链，需要自己进行配置。可以参考gn源码仓库示例项目的工具链配置。</p>\n<pre class=\"language-gn lang-gn\"><code class=\"language-gn lang-gn\"># build/toolchain/BUILD.gn\n\ntoolchain(\"gcc\") {\n  tool(\"cc\") {\n    depfile = \"{{output}}.d\"\n    command = \"gcc -MMD -MF $depfile {{defines}} {{include_dirs}} {{cflags}} {{cflags_c}} -c {{source}} -o {{output}}\"\n    depsformat = \"gcc\"\n    description = \"CC {{output}}\"\n    outputs =\n        [ \"{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o\" ]\n  }\n  tool(\"cxx\") {\n    depfile = \"{{output}}.d\"\n    command = \"g++ -MMD -MF $depfile {{defines}} {{include_dirs}} {{cflags}} {{cflags_cc}} -c {{source}} -o {{output}}\"\n    depsformat = \"gcc\"\n    description = \"CXX {{output}}\"\n    outputs =\n        [ \"{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o\" ]\n  }\n  tool(\"alink\") {\n    command = \"ar rcs {{output}} {{inputs}}\"\n    description = \"AR {{target_output_name}}{{output_extension}}\"\n    outputs =\n        [ \"{{target_out_dir}}/{{target_output_name}}{{output_extension}}\" ]\n    default_output_extension = \".a\"\n    output_prefix = \"lib\"\n  }\n  tool(\"solink\") {\n    soname = \"{{target_output_name}}{{output_extension}}\"  # e.g. \"libfoo.so\".\n    sofile = \"{{output_dir}}/$soname\"\n    rspfile = soname + \".rsp\"\n    if (is_mac) {\n      os_specific_option = \"-install_name @executable_path/$sofile\"\n      rspfile_content = \"{{inputs}} {{solibs}} {{libs}}\"\n    } else {\n      os_specific_option = \"-Wl,-soname=$soname\"\n      rspfile_content = \"-Wl,--whole-archive {{inputs}} {{solibs}} -Wl,--no-whole-archive {{libs}}\"\n    }\n    command = \"g++ -shared {{ldflags}} -o $sofile $os_specific_option @$rspfile\"\n    description = \"SOLINK $soname\"\n    # Use this for {{output_extension}} expansions unless a target manually\n    # overrides it (in which case {{output_extension}} will be what the target\n    # specifies).\n    default_output_extension = \".so\"\n    # Use this for {{output_dir}} expansions unless a target manually overrides\n    # it (in which case {{output_dir}} will be what the target specifies).\n    default_output_dir = \"{{root_out_dir}}\"\n    outputs = [ sofile ]\n    link_output = sofile\n    depend_output = sofile\n    output_prefix = \"lib\"\n  }\n  tool(\"link\") {\n    outfile = \"{{target_output_name}}{{output_extension}}\"\n    rspfile = \"$outfile.rsp\"\n    if (is_mac) {\n      command = \"g++ {{ldflags}} -o $outfile @$rspfile {{solibs}} {{libs}}\"\n    } else {\n      command = \"g++ {{ldflags}} -o $outfile -Wl,--start-group @$rspfile {{solibs}} -Wl,--end-group {{libs}}\"\n    }\n    description = \"LINK $outfile\"\n    default_output_dir = \"{{root_out_dir}}\"\n    rspfile_content = \"{{inputs}}\"\n    outputs = [ outfile ]\n  }\n  tool(\"stamp\") {\n    command = \"touch {{output}}\"\n    description = \"STAMP {{output}}\"\n  }\n  tool(\"copy\") {\n    command = \"cp -af {{source}} {{output}}\"\n    description = \"COPY {{source}} {{output}}\"\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">如果需要使用clang：</p>\n<pre class=\"\"><code class=\"\"># build/toolchain/BUILD.gn\n\ntoolchain(\"clang\") {\n  tool(\"cc\") {\n    depfile = \"{{output}}.d\"\n    command = \"clang -MMD -MF $depfile {{defines}} {{include_dirs}} {{cflags}} {{cflags_c}} -c {{source}} -o {{output}}\"\n    depsformat = \"gcc\"\n    description = \"CC {{output}}\"\n    outputs =\n        [ \"{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o\" ]\n  }\n  tool(\"cxx\") {\n    depfile = \"{{output}}.d\"\n    command = \"clang++ -MMD -MF $depfile {{defines}} {{include_dirs}} {{cflags}} {{cflags_cc}} -c {{source}} -o {{output}}\"\n    depsformat = \"gcc\"\n    description = \"CXX {{output}}\"\n    outputs =\n        [ \"{{source_out_dir}}/{{target_output_name}}.{{source_name_part}}.o\" ]\n  }\n  tool(\"alink\") {\n    command = \"ar rcs {{output}} {{inputs}}\"\n    description = \"AR {{target_output_name}}{{output_extension}}\"\n    outputs =\n        [ \"{{target_out_dir}}/{{target_output_name}}{{output_extension}}\" ]\n    default_output_extension = \".a\"\n    output_prefix = \"lib\"\n  }\n  tool(\"solink\") {\n    soname = \"{{target_output_name}}{{output_extension}}\"  # e.g. \"libfoo.so\"\n    sofile = \"{{output_dir}}/$soname\"\n    rspfile = soname + \".rsp\"\n    if (is_mac) {\n      os_specific_option = \"-install_name @executable_path/$sofile\"\n      rspfile_content = \"{{inputs}} {{solibs}} {{libs}}\"\n    } else {\n      os_specific_option = \"-Wl,-soname=$soname\"\n      rspfile_content = \"-Wl,--whole-archive {{inputs}} {{solibs}} -Wl,--no-whole-archive {{libs}}\"\n    }\n    command = \"clang++ -shared {{ldflags}} -o $sofile $os_specific_option @$rspfile\"\n    description = \"SOLINK $soname\"\n    default_output_extension = \".so\"\n    default_output_dir = \"{{root_out_dir}}\"\n    outputs = [ sofile ]\n    link_output = sofile\n    depend_output = sofile\n    output_prefix = \"lib\"\n  }\n  tool(\"link\") {\n    outfile = \"{{target_output_name}}{{output_extension}}\"\n    rspfile = \"$outfile.rsp\"\n    if (is_mac) {\n      command = \"clang++ {{ldflags}} -o $outfile @$rspfile {{solibs}} {{libs}}\"\n    } else {\n      command = \"clang++ {{ldflags}} -o $outfile -Wl,--start-group @$rspfile {{solibs}} -Wl,--end-group {{libs}}\"\n    }\n    description = \"LINK $outfile\"\n    default_output_dir = \"{{root_out_dir}}\"\n    rspfile_content = \"{{inputs}}\"\n    outputs = [ outfile ]\n  }\n  tool(\"stamp\") {\n    command = \"touch {{output}}\"\n    description = \"STAMP {{output}}\"\n  }\n  tool(\"copy\") {\n    command = \"cp -af {{source}} {{output}}\"\n    description = \"COPY {{source}} {{output}}\"\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">然后在构建配置中指定工具链：</p>\n<pre class=\"\"><code class=\"\">if (target_os == \"\") {\n  target_os = host_os\n}\nif (target_cpu == \"\") {\n  target_cpu = host_cpu\n}\nif (current_cpu == \"\") {\n  current_cpu = target_cpu\n}\nif (current_os == \"\") {\n  current_os = target_os\n}\nis_linux = host_os == \"linux\" &amp;&amp; current_os == \"linux\" &amp;&amp; target_os == \"linux\"\nis_mac = host_os == \"mac\" &amp;&amp; current_os == \"mac\" &amp;&amp; target_os == \"mac\"\n# All binary targets will get this list of configs by default.\n_shared_binary_target_configs = [ \"//build:compiler_defaults\" ]\n# Apply that default list to the binary target types.\nset_defaults(\"executable\") {\n  configs = _shared_binary_target_configs\n  # Executables get this additional configuration.\n  configs += [ \"//build:executable_ldconfig\" ]\n}\nset_defaults(\"static_library\") {\n  configs = _shared_binary_target_configs\n}\nset_defaults(\"shared_library\") {\n  configs = _shared_binary_target_configs\n}\nset_defaults(\"source_set\") {\n  configs = _shared_binary_target_configs\n}\nset_default_toolchain(\"//build/toolchain:clang\")\n# 若使用gcc\nset_default_toolchain(\"//build/toolchain:gcc\")</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">上方的工具链配置需要在 <code>build/BUILD.gn</code>中声明一些配置：</p>\n<pre class=\"\"><code class=\"\">config(\"compiler_defaults\") {\n  if (current_os == \"linux\") {\n    cflags = [\n      \"-fPIC\",\n      \"-pthread\",\n    ]\n  }\n}\nconfig(\"executable_ldconfig\") {\n  if (!is_mac) {\n    ldflags = [\n      \"-Wl,-rpath=\\$ORIGIN/\",\n      \"-Wl,-rpath-link=\",\n    ]\n  }\n}</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在gn中，<code>config</code>是一个用于定义配置的构建工具。它允许你定义一些变量，这些变量和常量可以在构建过程中被引用。</p></blockquote>\n<h2>2. 声明构建配置</h2>\n<h3>引入 glad</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">将下载的glad项目放入 <code>thirdparty/glad</code>下，书写构建配置。</p>\n<pre class=\"\"><code class=\"\"># thirdparty/glfw/BUILD.gn\n\nconfig(\"glad_inner_headers\") {\n    include_dirs = [\n        \"include\",\n    ]\n}\n\nstatic_library(\"glad\") {\n    sources = [\n        \"src/glad.c\",\n    ]\n    include_dirs = [\n        \"include\",\n    ]\n    public = [\n        \"include/glad/glad.h\",\n        \"include/KHR/khrplatform.h\"\n    ]\n    public_configs = [\n        \":glad_inner_headers\",\n    ]\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">构建配置中，<code>config</code>用于定义一些变量，这些变量可以在构建过程中被引用。<code>static_library</code>用于声明一个静态库，静态库是一个包含多个源文件的库，这些源文件被编译成静态链接库。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><code>static_library</code>中，<code>sources</code>用于声明静态库的源文件，<code>include_dirs</code>用于声明静态库的头文件目录，<code>public</code>用于声明静态库的头文件，<code>public_configs</code>中的字段会应用到所有依赖于此目标的目标。</p>\n<h3>引入 glfw</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">类似的，可以为 glfw 书写配置文件：</p>\n<pre class=\"language-gn lang-gn\"><code class=\"language-gn lang-gn\"># thirdparty/glfw/BUILD.gn\n# 修改自 ohos/third_party/glfw/BUILD.gn\n\n# Copyright (c) 2021-2024 Huawei Device Co., Ltd.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nconfig(\"glfw_inner_headers\") {\n  include_dirs = [ \"include\" ]\n}\n\nconfig(\"glfw_config_mac\") {\n  cflags = [ \"-Wno-sign-compare\" ]\n}\n\nstatic_library(\"glfw\") {\n  defines = [ \"PREVIEW\" ]\n  include_dirs = [ \"src\" ]\n  public = [\n    \"include/GLFW/glfw3.h\",\n    \"include/GLFW/glfw3native.h\",\n  ]\n\n  sources = [\n    \"src/context.c\",\n    \"src/init.c\",\n    \"src/input.c\",\n    \"src/monitor.c\",\n    \"src/null_init.c\",\n    \"src/null_joystick.c\",\n    \"src/null_joystick.h\",\n    \"src/null_monitor.c\",\n    \"src/null_platform.h\",\n    \"src/null_window.c\",\n    \"src/osmesa_context.c\",\n    \"src/platform.c\",\n    \"src/vulkan.c\",\n    \"src/window.c\",\n  ]\n\n  public_configs = [ \":glfw_inner_headers\" ]\n\n  if (current_os == \"mingw\") {\n    sources += [\n      \"src/egl_context.c\",\n      \"src/egl_context.h\",\n      \"src/wgl_context.c\",\n      \"src/wgl_context.h\",\n      \"src/win32_init.c\",\n      \"src/win32_joystick.c\",\n      \"src/win32_joystick.h\",\n      \"src/win32_module.c\",\n      \"src/win32_monitor.c\",\n      \"src/win32_platform.h\",\n      \"src/win32_thread.c\",\n      \"src/win32_thread.h\",\n      \"src/win32_time.c\",\n      \"src/win32_time.h\",\n      \"src/win32_window.c\",\n    ]\n\n    defines += [ \"_GLFW_WIN32\" ]\n\n    libs = [\n      \"gdi32\",\n      \"opengl32\",\n    ]\n  }\n  if (current_os == \"mac\") {\n    sources += [\n      \"src/cocoa_init.m\",\n      \"src/cocoa_joystick.h\",\n      \"src/cocoa_joystick.m\",\n      \"src/cocoa_monitor.m\",\n      \"src/cocoa_platform.h\",\n      \"src/cocoa_time.c\",\n      \"src/cocoa_time.h\",\n      \"src/cocoa_window.m\",\n      \"src/egl_context.c\",\n      \"src/egl_context.h\",\n      \"src/nsgl_context.m\",\n      \"src/posix_module.c\",\n      \"src/posix_poll.c\",\n      \"src/posix_poll.h\",\n      \"src/posix_thread.c\",\n      \"src/posix_time.c\",\n      \"src/posix_time.h\",\n    ]\n    include_dirs += [ \"deps\" ]\n    if (defined(enable_gn_2021)) {\n      frameworks = [\n        \"Cocoa.framework\",\n        \"IOKit.framework\",\n        \"CoreFoundation.framework\",\n        \"CoreVideo.framework\",\n        \"QuartzCore.framework\",\n      ]\n    } else {\n      libs = [\n        \"Cocoa.framework\",\n        \"IOKit.framework\",\n        \"CoreFoundation.framework\",\n        \"CoreVideo.framework\",\n        \"QuartzCore.framework\",\n      ]\n    }\n\n    cflags = [\n      \"-Wno-deprecated-declarations\",\n      \"-Wno-objc-multiple-method-names\",\n      \"-DNS_FORMAT_ARGUMENT(A)=\",\n    ]\n    public_configs += [ \":glfw_config_mac\" ]\n    defines += [ \"_GLFW_COCOA\" ]\n  }\n  if (current_os == \"linux\") {\n    sources += [\n      \"src/egl_context.c\",\n      \"src/glx_context.c\",\n      \"src/linux_joystick.c\",\n      \"src/linux_joystick.h\",\n      \"src/posix_module.c\",\n      \"src/posix_poll.c\",\n      \"src/posix_poll.h\",\n      \"src/posix_thread.c\",\n      \"src/posix_time.c\",\n      \"src/posix_time.h\",\n      \"src/x11_init.c\",\n      \"src/x11_monitor.c\",\n      \"src/x11_platform.h\",\n      \"src/x11_window.c\",\n      \"src/xkb_unicode.c\",\n      \"src/xkb_unicode.h\",\n    ]\n    cflags_c = [\n      \"-Wno-sign-compare\",\n      \"-Wno-missing-field-initializers\",\n    ]\n    libs = [\n      \"rt\",\n      \"dl\",\n      \"X11\",\n      \"Xcursor\",\n      \"Xinerama\",\n      \"Xrandr\",\n    ]\n    defines += [ \"_GLFW_X11\" ]\n    defines += [ \"USE_DUMMPY_XINPUT2\" ]\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">gn 中可以通过 <code>if</code>实现针对不同目标平台的条件编译。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在 gn 中可以通过 <code>declare_args</code>声明构建参数，如：</p>\n<pre class=\"\"><code class=\"\"># build/args.gni\n\ndeclare_args() {\n    is_dev = false\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在 <code>BUILD.gn</code>中引入参数：</p>\n<pre class=\"\"><code class=\"\">import(\"//build/args.gni\")</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在目标配置中根据不同参数设置不同的 <code>defines</code>参数：</p>\n<pre class=\"\"><code class=\"\">import(\"//build/args.gni\")\n\nexecutable(\"hello\") {\n    source = [ \"src/hello.cpp\" ]\n\n    defines = []\n\n    if (is_dev) {\n        defines += [ \"IS_DEV\" ]\n    }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">可以使程序在不同配置下进行不同的操作：</p>\n<pre class=\"language-cpp lang-cpp\"><code class=\"language-cpp lang-cpp\">#include &lt;iostream&gt;\n\nint main(int argc, char** argv)\n{\n    #ifdef IS_DEV\n    std::cout &lt;&lt; \"dev mode\" &lt;&lt; std::endl;\n    #endif\n\n    return 0;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在生成构建文件时，可以通过 <code>gn gen --args=\"is_dev=true\"</code>指定参数。</p>\n<h3>可执行文件</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在这篇文章中，我们使用一个简单的基于 glfw + glad 的图形应用程序来演示如何使用 gn 构建。</p>\n<pre class=\"\"><code class=\"\"># app/BUILD.gn\n\nexecutable(\"app\") {\n    sources = [\n        \"src/main.cpp\",\n    ]\n    deps = [\n        \"//thirdparty/glad:glad\",\n        \"//thirdparty/glfw:glfw\"\n    ]\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">通过 <code>executable</code>定义可执行文件目标，通过 <code>deps</code>指定依赖。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><code>//</code>指向项目的根目录，也就是 <code>.gn</code>文件的位置，<code>:</code>后是目标名称。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">完成上述配置后，可以在根目录 <code>BUILD.gn</code>定义一个 <code>group(\"all\")</code>目标作为默认的编译目标：</p>\n<pre class=\"\"><code class=\"\">group(\"all\") {\n    deps = [\n        \"//app:app\"\n    ]\n}</code></pre>\n<h2>3. 构建</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">构建过程分为两个步骤：</p>\n<ol start=\"1\">\n<li>使用gn生成ninja.build文件</li>\n<li>使用ninja编译生成可执行文件</li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">通过 <code>gn gen out</code>可以在 <code>out</code>下生成 <code>build.ninja</code>文件，通过 <code>ninja -C out</code>编译生成可执行文件。也可以通过 <code>ninja -C out -t &lt;target&gt;</code>指定编译目标。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">对于本例子，执行 <code>ninja -C out</code>后将会在 <code>out</code>下生成可执行文件 <code>app</code>。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">执行 <code>gn args out</code>会弹出一个文本编辑器，用以指定编译参数。也可以通过 <code>gn gen out --args=\"&lt;args&gt;\"</code>指定编译参数。通过 <code>gn args --list</code>可以查看所有的编译参数。</p>\n<h2>总结</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">由上面的例子可以看出，gn相比于cmake，从零开始新建项目较为繁琐，而且并没有cmake的应用广泛，对于本文的例子如果引入glfw，需要重新编写gn文件，对于个人开发者以及小型项目来说可能并不方便，所以gn的应用场景更多是规模较大的项目中，更为清晰的描述构建。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本文的最终源码已经托管在<a href=\"https://github.com/Redish101/gn-example\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">GitHub</a></p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/gn-quick-start-guide#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1739643516}, {"title": "港珠澳大家庭游，难得", "author": "林木木的博客", "pubDate": "2025-02-06 04:04:45", "link": "https://immmmm.com/hkzm-2025/", "description": "\n<p>年前开始计划港珠澳去兜一圈， 3 户人家共 10 人，一开始还打算全部我自己一个人把机票、酒店、景点门票等都搞定，尝试后发现太耗时耗力，特别是澳门、香港，最终还是找了家本地旅行社委托定制自由行，六天五晚，珠海、澳门、香港，初三飞去珠海，初八从深圳飞回。</p>\n<p>报价是 7.8k 一人，快速一算，扣除来回机票 3k+ ，5个晚上酒店均价 1K 情况下 2.5k+，长隆海洋和大马戏 0.8k ，减去之后低于 1.5k 一人。另外整个行程总计有 8 次专车接送，机场酒店，酒店关口，减去后大约每个人赚 0.5k，整个团赚 5k 不到，应该的。</p>\n<p>购物或公共交通，支付宝或微信都行，所以没有换币。</p>\n<h3>Day 1 情侣中路，半途而废</h3>\n<p>直飞到珠海，入住拱北口岸附近酒店（ <del>希尔顿欢朋酒店，差评</del> ），中餐酒店斜对角“小清迈大排档”好评，好吃又便宜，打卡还送可乐喝。</p>\n<p>下午走“情侣中路”海岸线，计划从“爱情邮局”一直步行到“日月贝”，实际“邮局”到“渔女”这一个弯已经累趴，海岸线风景是不错，但没啥变化.</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-z3.webp\" alt=\"\"></p>\n<p>而且：爱情邮局，一个灯塔，仅此而已；珠海渔女，一座石像，仅此而已；城市阳台，一个建筑，仅此而已。</p>\n<p>改为横穿沙滩公园，公交到“日月贝”对面的“扬名广场”解决了晚餐，计划饭后徒步过桥到“日月贝”，不料下起小雨，果断打的回酒店。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-z6.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-z2.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-z4.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-z7.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-z5.webp\" alt=\"\"></p>\n<h3>Day 2 海洋马戏，嗨足整天</h3>\n<h4>海洋王国</h4>\n<p>人从众，游客多到已提早半小时开园，径直看了看“鲸鲨馆”（地标下）十几分种出来，被告知隔壁（以为在一起呢！）的“白鲸剧场”已满，要等下一场。</p>\n<p>游玩路线看着剧场演出时间表来安排，而且至少要提早半小时以上排队入场，一场 5k 多人，场场满员。</p>\n<p>园内餐饮点个赞，可供选择较多，口味、价格、量都比较良心。</p>\n<p>海洋王国的几个剧场个人体验排序：</p>\n<ol>\n<li>海豚剧场：目不暇接，海豚速度、技巧超燃。</li>\n<li>白鲸剧场：排队太久，表演内容太划水，总共 20 几分钟的表演，竟然还让看了好几分钟的日常饲养视频。</li>\n<li>5D电影剧场：排队太久。</li>\n<li>海狮剧场：困。</li>\n</ol>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl1.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl2.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl12.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl8.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl11.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl9.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl6.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl4.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl10.webp\" alt=\"\"></p>\n<h4>大马戏</h4>\n<p>相比 3 年前广州长隆，珠海的更现代化，互动体验也更佳！90 分钟表演，眨眼而过，五星推荐。</p>\n<p>没必要买 VIP，普通票早点排队，选择靠近中间环线过道最佳。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-cl3.webp\" alt=\"\"></p>\n<h3>Day 3&amp;4 澳门两日，浮光掠影</h3>\n\n\n\n\n\n    \n\n\n\n\n    \n    <div class=\"db-card\">\n        <div class=\"db-card-subject\">\n            <div class=\"db-card-post\"><img loading=\"lazy\" decoding=\"async\" referrerpolicy=\"no-referrer\" src=\"https://db.immmmm.com/movie/36851327.jpg\"></div>\n            <div class=\"db-card-content\">\n                <div class=\"db-card-title\"><a href=\"https://movie.douban.com/subject/36851327/\" class=\"cute\" target=\"_blank\" rel=\"noreferrer\">灿烂的风和海</a></div>\n                <div class=\"rating\">\n<span class=\"allstardark\"><span class=\"allstarlight\"></span></span><span class=\"rating_nums\">7.7</span>\n</div>\n                <div class=\"db-card-abstract\">2024 / 中国大陆 / 剧情 / 李漠 徐维宽 / 钟楚曦 孙阳</div>\n            </div>\n            <div class=\"db-card-cate\">movie</div>\n        </div>\n    </div>\n\n\n\n<p>出发前无意中刷到《灿烂的风和海》这部剧，当做澳门风光片，挺符合剧名。也因此，留了 2 天在澳门。</p>\n<p>入住“骏龙酒店”，下午氹仔岛深度游，官也街、威尼斯、皇宫等，晚上再次坐轻轨岛赏夜景，到永利皇宫看喷泉免费坐缆车。</p>\n<p>第二天，赶早到“大三巴”打卡，感慨市政府竟然随便逛，还卖精致平价的纪念品。然后沿着非遗路线，暴走之，感受澳门本土人情风俗，中餐在“下环街市”（菜场）熟食中心搞定。</p>\n<p>下午单独带娃去了“大赛车博物馆”，顺便路过渔人码头，这片异常冷清。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc9.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc11.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc12.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc10.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc8.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc2.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc6.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc15.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc3.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-mc4.webp\" alt=\"\"></p>\n<h3>Day 5&amp;6 香港日夜，上山过海</h3>\n<p>入住“九龙海逸君绰酒店”，性价比之王，在香港住到了本次行程就满意的酒店。本来还觉得不在地铁旁会麻烦，后来发现边上即“红磡轮渡码头”可乘坐“香港水上的士”，虽然班次有点少间隔 40 分钟一班，但能直接到“中环”码头，不错不错。</p>\n<p>由于第二天一早就退房，过关去深圳机场回家。所以，到了“中环”后，乘坐 15 路公交车直上“太平山”，俯瞰整个港湾。没有选择“缆车”，还是因为往返都要排队半小时以上。</p>\n<p>下山后地铁到“坚尼地城”，C 出口左拐，看到了传说中的网红篮球场打卡机位，不要笑，加入他们😄</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk12.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk9.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk11.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk21.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk19.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk1.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk23.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk22.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk15.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk16.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk17.webp\" alt=\"\"></p>\n<p>傍晚“叮叮车”返回中环，在“中环街市”里解决晚餐，之后兵分两路，老人和孩子乘坐“水上巴士”回酒店，要逛要买买买的“天星号”去“尖沙咀”。</p>\n<p>无意还路过传说中的“重庆大厦”，搜索补课后，也算进去过了。夜晚的维多利亚港人不多，走走拍拍，寒风中撒欢。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk4.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk5.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk6.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk24.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk14.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk2.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk7.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk8.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/02/hkzw-hk10.webp\" alt=\"\"></p>\n<h3>难 &amp; 得</h3>\n<h4>难</h4>\n<p>大家庭自由行，太难了，10 人团已经是众口难调，更适合叫个地陪包车游。</p>\n<h4>得</h4>\n<p>看到臭小子明显的长进，主动与当地深度“交互”：</p>\n<ul>\n<li>等待拿饮料时，会拉上爷爷奶奶玩一玩边上的“健身”器材不亦乐乎</li>\n<li>挣着抢着拿相机、手机，积极找角度、坐叮叮车最前排，拍人、拍风景</li>\n<li>除了坐下等出餐会拿手机看会儿视频，或 Switch 玩会儿游戏，其余时间都是“好奇宝宝”，十万个为什么，废爹妈</li>\n</ul>\n<h4>感</h4>\n<p>每座城市，都有着各自的发展历程，完全无需“厚彼薄己”或相反。</p>\n", "categories": ["%E6%97%A5%E5%B8%B8"], "time": 1738785885}, {"title": "尊贵的 Tesla 车主 +1", "author": "林木木的博客", "pubDate": "2025-01-19 11:48:13", "link": "https://immmmm.com/hi-tesla-2025/", "description": "\n<p>上周 Model Y 焕新款终于官宣，细看了几分钟，旋即下了 Model 3 ，今日已成为“尊贵”的特斯拉车主。</p>\n<p>与之前的焕新款 3 相比：</p>\n<ul>\n<li>25年贵了3600</li>\n<li>电池增加到 62.5 度，原来是 60 度</li>\n<li>能以 ¥1299 购买赛博家用充电桩，原来要 ¥5200</li>\n</ul>\n<p>然后，若是旧车置换的话能试用 90 天的 EAP（增强版自动辅助驾驶）。</p>\n<h3>溜车三天杂记（1月23日）</h3>\n<h4>满电表显 458km，挺准</h4>\n<p>这几天市区道路+高架+高速累计已开 300km+，能耗在 137kw/h 。</p>\n<p>按照公式 62.5 度电 ÷ 137 能耗 x 1000 ≈ 456km，一次充电，满足一周上下班，够够的。</p>\n<p>家充 7kw，谷电 3 毛/度，一杯普通奶茶，一晚，满电。美滋滋。</p>\n<p>看别人发着，超充或第三方，50 几分钟可满电，算 2 元/度，一百来块钱，一小时，满电。还可以。</p>\n<h4>AP/EAP，上高架高速，好使</h4>\n<p>置换送了 90 天的 EAP，相比免费的 AP 多了“召唤”、“自动泊车”、“高速自动换道”和“高速自动进匝道”等。而 AP 只有车道保持，即“跟车”。</p>\n<p>虽然已落后国内的“智驾”，但其是纯视觉方案，想想，还是佩服！若经常高架高速，若 EAP 不是 3万2 而是 3千2，那还是非常值得开通的。</p>\n<p>有一点挺难受，两者都是保持车道居中，但很多人习惯于车道靠左一些，包括我自己。右侧是一辆大车且快贴着线时，感觉压力山大。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/01/IMG_8167.JPEG\" alt=\"\"></p>\n<h3>一人一车，磨合一小时</h3>\n<h4>优点</h4>\n<ul>\n<li>星空灰还对眼，既没有土灰的感觉，也没有纯黑那么刚硬的感觉。</li>\n<li>动力是杠杠的，没啥感觉没几秒就上了 80+ 码，找了找车机开启了超速“蜂鸣”提醒。</li>\n<li>隔音效果、车内震动优于预期，没有网上说的那么差。</li>\n<li>与 iOS 搭配，更可餐。锁屏、桌面、快捷小组件应有尽有。就等新系统推送，还能用 iWatch 控制。</li>\n</ul>\n<h4>缺点</h4>\n<ul>\n<li>新车味重，闻着晕。</li>\n<li>前排座位硬，怎么调都不舒服；后排空间小，做做小朋友还行。</li>\n<li>后车镜怎么调都难受，倒车拐弯盲区仍不少，没有 360 车身四周影像。</li>\n</ul>\n<h3>下单到提车，行云流水线</h3>\n<ul>\n<li>上周日晚 8 点，找了个客户经理，下定金 ¥1000。</li>\n<li>周一拉群，确认当地提车上牌，预计一周后（即今天）可提车。</li>\n<li>周二旧车置换官方合作方，上门验车估价签协议，立马收到 ¥1000 定金；虽老车已经符合报废补贴，但二手车估出来还值 1W1，这样加上后续的置换国补 1W5，比直接报废划算。</li>\n<li>同步，五年免息招行开启车贷申请流程。周三招行上门面签，周四贷款通过，同步 APP 里付了尾款 ¥79500，银行经理说贷个取个整 15W5，所以首付多付了些。</li>\n<li>同步，家用充电桩拉群，周三现场勘探后，确认方案。自己在国家电网上申请新电表，修改为新能源类型并开通峰谷电。</li>\n<li>周六，官方 App 内给车上好保险，选择周日也就是今天 0 点生效，太平洋保险基础套餐 ¥9013。</li>\n<li>今天，顺利提车，店内 0 消费，未延保，未买窗膜。</li>\n</ul>\n<h3>没日没夜，买了一堆软装</h3>\n<h4>山姆</h4>\n<ul>\n<li>腰靠、头靠两对 ¥245</li>\n</ul>\n<h4>YZ 牌</h4>\n<ul>\n<li>门槛条 4 件套 ¥156</li>\n<li>手套箱挂钩 ¥11.5</li>\n<li>通风口防尘网、后排空调出风口保护罩 ¥26.6</li>\n<li>后排空调下储物垃圾盒 ¥75.2</li>\n<li>中控储物收纳盒 ¥30</li>\n<li>补胎千斤顶支持 ¥20</li>\n<li>门锁保护扣 ¥15.7</li>\n<li>后排椅子下防踢垫板 ¥27.5</li>\n</ul>\n<h4>3M 牌</h4>\n<ul>\n<li>3M 屏下中控磁吸储物盒 ¥126</li>\n<li>3M 车头进风口防虫网 ¥109</li>\n</ul>\n<h4>小特叔叔车品</h4>\n<ul>\n<li>中控拓展坞，点烟器取电款 ¥108</li>\n<li>车门储物盒 x4，¥91.3</li>\n<li>碳纤纹车牌架 ¥70.2</li>\n<li>屏幕保护条 ¥8.3</li>\n<li>无线充软硅胶垫 ¥14.2</li>\n<li>后备箱垫 ¥63.7</li>\n<li>后备箱侧边储物盒 ¥54.4</li>\n</ul>\n<p>另外，买的刹车踏板扣到指甲开裂，仍安装失败，差评！还有中控水杯垫，毛胚就卡得够紧，多余。</p>\n<p>哦，找的客户经理私下送了脚垫，但还在路上。</p>\n<h3>感叹</h3>\n<p>副驾边的铭牌，生产日期 <code>2025年1月15日</code>，上周日 12 号晚下单，车子这周三下线，周日交付到车主手上。</p>\n<p>充值信仰，还看老马！</p>\n", "categories": ["%E6%97%A5%E5%B8%B8"], "time": 1737258493}, {"title": "2024年终总结", "author": "Redish101博客", "pubDate": "2024-12-30 16:00:00", "link": "https://blog.redish101.top/article/2024-summary", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://cdn.smartcis.cn/gh/redish101/cdn@src/img/postspark_export_2024-12-22_15-17-56.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412290927100.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291013292.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291018651.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741579.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741355.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291821543.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291929767.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291947480.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291953729.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292002652.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292004463.jpg\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/2024-summary\">https://blog.redish101.top/article/2024-summary</a>\n</blockquote>\n<div>\n<h2>2024年终总结及新年计划</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">2024年即将结束，在此总结一年中的功过荣辱以及值得记录或吐槽的事情、物品，并同时针对2025年进行总体规划。</p>\n<h2>博客</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本年度对博客进行了大规模，长时间（从冬天到夏天）的重构，从去年七月Next.js SSG的方案转为Go(Fiber) + Next.js的前后端分离方案，使自己的Go能力更上一部，尝试规模稍微复杂些的项目的流程。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">具体详尽内容见<a href=\"https://www.notion.so/16b0d19ec45680f4998cfdc9afac1cd7?pvs=21\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">博客重构</a> 。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">今年认识了一个与SpringBoot类似风格的nodejs服务端框架（nestjs），可惜没有早点遇到，轻笑推荐的好好用，早知道的话reblog就用nest写了。</p>\n<h2>编程</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本年度基本着重于对reblog的开发，但经过一年的长时间拖延，reblog整体依然处于较简陋的状态，来年将对reblog进行进一步的完善，为reblog新增如下功能（优先级递减）：</p>\n<ol start=\"1\">\n<li>标签与分类</li>\n<li>即刻（类似于说说功能）</li>\n<li>评论</li>\n<li>友情链接朋友圈（文章聚合订阅）</li>\n<li>内置的AI支持（摘要、问答）</li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">同时，将考虑使用nestjs重构retalk项目。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">来年将将更多经历投入到Acme Cloud Platform的开发上。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">截至本文完成时，Redish101共在GitHub上产生了1047次提交，相比2023年约增长622%。</p>\n<img src=\"https://cdn.smartcis.cn/gh/redish101/cdn@src/img/postspark_export_2024-12-22_15-17-56.png\" alt=\"https://cdn.smartcis.cn/gh/redish101/cdn@src/img/postspark_export_2024-12-22_15-17-56.png\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本年度共参与2个有效Pull Request：</p>\n<ol start=\"1\">\n<li><a href=\"https://github.com/umijs/umi/pull/12516\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">feat(create-umi): 为create-umi新增设置项目名称的步骤 #12516</a></li>\n<li><a href=\"https://github.com/gofiber/contrib/pull/1172\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">feat: Migrate Monitor Middleware #1172</a></li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">25年将着重对于以下领域的学习：</p>\n<ol start=\"1\">\n<li>Qt</li>\n<li>Nestjs</li>\n<li>OpenGL</li>\n<li>Vulkan</li>\n</ol>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">redish又在给自己挖坑了</p></blockquote>\n<h2>武汉</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">曾经出门的时候不止一次在火车上经过武汉，对于武昌火车站和长江大桥留下了深刻印象，再加上距离也不算很远，所以在24年二月初选择去武汉看看。</p>\n<h3>Day0</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">距离武汉并非十分遥远，便选择了乘火车（Z263硬座）前往。春节将至，凌晨三点钟的郑州站依旧灯火通明。列车缓缓驶出车站，前往武汉的旅途在窗外飞速后退的灯火旁拉开了帷幕。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">列车一路狂奔，天也蒙蒙亮了起来，但是天气似乎并不是十分晴朗，太阳在云层的遮挡下仅仅是撒下了些许白光。在无际的朦胧中，窗外的田野慢慢渐变到楼房。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">“前方到站——武昌站”。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412290927100.png\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412290927100.png\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">随着人流下了车，正式踏入武汉的地界。</p>\n<h3>Day1</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">走出武昌火车站，外面正下着朦胧的小雨，冒着小雨到了粮道街。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">热干面！</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">既然到了武汉肯定是要尝尝热干面的。热干面还是蛮合胃口的，筋道的面条裹挟着浓郁的浆汁，很是美味（<del>看似一小份不过似乎很容易吃饱</del>）。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">吃过饭，便来到了武汉最著名的景点之一——黄鹤楼。</p>\n<blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">昔人已乘黄鹤去，此地空余黄鹤楼。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">黄鹤一去不复返，白云千载空悠悠。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">晴川历历汉阳树，芳草萋萋鹦鹉洲。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">日暮乡关何处是？烟波江上使人愁。</p>\n</blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">古往今来，数不尽的人登上黄鹤楼，感慨万千，吟诗作赋，给这座楼增添了许多文化气息。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">逐层登上黄鹤楼，苍茫朦胧的景色扑面而来。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291013292.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291013292.jpeg\"><img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291018651.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291018651.jpeg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">下午去了辛亥革命纪念馆</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741579.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741579.jpeg\"><img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741355.jpg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741355.jpg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">天色渐渐暗下来了，毕竟凌晨就起床，又累又饿的，便匆匆回了酒店。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">坐车到酒店附近，已是天昏地暗，浑身疲软。摸了下口袋，身份证不翼而飞。猛地惊醒，趁着公交尚未离开，狂奔了回去，抱着一丝希望想要从车上找到，可惜无果。回到房间，给博物馆的工作人员打了个电话，也并未有人找到。</p>\n<h3>Day2</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">上午去了古德寺。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">古德寺的建筑风格与我一般印象中的佛教寺院很不一样，没有红墙绿瓦，反倒是浓郁的异域风气。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291821543.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291821543.jpeg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">雨水不大，微微拂面，给这建筑也衬上了一层静谧的气息。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">古德寺本身不大，没过多长时间就逛完了，便赶到湖北省博物馆附近。因为预约的是下午的场次，所以便准备先吃饭再前往博物馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">四周找寻好长时间，总算是走到小区附近找到了餐馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">吃过饭，排了好长时间队，总算进了博物馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">越王勾践剑展厅更是要排很长时间的队，排了好长时间进去后依然有很多人围到前面，身高又不占优势，甚至也没排到清楚的照片。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291929767.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291929767.jpeg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">从博物馆出来后看到天色并非很晚，就在截止前一会预约了隔壁美术馆的门票。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><del>来都来了.jpg（逃）</del></p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">不过可能是我的眼光不足以欣赏，也可能阅历不够丰富吧，没有看懂什么。。。</p>\n<h3>Day3</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">第三天选择长途跋涉去了科技馆玩，见到了好多之前在北京看到的相似的设施。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">不过寒假的多选一作业里面：</p>\n<ol start=\"1\">\n<li>制造一枚核弹，并拍摄引爆视频；</li>\n<li>制造一台永动机；</li>\n<li>上传一张与牛顿或爱因斯坦的合照。</li>\n<li>…</li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">于是……</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291947480.jpg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291947480.jpg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><del>太合理啦</del></p>\n<h3>Day4</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">第四天去了一个令我印象深刻的地方——五大旧址。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">曾经某次历史卷子曾给出了这里的图片，在学校“清晰”的印刷质量下已经是漆黑一片。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><del>所以，某种程度上的故地重游</del></p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">离开后时间还早，便前往晴川阁。</p>\n<blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">江上风烟望武昌，临江高阁晓苍苍。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">涛声八月蛟龙吼，霸气千秋草树荒。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">几点青山浮大别，一声残笛弄沧浪。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">自经崔颢题诗后，别是人间翰墨场。</p>\n</blockquote>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291953729.jpeg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291953729.jpeg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">由于下雪，（也许是雨夹雪，冻雨或者其他类似的各种东西），天气始终是朦胧的，迷蒙的，我很喜欢这种BSL（<del>白内障</del>）风格的氛围。远处楼影绰绰，淡墨色的长江大桥独跨江面。</p>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">忽如一夜春风来，千树万树梨花开。</p></blockquote>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292002652.jpg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292002652.jpg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><strong>徒步横跨长江！</strong></p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292004463.jpg\" alt=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292004463.jpg\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">走上了这座古朴的大桥，可能是风大，也可能单纯腿软，总觉得桥面在晃动。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">一不小心好险摔跤。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">还是小看了长江的长度，本以为能够步行过去后还能再徒步到酒店，看来还是高估自己了，最后依然选择坐地铁会酒店。</p>\n<h3>Day5</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">由于是上午的车，所以并没有去很远的地方，所以又去了一趟辛亥革命起义纪念馆，可惜身份证还是没找到。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">快到了回家的时候，走进武昌火车站，严峻的天气让诸多列车晚点，许多乘客滞留在候车厅，不过好在我们所乘坐的车次是从武昌火车站始发，而且有DF11G-0001/2的加持，列车依然正常出发。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">列车在风雪中奔驰，掠过楼房与田野。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">飞速的行驶并未成常态，在经过信阳附近时，开始了长时间的临时停车。（还好买的软座车票！）天逐渐黑了下来，腰酸背痛接踵而至，晚点了数小时后终于到了郑州站。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">深夜总算是回到家了，武汉之行也告一段落。</p>\n<h2>北京</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在七月份去了北京，内容较多，又考虑与以往在北京的经历串联起来写一篇文章，所以还是不放到年终总结里了吧（咕咕咕咕咕咕）。</p>\n<h2>A&amp;Q</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本年度也被人问了很多问题，这里集中回答下吧。</p>\n<h3>为什么叫redish，和redis有什么关系吗?</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">redish这个名字其实在很久之前（2020年之前）就已经取了，当时并不了解redis这一项目，取了这个名字。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">至于这个名字的含义？</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><strong>R</strong>obust and <strong>E</strong>fficient <strong>D</strong>istributed <strong>I</strong>ntelligent data <strong>S</strong>torage <strong>H</strong>andler</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><strong>强健且高效的分布式智能数据存储处理器</strong></p>\n<h3>为什么周末总是出门？</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">确实有些事情的，不要乱猜了）</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">写到这里也差不多了，就这样吧，今年的文章似乎确实不是很多，明年一定狠狠的更新！```</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/2024-summary#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1735545600}, {"title": "Windows Server DataCentre 2022 Retail序列号一次激活多次使用", "author": "Chenxi", "pubDate": "2024-11-16 18:00:21", "link": "https://chenxi.in/post/wsd2rxlhycjhdcsy/", "description": "<p>最近某宝花12块钱买了个Windows Server DataCentre 2022 Retail序列号，用在激活虚拟机上了，其实原本是打算用在物理机上的。Retail的序列号设计上是只能用一次，现在博主的需求是能激活多次用于多台虚拟机（用于出租🤣），那么设计和需求之间就存在矛盾了，现在需要解决这个矛盾</p>", "categories": [], "time": 1731751221}, {"title": "Windows提权 - 特权利用", "author": "Chenxi", "pubDate": "2024-07-28 16:33:13", "link": "https://chenxi.in/post/wtqtqly/", "description": "<p>最近整了2单oscp的<s>考</s>(jiu)<s>前</s>(shi)<s>辅</s>(dai)<s>导</s>(kao)，发现这个考试引入了一些不常用的Windows提权手法，因此专门开一篇文章做个记录（有点散嗖嗖的，有空整理整理一下🤣）<br><em>有关Windows提权的手法：</em>  <a href=\"https://chenxi.in/tqslzwjqx/\">总览</a>，<a href=\"https://chenxi.in/wrgu/\">绕过UAC</a>，<a href=\"https://chenxi.in/wtqaie/\">MSI特权安装</a><br><em>持续更新中</em></p>", "categories": [], "time": 1722155593}, {"title": "Deno再尝试：使用Deno编写一个简单的WebAPI", "author": "Redish101博客", "pubDate": "2024-07-22 20:13:46", "link": "https://blog.redish101.top/article/deno", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/deno\">https://blog.redish101.top/article/deno</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">两年前，我通过<a href=\"https://mk1.io/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">Ray(@so1ve)</a>的博客系统<a href=\"https://github.com/dolan-x/dolan-server\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">dolan-x</a>了解到了 <code>Deno</code>这一新的 js 运行时以及其对应的 saas 服务 <code>Deno Deploy</code>，为了<del>白嫖 <code>Deno Deploy</code></del>，决定尝试一下，用 Deno + oak + LeanCloud 写了一个简单的友链管理。但是 Deno 脆弱的生态和与 go 类似的基于 url 的模块系统（即使能通过 <code>import_map.json</code>定义别名）实在没有太多优势，最近 Deno Deploy 又被群友提及，看到 Deno 本身变化很大，便决定再尝试用 Deno 写一个东西。凑巧<a href=\"https://redish101.top/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">个人主页</a>想加一个活动监测器，便决定用 Deno 来实现。</p>\n<h2>web 框架的选择</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">相比之前的友链，这次要做的比较简单，所以没有使用一些框架，而是直接使用标准库中的 <code>Deno.serve</code>实现。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><code>Deno.serve</code>接受一个函数，函数接受请求对象返回响应。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const handler = (req: Request) {\n    return new Response(\"Hello, World!\");\n}\n\nDeno.serve(handler);</code></pre>\n<h2>路由</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">Deno 本身并没有实现路由，但是可以通过手动解析 <code>pathname</code>实现。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const handler = (req: Request) {\n    const { pathname } = new URL(req.url);\n\n    if (pathname === \"/\") {\n        return new Response(\"Hello, World!\");\n    }\n\n    if (pathname === \"/foo\") {\n        return new Response(\"bar\");\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">对于复杂的路由，可以尝试把 handler 封装到 map 中：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">type Handler = (req: Request) =&gt; Response;\ntype HandlerMap = { [pathname: string]: Handler };\n\nconst handlers: HandlerMap = {\n  \"/\": () =&gt; new Responese(\"Hello, World!\"),\n  \"/foo\": () =&gt; new Response(\"bar\"),\n};\n\nconst handler = (req: Request) =&gt; {\n  const { pathname } = new URL(req.url);\n\n  const matchedHandler = handlers[pathname];\n\n  if (matchedHandler) {\n    return matchedHandler(req);\n  }\n\n  return new Response(\"Not Found\", { status: 404 });\n};</code></pre>\n<h2>格式化响应</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">最好封装一个格式化响应对象，封装 <code>success</code>，<code>message</code>，<code>data</code>等属性，方便处理：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">class FmtResponse&lt;T&gt; {\n  private code: number = 200;\n  private success: boolean = true;\n  private message: string = \"success\";\n  private data: T | null = null;\n\n  constructor(opts: { code?: number; message?: string; data?: T }) {\n    if (opts.code &amp;&amp; opts.code &gt;= 400) {\n      this.success = false;\n    }\n    this.message = opts.message || \"success\";\n    this.data = opts.data || null;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">并提供一个 <code>json</code>方法返回 json 格式的响应：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">public json() {\n    const resObj = {\n      success: this.success,\n      message: this.message,\n      data: this.data,\n    };\n\n    return new Response(JSON.stringify(resObj), {\n      status: this.code,\n      headers: {\n        \"content-type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n        \"Access-Control-Allow-Headers\": \"Content-Type, apikey\",\n      },\n    });\n}</code></pre>\n<h2>数据的储存</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">选择 <code>Deno Deploy</code>很大一部分原因是因为其方便的 kv 储存，可以方便的持久化储存数据：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const kv = await Deno.openKv();\n\nawait kv.set([\"settings\", \"username\"], \"redish101\");\n\nconst username = await kv.get([\"settings\", \"username\"]);\n\nconsole.log(username.value); // \"redish101\"</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">值得一提的是，<code>DenoKV</code>虽然可以在本地使用，但是需要在 cli 传入 <code>--unstable-kv</code>：</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">deno run --unstable-kv main.ts</code></pre>\n<h2>监控数据的上报</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">这部分没什么可说的，用 rust 写了一个上报器，每 20 分钟通过请求接口上报正常状态的数据，并作为 macOS 服务运行：</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">use std::env;\n\nuse tokio::time;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt::init();\n\n    info!(\"Welcome to remonitor!\");\n\n    let apiurl = \"https://redish101-remonitor.deno.dev/remonitor\";\n    let apikey = env::var(\"APIKEY\").unwrap();\n\n    let mut interval = time::interval(time::Duration::from_secs(1200));\n\n    loop {\n        interval.tick().await;\n        info!(\"Post status\");\n        reqwest::Client::new()\n           .get(apiurl)\n           .header(\"apikey\", apikey.clone())\n           .send()\n           .await\n           .expect(\"Failed to send request\");\n        info!(\"Sent request\");\n    }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">macos 的服务不能直接读取环境变量，只能读取通过 <code>launchctl setenv</code>设置的环境变量。通过 plist 设置 <code>keepAlive</code>可以实现后台运行：</p>\n<pre class=\"language-xml lang-xml\"><code class=\"language-xml lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;Label&lt;/key&gt;\n    &lt;string&gt;top.redish101.remonitor&lt;/string&gt;\n    &lt;key&gt;ProgramArguments&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;/path/to/client&lt;/string&gt;\n    &lt;/array&gt;\n    &lt;key&gt;RunAtLoad&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;key&gt;KeepAlive&lt;/key&gt;\n    &lt;true/&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;</code></pre>\n<h2>部署</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><code>Deno Deploy</code>是Deno推出的saas服务，提供了Deno程序的部署、KV、定时任务等功能，并且速度不错，所以选择了通过Deno Deploy部署。</p>\n<h2>总结</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">Deno虽说目前不怎么适合放到大型项目的生产环境，但是写一些小服务玩玩还是很舒服的，编码体验很好</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/deno#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1721650426}, {"title": "“台独”死路一条", "author": "Chenxi", "pubDate": "2024-05-26 11:33:43", "link": "https://chenxi.in/post/tdslyt/", "description": "<figure data-type=\"image\" tabindex=\"1\"><img src=\"https://images.chenxi.in/tdslyt/1.JPG\" alt=\"\" loading=\"lazy\"></figure>", "categories": [], "time": 1716694423}, {"title": "绕过群晖NAS“禁止下载和复制”", "author": "Chenxi", "pubDate": "2024-04-16 15:11:33", "link": "https://chenxi.in/post/rgqhnjzxzhfz/", "description": "<p>还以为群晖分享文件的时候勾选“禁止下载和复制”有什么加密解密套壳的操作，没想到打开控制台就能看到请求的文件地址，复制粘贴访问之直接弹出下载<br>\n万万没想到既不防君子也不防小人😂</p>", "categories": [], "time": 1713251493}, {"title": "忙到没空更新", "author": "Chenxi", "pubDate": "2024-03-15 19:22:08", "link": "https://chenxi.in/post/mdmkgx/", "description": "<p>实在是太忙了😂<br>\n正所谓：打工人打工魂，打工的才是人上人🤣</p>", "categories": [], "time": 1710501728}, {"title": "SteamDeck开启samba服务", "author": "Yume.KISEKI", "pubDate": "2024-01-15 14:27:53", "link": "https://www.monoko.jp/steamdeck-samba/", "description": "\n<p>SteamDeck开启samba服务 1.前言 为什么steamdeck要开启samba服务，不为别的，我只用 […]</p>\n<p><a href=\"https://www.monoko.jp/steamdeck-samba/\">SteamDeck开启samba服务</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "samba", "steamdeck"], "time": 1705300073}, {"title": "Phira源码解析1: 入口函数", "author": "Redish101博客", "pubDate": "2023-12-17 05:43:12", "link": "https://blog.redish101.top/article/phira-source-code-1", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/phira-source-code-1\">https://blog.redish101.top/article/phira-source-code-1</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><code>phira</code>，原<code>prpr</code>，一款Phigros自制谱播放器，程序主体部分使用rust编写，底层为轻量的跨平台的rust图形库<code>miniquad</code>与其封装库<code>macroquad</code>。</p>\n<h2>项目结构</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">phira的仓库内有以下几个包</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">.\n├── Cargo.lock\n├── Cargo.toml\n├── LICENSE\n├── README-zh_CN.md\n├── README.md\n├── assets\n├── build_wasm.sh\n├── phira\n├── phira-main\n├── phira-monitor\n├── prpr\n├── prpr-avc\n└── rustfmt.toml</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">其中核心程序部分</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">.\n├── phira\n├── prpr\n└── phira-main</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">我们也主要展开这两个包的解析。</p>\n<h3><code>phira-main/src/main.rs</code></h3>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">fn main() {\n    phira::quad_main();\n}</code></pre>\n<h3><code>phira::quad_main</code></h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><code>phira::quad_main();</code>调用位于phira包内的入口函数。<code>quad_main</code>函数内容如下</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">pub extern \"C\" fn quad_main() {\n    macroquad::Window::from_config(build_conf(), async {\n        if let Err(err) = the_main().await {\n            error!(\"Error: {:?}\", err);\n        }\n    });\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><code>macroquad::Window::from_config</code>函数用于从配置新建一个macroquad窗口，此处配置由<code>build_conf</code>函数生成。</p>\n<h3><code>build_conf</code></h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">此函数位于<code>prpr</code>包内。内容如下</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">pub fn build_conf() -&gt; macroquad::window::Conf {\n    macroquad::window::Conf {\n        window_title: \"Phira\".to_string(),\n        window_width: 973,\n        window_height: 608,\n        ..Default::default()\n    }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">此函数返回了<code>macroquad::window::Conf</code>结构体，此结构体用以指定macroquad窗口的标题，尺寸等配置项。</p>\n<h3><code>the_main</code></h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在<code>quad_main</code>函数中被调用，程序实际主体部分。内容如下：</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">async fn the_main() -&gt; Result&lt;()&gt; {\n    // 注册日志记录器\n    log::register();\n\n    // 初始化资源文件\n    init_assets();\n\n    // 创建tokio运行时\n    let rt = tokio::runtime::Builder::new_multi_thread()\n        .worker_threads(4) // 设置工作线程数为4\n        .enable_all() // 启用所有功能\n        .build() // 构建运行时\n        .unwrap(); // 获取运行时实例\n    let _guard = rt.enter(); // 进入运行时上下文\n\n    // ios环境下的特殊设置\n    #[cfg(target_os = \"ios\")]\n    unsafe {\n        use prpr::objc::*;\n        #[allow(improper_ctypes)]\n        extern \"C\" {\n            pub fn NSSearchPathForDirectoriesInDomains(\n                directory: std::os::raw::c_ulong,\n                domain_mask: std::os::raw::c_ulong,\n                expand_tilde: bool,\n            ) -&gt; *mut NSArray&lt;*mut NSString&gt;;\n        }\n        let directories = NSSearchPathForDirectoriesInDomains(5, 1, true);\n        let first: &amp;mut NSString = msg_send![directories, firstObject];\n        let path = first.as_str().to_owned();\n        *DATA_PATH.lock().unwrap() = Some(path);\n        *CACHE_DIR.lock().unwrap() = Some(\"Caches\".to_owned());\n    }\n\n    // 读取数据文件目录\n    let dir = dir::root()?;\n    let mut data: Data = std::fs::read_to_string(format!(\"{dir}/data.json\")) // 读取数据文件\n        .map_err(anyhow::Error::new) // 处理错误\n        .and_then(|s| Ok(serde_json::from_str(&amp;s)?)) // 解析JSON数据\n        .unwrap_or_default(); // 如果解析失败，使用默认值\n    data.init().await?; // 初始化数据\n    set_data(data); // 设置数据\n    sync_data(); // 同步数据\n\n    // 创建消息通道\n    let rx = {\n        let (tx, rx) = mpsc::channel();\n        *MESSAGES_TX.lock().unwrap() = Some(tx);\n        rx\n    };\n\n    // 创建防沉迷消息通道\n    let aa_rx = {\n        let (tx, rx) = mpsc::channel();\n        *AA_TX.lock().unwrap() = Some(tx);\n        rx\n    };\n\n    // 设置暂停恢复监听器\n    unsafe { get_internal_gl() }\n        .quad_context\n        .display_mut()\n        .set_pause_resume_listener(on_pause_resume);\n\n    // 如果存在用户信息，执行防沉迷操作\n    if let Some(me) = &amp;get_data().me {\n        anti_addiction_action(\"startup\", Some(format!(\"phira-{}\", me.id)));\n    }\n\n    // 加载Phigros字体文件\n    let pgr_font = FontArc::try_from_vec(load_file(\"phigros.ttf\").await?)?;\n    PGR_FONT.with(move |it| *it.borrow_mut() = Some(TextPainter::new(pgr_font, None)));\n\n    // 加载其他字体文件\n    let font = FontArc::try_from_vec(load_file(\"font.ttf\").await?)?;\n    let mut painter = TextPainter::new(font.clone(), None);\n\n    // 创建主场景、时间管理器和帧率计时器\n    let main = Main::new(Box::new(MainScene::new(font).await?), TimeManager::default(), None).await?;\n    let tm = TimeManager::default();\n    let mut fps_time = -1;\n\n    // 主循环\n    'app: loop {\n        let frame_start = tm.real_time(); // 记录当前帧开始时间\n        let res = || -&gt; Result&lt;()&gt; {\n            main.update()?; // 更新主场景\n            main.render(&amp;mut painter)?; // 渲染主场景\n            if let Ok(paused) = rx.try_recv() { // 接收暂停恢复消息\n                if paused {\n                    main.pause()?; // 暂停主场景\n                } else {\n                    main.resume()?; // 恢复主场景\n                }\n            }\n            Ok(())\n        }();\n        if let Err(err) = res { // 处理错误\n            error!(\"uncaught error: {err:?}\");\n            show_error(err);\n        }\n        if main.should_exit() { // 判断是否退出游戏\n            break 'app;\n        }\n\n        if let Ok(code) = aa_rx.try_recv() { // 接收防沉迷消息\n            info!(\"anti addiction callback: {code}\");\n            match code {\n                500 =&gt; {\n                    anti_addiction_action(\"enterGame\", None);\n                }\n                1001 =&gt; {\n                    anti_addiction_action(\"exit\", None);\n                    get_data_mut().me = None;\n                    get_data_mut().tokens = None;\n                    let _ = save_data(); // 保存数据\n                    sync_data(); // 同步数据\n                    use crate::login::L10N_LOCAL;\n                    show_message(crate::login::tl!(\"logged-out\")).ok(); // 显示退出登录提示\n                }\n                1030 =&gt; {\n                    show_and_exit(\"你当前为未成年账号，已被纳入防沉迷系统。根据国家相关规定，周五、周六、周日及法定节假日 20 点 - 21 点之外为健康保护时段。当前时间段无法游玩，请合理安排时间。\");\n                    exit_time = frame_start;\n                }\n                1050 =&gt; {\n                    show_and_exit(\"你当前为未成年账号，已被纳入防沉迷系统。根据国家相关规定，周五、周六、周日及法定节假日 20 点 - 21 点之外为健康保护时段。你已达时间限制，无法继续游戏。\");\n                    exit_time = frame_start;\n                }\n                9002 =&gt; {\n                    show_and_exit(\"必须实名认证方可进行游戏。\");\n                    exit_time = frame_start;\n                }\n                _ =&gt; {}\n            }\n        }\n\n        let t = tm.real_time(); // 获取当前时间\n\n        if t &gt; exit_time + 5. { // 判断是否达到退出条件\n            break;\n        }\n\n        let fps_now = t as i32; // 计算当前帧率\n        if fps_now != fps_time { // 如果帧率发生变化，更新帧率计时器\n            fps_time = fps_now;\n            info!(\"FPS {}\", (1. / (t - frame_start)) as u32);\n        }\n\n        next_frame().await; // 等待下一帧\n    }\n    Ok(())\n}</code></pre>\n</div>\n<p><a href=\"https://blog.redish101.top/article/phira-source-code-1#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1702762992}, {"title": "2023年年终总结", "author": "Redish101博客", "pubDate": "2023-12-15 03:08:54", "link": "https://blog.redish101.top/article/2023-summary", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/2023-summary\">https://blog.redish101.top/article/2023-summary</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">又至年末，又到了作年终总结的时候了。本来不想写年末总结的，但是看看这更新日期以及屈指可数的文章，还是写一篇为好。</p>\n<h2>博客数据</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本年度博客程序部分进行了两次大改版，第一次于本年3月由Hexo至Next.js Pages Router，后于七月重构至Next.js App Router，但核心的数据管理部分未做更改。而在ui设计方面使用了苏卡卡大佬的设计，但由于闭源，均为亲自实现。并于最近使用vite整理封装为react组件库(@recomponents/react)，但组件较少，缺失Input，List等实用组件，一般建议在如博客等场景中应用，而其中Card组件可自定义参数较多，可以实现较高程度的定制化。组件库使用了style9实现了预编译的原子化css，自npm下载使用时无需进行编译器层面的配置，但生产环境下类名经过处理，不易调试。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">新博客在Markdown渲染上会尝试接入尚未完成的由rust编写的Markdown解析器，主要用作练手使用。</p>\n<h2>服务商的选择</h2>\n<h3>服务端</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">由于vercel平台在管理自动部署等方面相较于其它服务商较好的优化，并且对于Next.js项目有极好的支持，所以至今所有web服务均部署在vercel上。</p>\n<h3>CDN</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">八月份Jason送了初七云亚太加速包，速度很好，但是配置方面实在不易学习，故又更换为Cloudflare，而Cloudflare在中国内地的访问速度并为太过于无法接受，且在配置方面有更好的效果，用起来还是十分不错的。</p>\n<h2>新技能</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">2022年目标中的新技能列表如下:</p>\n<ul>\n<li>Rust</li>\n<li>Unity</li>\n<li>Blender</li>\n<li>Pytorch</li>\n<li>K8S</li>\n<li>Latex</li>\n</ul>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">其中已经实现的有:</p>\n<ul>\n<li>Rust</li>\n<li>Blender</li>\n<li>Ltex</li>\n</ul>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">生命不息，奋斗不止</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">真的有认真在学啊！！！可是学不会，我是废物啊啊啊！</p>\n<h2>项目</h2>\n<h3>Retalk</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">大规模重构ing.....</p>\n<h3>remake-rs</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在写js相关操作</p>\n<h3>远期规划</h3>\n<ul><li>基于Rust的Minecraft: Bedrock Edition服务端</li></ul>\n<pre class=\"\"><code class=\"\">\n</code></pre>\n</div>\n<p><a href=\"https://blog.redish101.top/article/2023-summary#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1702580934}, {"title": "[搬运文] - offsec在线考试作弊“技巧”", "author": "Chenxi", "pubDate": "2023-12-08 18:16:03", "link": "https://chenxi.in/post/bywozxkszbjq/", "description": "<p><em>搬运自Quora</em><br>\n按照该文中的方法操作了一下，还真是无感作弊😂，根本不知道别的人登录进了考试用的虚拟机<br>\n能写出这篇“技巧”的人对于“漏洞”的理解可不是一般的深<br><em>稍微推广一下其实可以发现：这个方法适用于所有线上需要使用虚拟机进行的认证考试</em><br><a href=\"https://www.quora.com/profile/Nobody-Jack-1/\" target=\"_blank\">原文链接</a></p>", "categories": [], "time": 1702030563}, {"title": "浅谈Quest3", "author": "Yume.KISEKI", "pubDate": "2023-11-25 15:41:21", "link": "https://www.monoko.jp/about-quest3/", "description": "\n<p>入手quest3 当初想买quest2时发现已经出了有两年了，对于vr这种可有可无的设备干脆就等quest3了 […]</p>\n<p><a href=\"https://www.monoko.jp/about-quest3/\">浅谈Quest3</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "quest3", "vr"], "time": 1700898081}, {"title": "朝鲜红星OS提权到root", "author": "Chenxi", "pubDate": "2023-10-26 09:08:43", "link": "https://chenxi.in/post/cxhxotqdr/", "description": "<p>一段时间前做过的，忘记写下来了😅</p>", "categories": [], "time": 1698282523}, {"title": "2023年QQBOT防风控小妙招", "author": "轻音时雨的博客", "pubDate": "2023-09-25 11:20:37", "link": "https://www.594594.xyz/2023/09/25/qqbot_anti_risk/", "description": "<p>本文内容禁止抄袭、转载、搬运</p>", "categories": ["游戏相关", "教程"], "time": 1695612037}, {"title": "Windows提权 - AlwaysInstallElevated", "author": "Chenxi", "pubDate": "2023-09-18 04:29:13", "link": "https://chenxi.in/post/wtqaie/", "description": "<p>今天是 9·18，不要忘记：日本军国主义目前还没被清算，余孽依旧在<br>\n牢记历史 砥砺前行 吾辈自强</p>", "categories": [], "time": 1694982553}, {"title": "CloudFlare warp 优选", "author": "wututu-blog", "pubDate": "2023-08-12 15:20:04", "link": "https://blog.wututu.cn/cloudflare-warp-%E4%BC%98%E9%80%89/", "description": "博客原文地址：https://blog.misaka.rest/2023/03/12/cf-warp-yxip cloudflar ...", "categories": ["未分类"], "time": 1691824804}, {"title": "各大frp内网穿透评测", "author": "wututu-blog", "pubDate": "2023-08-06 02:41:43", "link": "https://blog.wututu.cn/%E5%90%84%E5%A4%A7frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%AF%84%E6%B5%8B/", "description": "只做评测排名不分上下 1.LoCyan Frp 此家frp坚持100%免费不做任何收费项目，如果有能力的话可以捐赠此项目 官网：h ...", "categories": ["内网穿透", "评测"], "time": 1691260903}, {"title": "这又是什么理论", "author": "Chenxi", "pubDate": "2023-07-28 16:39:11", "link": "https://chenxi.in/post/zyssmll/", "description": "<p>小红书上有个人说：就静态网站这点东西黑进去分分钟搞掂<br>\n博主不是很信，除非有手上有Apache 2.4.55 RCE / SSH 8.7p1 RCE<br>\n（最近做了迁移，现在是Apache 2.4.57 / SSH 9.2p1）<br>\n其实对于技术人员来说，劈里啪啦一大堆理论有个屁用，请用getshell说话（Talking is cheap，show me the code）（如果是真的有技术的话，早就入侵进来挂黑页了，根本不用在评论区里打嘴炮）<br>\n开启“装B之神”专区，截图挂出小红书B神（纯属没事干🤣）</p>", "categories": [], "time": 1690533551}, {"title": "将我的博客迁移到Next.js App Router与React Server Components", "author": "Redish101博客", "pubDate": "2023-07-13 05:03:10", "link": "https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-component", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230712213628.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131357.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131238.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-component\">https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-component</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在今年三月初，我使用 Next.js 重构了我的博客。现在，随着 Next.js AppRouter 的稳定，我又将博客从 Next.js Pages Router 迁移到了 Next.js 13 AppRouter 与 React Server Components，同时，我也做了大量的底层重构以及样式重构。</p>\n<h2>性能优化: React Server Components</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在 React 18 之前，所有的组件均为 <code>Client Components</code>，即客户端组件。顾名思义，客户端组件中的所有逻辑均在客户端执行。浏览器渲染客户端组件需要从服务端获取 chunk，然后渲染组件到页面。即使是在 SSR 中，也需要等待客户端组件所对应的 bundle 完成加载才能让页面具有逻辑，能够交互。而我们的一些操作并不需要在客户端调用：如获取数据，大量的类似的逻辑，大大提高了 bundle 的体积，使得页面加载相对较慢，而 <code>React Server Components</code>（以下简称 <code>RSC</code>）的出现很好的解决了这一问题。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">RSC 不同于客户端组件，RSC 在服务端的 React 执行，客户端所收到的是服务端的执行结果，也就是说，客户端不会加载任何 RSC 的逻辑代码，以此我们就能缩小 Client Bundle。因为 RSC 是在服务端执行的，所以理所当然，RSC 内能够调用 node 环境，我们也就不必通过 <code>getStaticProps</code>等 api 获取数据。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">之前的文章提到过，我将博客从 Hexo 迁移到了基于文件的 CMS，以往博客版本是这样获取数据的：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export async function getStaticPaths() {\n  const posts = getAllPosts([\"slug\"]);\n\n  return {\n    paths: posts.map((post) =&gt; {\n      return {\n        params: {\n          slug: post.slug,\n        },\n      };\n    }),\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }: any) {\n  const post = getPostBySlug(params.slug, [\"title\", \"date\", \"slug\", \"content\"]);\n  const content = await markdownToHtml(post.content || \"\");\n  await generateRss();\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content,\n      },\n    },\n  };\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">而在使用 RSC 后，我们可以直接获取数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default async function Post({ params }: { params: { slug: string } }) {\n  const post = getPostBySlug(params.slug, [\n    \"title\",\n    \"date\",\n    \"slug\",\n    \"cover\",\n    \"content\",\n  ]);\n  if (!post.title) {\n    return notFound();\n  }\n  const content = await markdownToHtml(post.content || \"\");\n  return (\n    &lt;&gt;\n      &lt;Card title={post.title} cover={post.cover} label={post.date.toString()}&gt;\n        &lt;div dangerouslySetInnerHTML={{ __html: content }} /&gt;\n      &lt;/Card&gt;\n    &lt;/&gt;\n  );\n}\n\nexport async function generateStaticParams() {\n  const posts = getAllPosts([\"slug\"]);\n  return posts.map((post) =&gt; ({\n    slug: post.slug,\n  }));\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">可以看见，使用 RSC 后的页面相比于不使用 RSC 的页面大幅减少了代码长度。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">但正因 RSC 是在 node 环境运行的，所以我们不能在 RSC 使用浏览器的 api，也无法使用 <code>useState</code>等 api，也就是说，RSC 不能直接响应用户的交互。而当我们需要调用浏览器api时，可以通过在组件代码前加上 <code>\"use client\";</code>将组件更改为客户端组件，就能调用浏览器api。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">值得一提的是，我们可以在RSC中引入客户端组件：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;div&gt;\n  This is a RSC\n  &lt;ClientComponent /&gt;\n&lt;/div&gt;</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">但我们不能在客户端组件内引入RSC：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;ClientComponent&gt;\n  &lt;ServerComponent /&gt;\n&lt;/ClientComponent&gt;</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">但我们依然有办法在客户端组件内直接调用RSC。前文提到，RSC在渲染过程中需要node的参与，但是返回结果是相当于静态的，所以我们可以通过Props的方式向客户端组件传入RSC的返回值实现：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;ServerComponent&gt;\n  const res = &lt;AnotherSC /&gt;\n  &lt;ClientComponent aprop={res} /&gt;\n&lt;/ServerComponent&gt;</code></pre>\n<h2>布局优化： Next.js App Router</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在 Next.js 13 中，Next.js 新增了一种新的路由方式：<code>App Router</code>。它基于 <code>React Server Components</code>开发，支持共享布局，加载状态，嵌套路由，错误处理等。其中对我而言最重要的更新就是嵌套路由。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">App Router 将路由拆分为布局与内容两部分，其中布局支持嵌套，大大减少了代码冗余。例如我们要实现 AB 两个页面，二者都包含一个导航栏和一个侧边栏，B 页面在以上的基础下又包含其自身所需要的布局，即需要布局嵌套，在 <code>Pages Router</code>中，我们需要这样：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// A.tsx\nexport default function A() {\n  return (\n    &lt;LayoutA&gt;\n      &lt;Content /&gt;\n    &lt;/LayoutA&gt;\n  );\n}</code></pre>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// B.tsx\nexport default function B() {\n  return (\n    &lt;LayoutA&gt;\n      &lt;LayoutB&gt;\n        &lt;Content /&gt;\n      &lt;/LayoutB&gt;\n    &lt;/LayoutA&gt;\n  );\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">只有两层情况就已经如此糟糕，倘若有三层，四层.......代码的可读性将大大降低。但在 App Router 中，我们可以这样做:</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// app/a/layout.tsx\nexport default RootLayout({ children }: { children: ReactNode }) {\n  return (\n      &lt;html lang=\"zh-CN\"&gt;\n      &lt;body&gt;\n        &lt;NavBar /&gt;\n        &lt;div&gt;\n          &lt;LayoutA&gt;{children}&lt;/LayoutA&gt;\n        &lt;/div&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  )\n}</code></pre>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// app/a/b/layout.tsx\nexport default LayoutB({ children }: { children: ReactNode }) {\n  return &lt;LayoutA&gt;{children}&lt;/LayoutA&gt;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">此时，b 页面的布局会自动继承 a 的布局，并在其基础上新增其自身布局，代码会十分简洁。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">除了语法更加简洁，我们也可以通过AppRouter实现共享布局。</p>\n<h2>服务端: 从 SSG 迈向 SSR</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在<a href=\"https://blog.redish101.top/post/blog-v5\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">「使用 Next.js 重构我的博客」</a>一文中我提到，我将博客核心所使用的 CMS 从 <code>Hexo</code>迁移到自研的基于文件的 CMS，在构建时使用 <code>Next.js Pages Router</code>提供的 <code>getStaticProps</code>等一系列 api 在构建时从本地获取文章并渲染，但在我迁移博客到 <code>Next.js App Router</code>时这样的做法无法通过构建，原因是 App Router 并不支持使用 <code>getStaticProps</code>等 api 获取数据。同时，在构建时渲染 Markdown 也会导致构建速度很慢，在考虑之下，我决定放弃 SSG，迈向 SSR。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">但是，如果在每次访问都渲染一次文章，就会导致服务器压力激增，客户端访问速度直线上升。显然，这种做法是极其不明智的。好在，React 18 中提供了一个 <code>cache</code>方法，被 <code>cache</code>包裹的方法，在传参不变的情况下不会执行方法，而是直接返回缓存值，例如：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { cache } from \"react\";\n\nconst add = (a: number, b: number) =&gt; {\n  return a + b;\n};\n\nconst cacheAdd = cache(add);\n\ncacheAdd(1, 2); // 3\ncacheAdd(1, 2); // 3</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">如果参数不变，多次调用 <code>cacheAdd</code>方法，并不会执行 <code>add</code>方法，而是会直接返回缓存值。上面的代码也可以写成这样：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { cache } from \"react\";\n\nconst add = cache((a: number, b: number) =&gt; {\n  return a + b;\n});\n\nadd(1, 2); // 3\nadd(1, 2); // 3</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">接下来的事情就简单了，只需要在读取和渲染文章的方法外包裹 <code>cache</code>就能提高性能：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">export const getPostBySlug = cache((slug: string, fields: string[] = []) =&gt; {\n  // ...\n});</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">顺便提一下，本人参与开发的评论系统「retalk」也大量使用了缓存提高性能</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">但现在依然有一个问题，现在服务端在收到请求后，会根据请求路径中的 slug 查找文章，并读取文章内容，但当文件不存在时，node 的 fs api 就会抛出错误，使 <code>getPostBySlug</code>方法没有返回任何内容，进而导致服务端返回 500，所以我们需要在 <code>getPostBySlug</code>方法中检测 slug 是否存在，若不存在则返回空对象而不是没有返回值：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">if (!fs.existsSync(fullPath)) {\n  return items;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在调用时检测返回对象是否包含 slug：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">if (!post.title) {\n  return notFound();\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\"><code>notFound()</code>是 Next.js 提供的方法，可以手动返回 404。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">这时，我们再尝试访问不存在的文章，服务端会返回 404，而非 500。</p>\n<h2>元数据: 从 next/head 到 Next Metadata</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在 Pages Router 中，我们可以在页面中返回 <code>Head</code>组件自定义页面的元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import Head from \"next/head\";\n\nexport default function PageA() {\n  return (\n    &lt;Head&gt;\n      &lt;title&gt;Your Title&lt;/title&gt;\n    &lt;/Head&gt;\n  );\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">而在 App Router 中，我们可以通过导出 <code>metadata</code>的方法设置元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"Your Title\",\n};</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">简介等属性同理</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">除了静态导出，我们还可以通过导出 <code>generateMetadata</code>函数实现动态设置元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export async function generateMetadata({\n  params,\n}: {\n  params: { slug: string };\n}): Promise&lt;Metadata&gt; {\n  const post = getPostBySlug(params.slug, [\"title\", \"content\"]);\n  if (!post.title) {\n    return {\n      title: `404 - ${config.name}`,\n    };\n  }\n  return {\n    title: `${post.title} - ${config.name}`,\n    description: post.content.slice(0, 200),\n  };\n}</code></pre>\n<h2>Markdown 渲染: 从 remark 到 marked</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在以往的版本中，我使用 <code>remark</code>完成 Markdown 的渲染，但我逐渐发现，remark 逐渐无法满足我的需求，所以更换到 <code>marked</code>。marked 支持自定义渲染器，可以更方便的修改渲染逻辑。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本站的 markdown 渲染被封装到了一个 <code>markdownToHtml</code>函数，所以更改渲染器十分方便：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">export default async function markdownToHtml(markdown: string) {\n  const renderer = new marked.Renderer();\n\n  renderer.code = function (code, language) {\n    // 添加hljs类和data-language属性\n    let lang = language ? language.toUpperCase() : \"\";\n    if (!language) {\n      lang = \"TEXT\";\n    }\n    if (language == \"\") {\n      language = \"plaintext\";\n    }\n    const highlightedCode = highlightjs(code, language);\n    return `&lt;pre class=\"hljs language-${lang}\" data-language=\"${lang}\"&gt;\n      &lt;code&gt;${highlightedCode}&lt;/code&gt;\n    &lt;/pre&gt;`;\n  };\n  return marked.parse(markdown, { mangle: false, headerIds: false, renderer });\n}</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">完整的渲染器代码较长，此处仅展示部分代码，可能无法单独使用</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">React 无法直接将 html 嵌入到组件作为子元素使用，但提供了属性 <code>dangerouslySetInnerHTML</code>供开发者显示 html 字符串，所以在这里可以这样写：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default async function Post({ params }: { params: { slug: string } }) {\n  const post = getPostBySlug(params.slug, [\n    \"title\",\n    \"date\",\n    \"slug\",\n    \"cover\",\n    \"content\",\n  ]);\n  if (!post.title) {\n    return notFound();\n  }\n  const content = await markdownToHtml(post.content || \"\");\n  return (\n    &lt;&gt;\n      &lt;Card title={post.title} cover={post.cover} label={post.date.toString()}&gt;\n        &lt;div&gt;\n          &lt;div&gt;{post.desc}&lt;/div&gt;\n          &lt;div dangerouslySetInnerHTML={{ __html: content }} /&gt;\n        &lt;/div&gt;\n      &lt;/Card&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<h2>代码高亮: 自定义主题</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">以往版本中，正文部分所使用的代码高亮主题是由 <code>github-markdown-css</code>提供的，我逐渐发现其设计不满足我的需求，便进行了自定义。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">代码高亮配色我觉得没有必要更改，但是 <code>highlight.js</code>提供的主题不支持深色模式，我就不得不手写配色。我将包含深色模式的配色放到了全局变量中：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">:root {\n  --pre: #fafafa;\n  --pre-comment: #6a737d;\n  --pre-string: #032f62;\n  --pre-literal: #032f62;\n  --pre-keyword: #d73a49;\n  --pre-function: #6f42c1;\n  --pre-deleted: #24292e;\n  --pre-class: #22863a;\n  --pre-property: #005cc5;\n  --pre-namespace: #6f42c1;\n  --pre-punctuation: #24292e;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --pre-comment: #757575;\n    --pre-string: #977cdc;\n    --pre-literal: #c64640;\n    --pre-keyword: #77b7d7;\n    --pre-function: #86d9ca;\n    --pre-deleted: #fff;\n    --pre-class: #dfab5c;\n    --pre-property: #77b7d7;\n    --pre-namespace: #86d9ca;\n    --pre-punctuation: #fff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">然后在 highlight.js 提供的默认主题基础上做修改，将颜色从固定值改为变量：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.hljs {\n  color: var(--text);\n  background: var(--pre);\n}\n.hljs-doctag,\n.hljs-keyword,\n.hljs-meta .hljs-keyword,\n.hljs-template-tag,\n.hljs-template-variable,\n.hljs-type,\n.hljs-variable.language_ {\n  color: var(--pre-keyword);\n}\n.hljs-title,\n.hljs-title.class_,\n.hljs-title.class_.inherited__,\n.hljs-title.function_ {\n  color: var(--pre-function);\n}</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">此处因篇幅原因只展示部分</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">原有代码块并没有直接显示语言，容易产生歧义。出现了以下设计方案：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230712213628.png\" alt=\"两种方案\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">显然第一种更显眼并具有设计感。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">具体实现我使用了 <code>before</code>伪类的方式，通过 <code>attr(data-language)</code>读取自定义渲染器所输入的语言名称：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">return `&lt;pre class=\"hljs language-${lang}\" data-language=\"${lang}\"&gt;\n      &lt;code&gt;${highlightedCode}&lt;/code&gt;\n    &lt;/pre&gt;`;</code></pre>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">pre::before {\n  color: var(--text-l);\n  opacity: 0.25;\n  content: attr(data-language);\n  font-size: 1.625rem;\n  font-weight: 700;\n  position: absolute;\n  right: 0.5rem;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">至此完成了代码块的修改。</p>\n<h2>CSS: Atomic CSS In JS</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">传统的css在使用重复布局时回产生大量冗余，例如以下三个类：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.a {\n  padding: 1.125rem;\n  color: pink;\n}\n\n.b {\n  padding: 1.125rem;\n  color: skyblue;\n}\n\n.c {\n  margin: 1.125rem;\n  color: pink;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">可以看见，<code>pading: 1.125rem</code>与 <code>color: pink</code>被在css中出现了多次，现在这个css文件共有6个属性。我们可以将它们拆分，封装成4个类：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.p-125 {\n  pading: 1.125rem;\n}\n\n.color-pink {\n  color: pink;\n}\n\n.color-skyblue {\n  color: skyblue;\n}\n\n.m-125 {\n  margin: 1.125rem;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在html中我们可以直接使用这些类的组合实现与第一种方式相同的效果，这就是原子化css。使用原子化设计的css只出现了4个属性。不难看出，原子化css能够减少css的体积。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在实际使用中，我们往往会使用已经绑定好的原子化css库，例如tailwindcss等。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">但是，这种做法会导致代码中有一大串的类名，显然不够优雅。所以，我使用了 <code>style9</code>，实现atomic css in js，您可以打开devtools查看效果。</p>\n<h2>布局设计: 拥抱双飞翼</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">以往版本的博客使用单栏设计，只留出中间一栏展示所有信息，这样做实现简单，但会导致比较单调。在新博客的设计中，我采用了「双飞翼」布局，即三栏布局：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131357.png\" alt=\"三栏布局\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">将布局拆分为 <code>Sidebar</code>与 <code>Content</code>，使用Next App Router可以实现路由跳转只加载 <code>Content</code>。具体实现使用 <code>CSS Flex</code>布局。</p>\n<h2>基础设计: Card</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">如你所见，本站现在的所有组件都是卡片，基础是一个具有 <code>title</code>，<code>label</code>，<code>content</code>，<code>size</code>，<code>cover</code>等众多属性的组件：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131238.png\" alt=\"布局演示\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">以此保证样式的统一。</p>\n<h2>深色模式: CSS变量</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">深色模式能够提高用户体验，为了实现深色模式，我为深色模式单独设计了配色，并通过 <code>@media (prefers-color-scheme: dark)</code>实现根据系统设置自动切换。</p>\n<h2>友情链接: 从静态到动态</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">以往的友情链接是静态储存的，这样做难免会有局限性，在新版博客中，我将友情链接数据迁移到了GitHub仓库，并通过 <code>Chuqi CDN</code>实时获取友情链接信息。</p>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">你想与101互换友情链接吗，那就看看下面的步骤吧</p></blockquote>\n<h3>前置条件</h3>\n<ul>\n<li>友情链接，先友后链，所以最好是101比较眼熟的朋友</li>\n<li>您的网站不是免费域名，包括但不限于：\n<ul>\n<li>由Freenom公司运营的 <code>.tk</code>，<code>.ml</code>等免费域名（不包括付费购买的域名）</li>\n<li>由 Joshua Anderson 运营的 Afraid FreeDNS 提供的免费子域名</li>\n<li>其他不包含在 Public Suffix List 中的 <strong>免费子域名</strong> 服务</li>\n<li>\n<code>*.github.io</code>，<code>*.gitee.io</code>等域名</li>\n</ul>\n</li>\n<li>不能是采集站！！！！！！！！！</li>\n<li>有三篇以上的原创文章（包括三篇）</li>\n<li>站点上有我的链接</li>\n</ul>\n<h3>我的信息</h3>\n<pre class=\"language-json lang-json\"><code class=\"language-json lang-json\">{\n  \"name\": \"Redish101 Blog\",\n  \"desc\": \"人文 科技 白日梦\",\n  \"icon\": \"https://blog.redish101.top/favicon.ico\",\n  \"link\": \"https://blog.redish101.top\"\n}</code></pre>\n<h3>添加</h3>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">仓库: <a href=\"https://github.com/Redish101/friend-links\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">https://github.com/Redish101/friend-links</a></p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">如果你满足前置条件，就可以开始提交。</p>\n<ol start=\"1\">\n<li>Fork本仓库</li>\n<li>更改data.json</li>\n<li>添加你的网站</li>\n<li>向本仓库提交pr</li>\n<li>等待审核</li>\n<li>审核完成后将会在Redish101 Blog下次构建时生效</li>\n</ol>\n<h2>尾声</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">感谢阅读</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-component#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1689195790}, {"title": "使用Fiber Starter开始一个Golang Web后端项目", "author": "Redish101博客", "pubDate": "2023-04-16 07:11:45", "link": "https://blog.redish101.top/article/fiber-starter", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230416152822.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/fiber-starter\">https://blog.redish101.top/article/fiber-starter</a>\n</blockquote>\n<div>\n<h2>什么是Fiber</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">Fiber是一个轻量级的Golang Web框架。</p>\n<h2>什么是Fiber Starter</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">不同于Java Web开发，开始一个Golang Web框架是很繁琐的，你需要: 设计目录结构、制作许多简单但繁琐的小工具..........如果项目更复杂些，你还需要: docker、docker-compose、make......... 这个初始化的过程往往耗费时间。为了解决这个问题，我把自己的起手模板稍微修改了下，并公开到Github：<a href=\"https://github.com/Redish101/fiber-starter\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">Redish101/fiber-starter</a>，帮助大家解决这个问题。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">这个项目包含了基于Git的版本信息获取，Make构建、Docker&amp;Docker Compose、CLI等实用的功能。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { remark } from \"remark\";\nimport html from \"remark-html\";\n\nexport default async function markdownToHtml(markdown: string) {\n  const result = await remark().use(html).process(markdown);\n  return result.toString();\n}</code></pre>\n<pre class=\"\"><code class=\"\">XHU4YmY3XHU1NzI4XHU2M2E3XHU1MjM2XHU1M2YwXHU2MjY3XHU4ODRjXHUwMDZiXHUwMDY1XHUwMDc5XHU1MWZkXHU2NTcw</code></pre>\n<h2>项目目录结构</h2>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">├── Makefile # Make配置文件(本项目使用Make管理构建)\n├── bin # 构建输出目录\n│   └── fiber-starter\n├── cmd # CLI\n│   ├── root.go\n│   └── server.go\n├── config # 一些配置文件\n│   ├── app.go # 应用程序相关\n│   └── version.go # 版本信息，会在构建时通过Git获取\n├── docker-compose.yml # Docker Compose 配置文件\n├── dockerfile # Dockerfile\n├── go.mod\n├── go.sum\n├── internal # 核心部分\n│   ├── handler # handler\n│   │   └── home.go # 默认的demo\n│   ├── server # 服务器相关操作\n│   │   ├── route.go\n│   │   └── server.go\n│   └── utils # 零碎的小工具\n│       └── res.go # 格式化相应\n└── main.go</code></pre>\n<h2>如何使用</h2>\n<h3>准备工作</h3>\n<ul>\n<li>能够熟练使用ide进行查找与替换</li>\n<li>基本的Git使用经验</li>\n<li>Github账号</li>\n<li>Make(本项目使用Make管理构建，所有构建操作请使用Make执行，否则可能会出现许多问题)</li>\n</ul>\n<h3>获取代码</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">Github提供了方便的模板功能，进入本项目<a href=\"https://github.com/Redish101/fiber-starter\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"link.tsx\">仓库</a>，点击右上角的 <code>Use this template</code></p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230416152822.png\" alt=\"image-20230416152821767\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">点击 <code>Create a new repository</code>，在接下来的页面内更改仓库信息，完成后，点击下方 <code>Create repository from template</code>。</p>\n<h3>修改信息</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">你需要在修改这几个文件，完成初始化:</p>\n<h4>Makefile</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">修改文件开头的部分变量:</p>\n<ul>\n<li>APP_NAME 应用程序名称</li>\n<li>PKG_NAME 包名</li>\n<li>BIN_NAME 构建输出路径</li>\n</ul>\n<h4>go.mod</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">修改第一行的包名，与上一步在Makefile中设置的一致。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">修改包名后，你需要使用ide的替换功能，将目录内所有的 <code>github.com/Redish101/fiber-starter</code>替换为你修改的包名。</p>\n<h4>dockerfile</h4>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">如果不需要Docker，请忽略此项</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">将21行的 <code>/bin/fiber-starter</code>更改为在Makefile中设置的 <code>BIN_NAME</code>。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">修改最后一行的 <code>fiber-starter</code>，设置为在Makefile中设置的 <code>BIN_NAME</code></p>\n<h4>docker-compose</h4>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">如果不需要docker-compose，请忽略此项</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">根据需求更改。</p>\n<h4>internal/utils/res.go</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">根据需要，修改第五行的返回数据格式。</p>\n<h4>config/app.go</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">修改 <code>AppName</code>，可以选择性的删除后面的版本号。</p>\n<h3>开发</h3>\n<h4>Handler</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">handler应存放在 <code>internal/handler</code>，每个handler应该是这样的格式:</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">package handler\n\nimport (\n    \"github.com/Redish101/fiber-starter/internal/utils\"\n    \"github.com/gofiber/fiber/v2\"\n)\n\nfunc Home(c *fiber.Ctx) error {\n    return utils.Res(c, true, \"Fiber Starter成功启动\", nil)\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">其中 <code>utils.Res</code>函数是标准化响应工具，需要传入这几个参数：</p>\n<ul>\n<li>c handler的Ctx</li>\n<li>ok 操作是否成功</li>\n<li>msg 提示信息</li>\n<li>data 返回数据，可以为任何类型</li>\n</ul>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">完成后，应当在 <code>internal/server/route.go</code>中注册路由。在 <code>initRoutes</code>函数末尾增加路由注册代码，它看起来应该像这样：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">app.Get(\"/\", handler.Home)</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">其中 <code>\"/\"</code>为路径，<code>handler.Home</code>为Handler函数。</p>\n<h3>开发运行</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">运行 <code>make dev</code>。</p>\n<h3>开发构建</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">运行 <code>make build-debug</code>。使用本命令构建的可执行文件可以使用gdb进行调试，且版本号为 <code>dev-xxxxxx</code>。</p>\n<h3>生产构建</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">运行 <code>make all</code>。使用本命令构建的可执行文件不可以使用gdb进行调试，且版本号为最新的标签。</p>\n<h3>构建Docker镜像</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">运行 <code>make build-docker</code>。</p>\n<h2>结语</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">这篇文章就到这里了，如果觉得项目还不错的话就点点Star吧，谢谢了。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/fiber-starter#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1681600305}, {"title": "为我的网站添加深色模式", "author": "Redish101博客", "pubDate": "2023-03-28 13:06:55", "link": "https://blog.redish101.top/article/darkmode", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/darkmode\">https://blog.redish101.top/article/darkmode</a>\n</blockquote>\n<div>\n<h2>我们为什么需要「深色模式」</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">不可避免的，我们在很多时候需要在黑暗的环境下访问网站，而在黑暗的环境下，如果网站依然有大部分亮色区域，会在瞬间使眼睛受到刺激，极大的降低了用户体验。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">同时，深色模式能减少OLED屏幕的功耗，延长设备的使用时间这也是很多人在白天也依然打开深色模式的原因。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">如今，很多操作系统已经支持了深色模式，macos也提供了很好的深色模式支持。Chrome、FireFox等主流浏览器也已经支持通过 <code>prefers-color-scheme</code>单独定义深色模式下的样式，这也降低了我们制作深色模式的难度。</p>\n<h2>「深色模式」的切换逻辑</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">前面提到，我们可以通过 <code>prefers-color-scheme</code>来单独定义深色模式的样式，而 <code>prefers-color-scheme</code>是跟随系统的，显然，这种方式可以较好符合用户的个人喜好。</p>\n<h3>\n<code>prefers-color-scheme</code>的兼容问题</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">的确，<code>prefers-color-scheme</code>对于低版本的浏览器适配并不友好，但是考虑到本站用户群体，这种问题几乎不会发生(其实是我懒)，所以就没有做过多处理。</p>\n<h2>「深色模式」的前端实现</h2>\n<h3>单独编写样式</h3>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">body {\n  color: #000;\n}\n\n@media (prefers-color-scheme: dark) {\n  body {\n    color: #fff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">显然，这种方式繁琐且复杂。</p>\n<h3>使用CSS Variable</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本站的配色信息都是以CSS Variable的形式存放在一个单独的css(global.css)中的，并在其他的css文件中可以直接通过 <code>var(xxxx)</code>引用，所以，我们可以为深色模式和亮色模式设计两种配色，并通过第一种方法实现，就可以实现自动的深色模式切换。</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">:root {\n  --bg: #f2f5f8;\n  --card-bg: #fff;\n  --text: #000;\n  --link: #007bff;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --bg: #0d1117;\n    --card-bg: #161b22;\n    --text: #c9d1d9;\n    --link: #58a6ff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">本站就是用的这种方法，在你的系统设置中切换配色即可体验。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/darkmode#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1679980015}, {"title": "使用Next.js重构我的博客", "author": "Redish101博客", "pubDate": "2023-03-04 04:33:10", "link": "https://blog.redish101.top/article/blog-v5", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193114.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193416.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/blog-v5\">https://blog.redish101.top/article/blog-v5</a>\n</blockquote>\n<div>\n<h2>技术选型</h2>\n<h3>React VS Vue</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在这两者之间，我对React的使用更加熟练些，而且我认为使用TSX开发React应用的体验是愉悦的，所以选择React。</p>\n<h3>Gatsby VS Next.js</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">这两者都是十分优秀的React框架，但我一直无法成功配置Gatsby环境，而且考虑到应用以后可能使用服务端渲染，所以选择Next.js。</p>\n<h3>SSR VS SSG</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">博客目前并没有一些复杂的功能需要使用SSR实现，为了节省性能，选择了Next.js的SSG（以后会计划开发管理后台，所以以后可能会更换为SSR）。</p>\n<h2>UI设计</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">为了提高界面主题的美观，降低实现的难度，我设计了较为简单（简陋）的ui，并做了移动端适配，尽量让移动端的用户能有较好的体验。</p>\n<h2>内容管理</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">最开始，我准备效仿苏卡卡，使用hexo管理文章，但在进行一段时间的开发后，发现我对hexo api的了解无法满足使用。最后，我选择将文章储存为Markdown文件，并在每次更新后将其渲染为静态页面。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在众多Markdown渲染库中，我选择使用比较简单易用的 <code>remark</code>将markdown渲染为html：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { remark } from \"remark\";\nimport html from \"remark-html\";\n\nexport default async function markdownToHtml(markdown: string) {\n  const result = await remark().use(html).process(markdown);\n  return result.toString();\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">搞定正文的渲染，还有一个问题，由于并没有使用数据库文章信息，所以需要将文章信息放到 <code>front matter</code>内，再在构建时解析，转换为js能够读取的数据格式，并储存到页面的 <code>props</code>中，供前端使用。在处理 <code>front-matter</code>中，我选择了 <code>gray-matter</code>。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在读取Markdown并处理后，需要将文章数据传递给前端，供前端使用，但我并没有使用SSR，所以无法做到获取实时的文章数据，但得益于强大的Next.js，我们可以通过 <code>getStaticProps</code>，<code>getStaticPaths</code>在执行构建时获取数据，储存到props中，例如文章详情页的数据可以这样获取：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">export async function getStaticPaths() {\n  const posts = getAllPosts([\"slug\"]);\n\n  return {\n    paths: posts.map((post) =&gt; {\n      return {\n        params: {\n          slug: post.slug,\n        },\n      };\n    }),\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }: any) {\n  const post = getPostBySlug(params.slug, [\"title\", \"date\", \"slug\", \"content\"]);\n  const content = await markdownToHtml(post.content || \"\");\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content,\n      },\n    },\n  };\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">这样在前端就可以十分方便的使用数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default function Post(props: props) {\n  const router = useRouter();\n  const post = props.post;\n  const title = `${post.title} | Redish101 Blog`;\n  if (!router.isFallback &amp;&amp; !post?.slug) {\n    return &lt;Error404 /&gt;;\n  }\n  return (\n    &lt;&gt;\n      &lt;Head&gt;\n        &lt;title&gt;{title}&lt;/title&gt;\n      &lt;/Head&gt;\n      &lt;PostBody title={post.title} date={post.date} content={post.content} /&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<h2>样式实现</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在众多css in js库中，我选择了 <code>griffel</code>，它可以自动生成随机的类名，对于我这种起名困难党算是个福音，其次，它使用起来也十分的顺畅，只需要使用 <code>makeStyles()</code>定义样式，即可通过 <code>useStyles()</code>使用样式。使用它定义样式，在编码过程中ide会给出效果较好的代码提示：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193114.png\" alt=\"\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在开发的过程中节约了很多时间，生成的随机类名可以很好的避免类名重复导致的错误：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193416.png\" alt=\"\"><h2>一言</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在新版博客的首页，我将原来固定的副标题替换为从一言api获取一句质量较高的话作为副标题，数据的获取与文章数据的获取一样，都使用 <code>getStaticProps</code>在构建时获取，所以一言的更新频率完去取决于我的更新频率。</p>\n<h2>部署</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">网站的部署有以下几个选择：服务器部署，vercel，netlify。前面说过，本站是静态网站，所以如果选择服务器部署，在每次内容更新后都需要上传到服务器，浪费时间，即使使用ci，服务器由于地域原因也无法从GitHub拉取网站源码进行构建，所以率先出局。在vercel和netlify中我选择vercel，一是使用熟练，二是对Next.js有较好的支持，若是以后更改为ssr也很方便。</p>\n<h2>重构博客给我带来了什么</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">Nextjs SSG网站的性能明显是要好于动态博客的，而且构建速度也比之前用Hexo的时候更快。而且自己造的轮子，自己肯定更熟悉，改起来也方便。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/blog-v5#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1677875590}, {"title": "非4k显示器开启hidpi", "author": "Yume.KISEKI", "pubDate": "2023-02-11 04:29:27", "link": "https://www.monoko.jp/enable-hidpi/", "description": "\n<p>macOS想要完美体验hidpi只能是换上4k及以上显示器，如果用上苹果自家的6K Pro Display X […]</p>\n<p><a href=\"https://www.monoko.jp/enable-hidpi/\">非4k显示器开启hidpi</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "BetterDisplay", "hidpi", "macOS"], "time": 1676060967}, {"title": "Pro App 教育套装", "author": "Yume.KISEKI", "pubDate": "2023-02-02 14:24:50", "link": "https://www.monoko.jp/pro-app/", "description": "\n<p>一个Final Cut Pro多少钱？是1998元 一个教育优惠套装多少钱？是1298元(前几年是1543元) […]</p>\n<p><a href=\"https://www.monoko.jp/pro-app/\">Pro App 教育套装</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "Apple教育优惠", "Final Cut Pro"], "time": 1675319090}, {"title": "windows手动安装哪吒探针客户端", "author": "wututu-blog", "pubDate": "2023-01-30 18:30:31", "link": "https://blog.wututu.cn/nztz-for-windows/", "description": "以针会友，几乎成了吃灰服务器的标配行为，得益于最近火起来的哪吒探针，我也搭建了自己的探针平台，数据直观且美观，兼具实用与装 13特 ...", "categories": ["未分类"], "time": 1675074631}, {"title": "网站迁移完成，如有BUG欢迎留言", "author": "wututu-blog", "pubDate": "2023-01-30 18:04:37", "link": "https://blog.wututu.cn/gx/", "description": "", "categories": ["未分类"], "time": 1675073077}, {"title": "一款好用的摄影包——Bellroy Venture Sling 10L", "author": "Yume.KISEKI", "pubDate": "2023-01-15 13:40:21", "link": "https://www.monoko.jp/bellroy-venture-sling-10l/", "description": "\n<p>终于还是灭门了佳能，转而马上投入大法的怀抱，真香。话说都2023年了确实早已是无反的时代了，还好我的5d4和它 […]</p>\n<p><a href=\"https://www.monoko.jp/bellroy-venture-sling-10l/\">一款好用的摄影包——Bellroy Venture Sling 10L</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "Bellroy"], "time": 1673761221}, {"title": "解决acme.sh签发SSL证书失败", "author": "Yume.KISEKI", "pubDate": "2022-12-18 04:39:26", "link": "https://www.monoko.jp/create-ssl-with-acme-sh/", "description": "\n<p>前段时间在甲骨文云成功开了台arm的机器后一直闲置没用，最近看到甲骨文云开始有回收清理白嫖机器的动作了，吓得我 […]</p>\n<p><a href=\"https://www.monoko.jp/create-ssl-with-acme-sh/\">解决acme.sh签发SSL证书失败</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["vps", "acme.sh"], "time": 1671309566}, {"title": "「古典文法」推量系の助動詞の関係性", "author": "Yume.KISEKI", "pubDate": "2022-12-04 07:34:51", "link": "https://www.monoko.jp/suiryokei-no-jyodoushi/", "description": "\n<p>不难发现在助动词中有那么一堆词都带有推定的意思，我们可以称之为推量系助动词，对于这些词之间的关系总结如下图，可 […]</p>\n<p><a href=\"https://www.monoko.jp/suiryokei-no-jyodoushi/\">「古典文法」推量系の助動詞の関係性</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["古典文法", "助动词", "推量系", "日语古文"], "time": 1670110491}, {"title": "好用的ssh客户端工具—electerm", "author": "Yume.KISEKI", "pubDate": "2022-11-30 14:13:22", "link": "https://www.monoko.jp/ssh-electerm/", "description": "\n<p>前段时间偶然发现一款开源ssh客户端——electerm，三大平台全能型，多语言支持，支持sftp并且能直接编 […]</p>\n<p><a href=\"https://www.monoko.jp/ssh-electerm/\">好用的ssh客户端工具—electerm</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["software", "electerm"], "time": 1669788802}, {"title": "异常低价的CleanMyMac X", "author": "Yume.KISEKI", "pubDate": "2022-11-20 02:30:00", "link": "https://www.monoko.jp/low-price-of-cleanmymac/", "description": "\n<p>近期需要用到笔记本电脑一段时间，也就突然想到还有台14款的mbp正好可以拿来用段时间，系统是一代代升级到了最终 […]</p>\n<p><a href=\"https://www.monoko.jp/low-price-of-cleanmymac/\">异常低价的CleanMyMac X</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["software", "CleanMyMac X"], "time": 1668882600}, {"title": "遭遇xmrig挖矿病毒", "author": "Yume.KISEKI", "pubDate": "2022-10-21 15:39:10", "link": "https://www.monoko.jp/cryptojacking-xmrig/", "description": "\n<p>起因 前段时间conoha为纪念突破50万用户大搞活动，看着优惠力度和近期的日元汇率是真的香！但太久没用con […]</p>\n<p><a href=\"https://www.monoko.jp/cryptojacking-xmrig/\">遭遇xmrig挖矿病毒</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["vps", "xmrig"], "time": 1666337950}, {"title": "Linux/Windows系统安装最新版JAVA教程", "author": "wututu-blog", "pubDate": "2022-10-18 18:00:18", "link": "https://blog.wututu.cn/linux-windows-install-java/", "description": "<div class=\"wp-block-jetpack-markdown\">\n<h2>说明</h2>\n<p>我们很多时候都需要用到JAVA环境，这里博主就记录下安装过程。</p>\n<h2>1、获取最新版JAVA下载链接</h2>\n<p>首先进入JAVA下载地址：点击进入，再点击中间框框右下角的<code>JDK Download</code>按钮进入下载界面，然后点击<code>Accept License Agreement</code>，这时候就可以点击一下对应版本的<code>JAVA JDK</code>包，浏览器下载器会弹出来文件下载，这时候就可以复制下载链接了。\n注意别直接将<code>jdk</code>包的超链接当成下载链接，这样下载会出错的。</p>\n<h2>2、Linux安装</h2>\n<p>这里<code>CentOS</code>、<code>Debian</code>、<code>Ubuntu</code>等常见Linux系统都可以用以下方法安装JAVA。</p>\n<pre><code>#下载JAVA JRE包，将你获取的链接替换到后面，下载链接通常为http://xx/jdk_linux-x64.tar.gz?AuthParam=xx\nwget -O jdk.tar.gz http://xx/jdk_linux-x64.tar.gz?AuthParam=xx\n#解压文件\ntar -zxvf jdk.tar.gz\n#记住这时候解压出的文件夹路径，比如目前为/root/jdk1.8.0_191\n</code></pre>\n<p>编辑<code>/etc/profile</code>文件：</p>\n<pre><code>编辑/etc/profile文件：\n</code></pre>\n<p>在后面添加以下代码：</p>\n<pre><code>#前2行后面的参数为解压出的JAVA文件夹路径\nJAVA_HOME=/root/jdk1.8.0_191\nexport JRE_HOME=/root/jdk1.8.0_191/jre \nexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH \nexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH\n</code></pre>\n<p>使配置生效：</p>\n<pre><code>source /etc/profile\n</code></pre>\n<p>查看JAVA版本：</p>\n<pre><code>java -version\n</code></pre>\n<h2>3、Windows系统安装</h2>\n<p>获取JAVA JRE包的方法参考上面，然后直接下载Win版本的点击安装即可。</p>\n</div>", "categories": ["教程", "软件"], "time": 1666087218}, {"title": "Linux VPS一键添加/删除Swap虚拟内存", "author": "wututu-blog", "pubDate": "2022-10-17 17:55:42", "link": "https://blog.wututu.cn/linux-vps-swap/", "description": "\n<div class=\"wp-block-jetpack-markdown\">\n<h2>脚本</h2>\n<p>提示：脚本不支持<code>OpenVZ</code>架构，安装会自动退出。\n运行命令：\n国外机器</p>\n<pre><code>wget https://cdn.jsdelivr.net/gh/wututua/file@master/swap.sh &amp;&amp; bash swap.sh\n</code></pre>\n<p>国内机器</p>\n<pre><code>wget https://gitee.com/wututua/file-storage-warehouse/raw/master/swap.sh &amp;&amp; bash swap.sh\n</code></pre>\n<p>然后根据选项进行操作，记得添加<code>swap</code>的时候填写纯数字，默认单位为<code>M</code>。</p>\n</div>\n\n\n\n<figure class=\"wp-block-image size-large\"><img data-recalc-dims=\"1\" decoding=\"async\" src=\"https://i0.wp.com/cdn.jsdelivr.net/gh/wututua/image%40master/img/swap_add.png?w=640&amp;ssl=1\" alt=\"\"></figure>\n", "categories": ["未分类"], "time": 1666000542}, {"title": "主流 Markdown 编辑器推荐", "author": "wututu-blog", "pubDate": "2022-10-16 17:54:57", "link": "https://blog.wututu.cn/markdown/", "description": "开头 Markdown ，2004年由 John Gruberis 设计和开发，是一种可以使用普通文本编辑器编写的标记语言，通过简 ...", "categories": ["软件"], "time": 1665914097}, {"title": "iptables一键配置端口转发脚本，支持tcp和udp", "author": "wututu-blog", "pubDate": "2022-10-15 17:50:01", "link": "https://blog.wututu.cn/iptables/", "description": "<div class=\"wp-block-jetpack-markdown\">\n<h2>iptables</h2>\n<p>iptables是一款非常强大的防火墙管理工具，同样支持端口转发，同时也支持端口段转发。上一篇文章使用iptables进行端口转发配置对于小白非常不友好，自然在网络上面找到了一键脚本，对小白非常友好，可视化的UI配置界面。</p>\n<h2>系统要求</h2>\n<p>支持Centos / Debian / Ubuntu 14.04 +\n推荐 Debian / Ubuntu，这个是我一直使用的系统，我的脚本在这个系统上面出错率最低。\nCentOS 7 默认的防火墙是 firewall，要使用本脚本，请先卸载或关闭 firewall 服务器，并安装 iptables 全套软件。</p>\n<h2>安装说明</h2>\n<p>下载iptables一键配置端口转发脚本，并赋予执行权限运行</p>\n<pre><code>wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/iptables-pf.sh &amp;&amp; chmod +x iptables-pf.sh &amp;&amp; bash iptables-pf.sh\n</code></pre>\n<p>下载并运行脚本后，先选择 1. 安装 iptables ，会检测是否安装 iptables 同时也会进行 iptables 防火墙开机启动加载等配置。</p>\n<h2>使用方法</h2>\n<pre><code>./iptables-pf.sh\n</code></pre>\n<p>运行脚本后，会显示菜单：</p>\n<pre><code>iptables 端口转发一键管理脚本 [vx.x.x]\n \n-- Toyo | doub.io/wlzy-20 --\n \n0. 升级脚本\n \n————————————\n \n1. 安装 iptables\n \n2. 清空 iptables 端口转发\n \n————————————\n \n3. 查看 iptables 端口转发\n \n4. 添加 iptables 端口转发\n \n5. 删除 iptables 端口转发\n \n————————————\n</code></pre>\n<p>注意：初次使用前请请务必执行 1. 安装 iptables(不仅仅是安装)\n请输入数字 [0–5]:\n选择 <code>4. 添加 iptables</code> 端口转发 后，会提示你依次输入 欲转发IP、欲转发端口、本地监听端口、本地IP、转发类型：</p>\n<pre><code>(默认端口: 10000-11000):\n \n本地监听端口 : 10000-11000\n \n请输入 本服务器的 公网IP网卡IP(注意是网卡绑定的IP，而不仅仅是公网IP，回车自动检测):\n \n本服务器IP : 1.1.1.1\n \n请输入数字 来选择 iptables 转发类型:\n \n1. TCP\n \n2. UDP\n \n3. TCP+UDP\n \n(默认: TCP+UDP):\n \n——————————————————————————————\n \n请检查 iptables 端口转发规则配置是否有误 !\n \n本地监听端口 : 10000-11000\n \n服务器 IP : 2.2.2.2\n \n欲转发的端口 : 10000-11000\n \n欲转发 IP : 1.1.1.1\n \n转发类型 : TCP+UDP\n \n——————————————————————————————\n</code></pre>\n<p>最后会提示你确认配置是否有误，如果没有问题就按任意键继续，启动成功后就会提示：</p>\n<pre><code>——————————————————————————————\n \niptables 端口转发规则配置完成 !\n \n本地监听端口 : 10000:11000\n \n服务器 IP : 1.1.1.1\n \n欲转发的端口 : 10000:11000\n \n欲转发 IP : 2.2.2.2\n \n转发类型 : TCP+UDP\n \n——————————————————————————————\n</code></pre>\n<p>选择 <code>3. 查看 iptables 端口转发</code> 后，会显示如下：</p>\n<pre><code>当前有 2 个 iptables 端口转发规则。\n \n1. 类型: tcp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000\n \n2. 类型: udp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000\n</code></pre>\n<p>选择 <code>5. 删除 iptables 端口转发</code> 后，也会显示列表，然后让你选择 要删除的端口转发规则序号。\n就这些啦</p>\n</div>", "categories": ["教程"], "time": 1665827401}, {"title": "Navicat Premium 12安装教程(完整激活版)", "author": "wututu-blog", "pubDate": "2022-10-14 17:49:00", "link": "https://blog.wututu.cn/navicat-premium-12/", "description": "开始 本文所有文件下载 下载地址1 下载地址2 1.安装 1.双击安装，点击下一步： 2.同意协议，点击下一步： 3.选择安装位置 ...", "categories": ["破解"], "time": 1665740940}, {"title": "Navicat Premium 15安装教程(完整激活版)", "author": "wututu-blog", "pubDate": "2022-10-08 17:45:00", "link": "https://blog.wututu.cn/navicat-premium-15/", "description": "写在前面 之前一直忙着工作，趁着休假，加上身边的小伙伴想尝鲜一把最新版的Navicat Premium 15，官网说，最新一版的N ...", "categories": ["未分类"], "time": 1665222300}, {"title": "Github Codespaces初体验", "author": "Redish101博客", "pubDate": "2022-06-10 10:52:04", "link": "https://blog.redish101.top/article/github-codespaces", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610210634.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610211120.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/github-codespaces\">https://blog.redish101.top/article/github-codespaces</a>\n</blockquote>\n<div>\n<h1>这是什么</h1>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在去年，GitHub上线了一个的新功能：<code>Codespaces</code>，使用Codespaces可以随时随地在浏览器里编辑、调试、运行托管在GitHub的代码。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">在前几天，GitHub将此功能开放公测，任何用户都能申请使用，我，于是就有了这篇文章。</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610210634.png\" alt=\"邮件\"><h1>性能</h1>\n<h2>硬件配置</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">先说性能，GitHub面对个人项目提供了一台4Cores 8RAM的设备，这性能对于普通的开发那是绰绰有余，话不多说，上bench截图：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610211120.png\" alt=\"测试结果\"><h2>网络</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">配置虽好值得夸赞，但这网络之遭也十分的影响使用，在笔者试用的时候，2个小时中断线了将近十次。虽然大部分时间下编辑器的使用没有发现明显卡顿，但终端在使用时的卡顿是真的让人无法忍受。</p>\n<h2>终端相关</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">Github Codespaces的终端是可以通过 <code>sudo su</code>进入root用户的，也可以直接通过 <code>sudo</code>命令来运行需要root权限的服务。</p>\n<h2>自动休眠</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">这是非常重要的一个点，是我们白嫖之路的最大绊脚石，在一段时间（暂未明确结果）内如果编辑器没有活跃，codespace就会自动关闭。</p>\n<h1>写代码</h1>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">Codespaces使用了web版本的VS Code，所以说编辑体验是与直接在本地使用Code编辑并无不同，经过测试，也能完美的适配各种插件。运行时方面也无需担心，已经自动预装了docker、python、node、c/cpp等大部分语言的开发环境。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"paragraph.tsx\">同时，如果在终端里启动程序的开发服务器时编辑器会自动发现开放的端口并映射到公网，默认是私有的，只有codespace的所有者才能访问，但是可以在图中的这个位置中更改穿透为对外公开，但是101奉劝各位早点死了用这个搭建什么服务的心吧，同GitHub一样，几乎是无法访问，在速度这方面，甚至比不上GitHub Pages。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/github-codespaces#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1654829524}, {"title": "你问我答 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-05-25 14:28:40", "link": "https://www.594594.xyz/2022/05/25/xqa/", "description": "<p>一个适用hoshinobot的你问我答插件</p>", "categories": ["hoshino插件", "功能拓展"], "time": 1653460120}, {"title": "适用小白的快速搭建QQ机器人的超详细教程(可选带马娘插件)2023-10-13更新", "author": "轻音时雨的博客", "pubDate": "2022-03-05 03:10:37", "link": "https://www.594594.xyz/2022/03/05/uma_bot/", "description": "<p>适用小白的快速搭建一个QQ机器人(可选带马娘插件)</p>", "categories": ["游戏相关", "教程", "赛马娘"], "time": 1646421037}, {"title": "马娘功能插件整合版v2.0.1 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-03-04 07:36:40", "link": "https://www.594594.xyz/2022/03/04/uma_plugin/", "description": "<p>一个适用hoshinobot的马娘功能插件整合版</p>", "categories": ["hoshino插件", "赛马娘"], "time": 1646350600}, {"title": "赛马娘模拟抽卡 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-02-05 03:43:40", "link": "https://www.594594.xyz/2022/02/05/uma_gacha_for_hoshino/", "description": "<p>一个适用hoshinobot的赛马娘模拟抽卡插件</p>", "categories": ["hoshino插件", "赛马娘"], "time": 1644003820}, {"title": "ZeroTier One搭建MOON服务器", "author": "轻音时雨的博客", "pubDate": "2022-02-03 03:30:40", "link": "https://www.594594.xyz/2022/02/03/moon_for_zerotier/", "description": "<p>完美解决Tabletop等和好友P2P联机延迟高的解决办法及相关踩坑</p>", "categories": ["游戏相关"], "time": 1643830240}, {"title": "早安晚安 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:16:12", "link": "https://www.594594.xyz/2021/10/24/good_morning_for_hoshino/", "description": "<p>一个适用hoshinobot的 早安晚安 插件</p>", "categories": ["hoshino插件", "pcr"], "time": 1635016572}, {"title": "pcr签到黄历 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:09:12", "link": "https://www.594594.xyz/2021/10/24/pcr_almanac_for_hoshino/", "description": "<p>一个适用hoshinobot的 pcr签到黄历 插件</p>", "categories": ["hoshino插件", "pcr"], "time": 1635016152}, {"title": "mc数据查询监控 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:00:12", "link": "https://www.594594.xyz/2021/10/24/mc_status_for_hoshino/", "description": "<p>一个适用hoshinobot的 mc数据查询监控 插件</p>", "categories": ["hoshino插件", "mc"], "time": 1635015612}, {"title": "github仓库更新提醒 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-08-23 04:00:12", "link": "https://www.594594.xyz/2021/08/23/github_reminder_for_hoshino/", "description": "<p>一个适用hoshinobot的 github仓库更新提醒 插件</p>", "categories": ["hoshino插件", "github"], "time": 1629662412}]