[{"title": "尊贵的 Tesla 车主 +1", "author": "林木木的博客", "pubDate": "2025-01-19 11:48:13", "link": "https://immmmm.com/hi-tesla-2025/", "description": "\n<p>上周 Model Y 焕新款终于官宣，细看了几分钟，旋即下了 Model 3 ，今日已成为“尊贵”的特斯拉车主。</p>\n<p>与之前的焕新款 3 相比：</p>\n<ul>\n<li>25年贵了3600</li>\n<li>电池增加到 62.5 度，原来是 60 度</li>\n<li>能以 ¥1299 购买赛博家用充电桩，原来要 ¥5200</li>\n</ul>\n<p>然后，若是旧车置换的话能试用 90 天的 EAP（增强版自动辅助驾驶）。</p>\n<h3>溜车三天杂记（1月23日）</h3>\n<h4>满电表显 458km，挺准</h4>\n<p>这几天市区道路+高架+高速累计已开 300km+，能耗在 137kw/h 。</p>\n<p>按照公式 62.5 度电 ÷ 137 能耗 x 1000 ≈ 456km，一次充电，满足一周上下班，够够的。</p>\n<p>家充 7kw，谷电 3 毛/度，一杯普通奶茶，一晚，满电。美滋滋。</p>\n<p>看别人发着，超充或第三方，50 几分钟可满电，算 2 元/度，一百来块钱，一小时，满电。还可以。</p>\n<h4>AP/EAP，上高架高速，好使</h4>\n<p>置换送了 90 天的 EAP，相比免费的 AP 多了“召唤”、“自动泊车”、“高速自动换道”和“高速自动进匝道”等。而 AP 只有车道保持，即“跟车”。</p>\n<p>虽然已落后国内的“智驾”，但其是纯视觉方案，想想，还是佩服！若经常高架高速，若 EAP 不是 3万2 而是 3千2，那还是非常值得开通的。</p>\n<p>有一点挺难受，两者都是保持车道居中，但很多人习惯于车道靠左一些，包括我自己。右侧是一辆大车且快贴着线时，感觉压力山大。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2025/01/IMG_8167.JPEG\" alt=\"\"></p>\n<h3>一人一车，磨合一小时</h3>\n<h4>优点</h4>\n<ul>\n<li>星空灰还对眼，既没有土灰的感觉，也没有纯黑那么刚硬的感觉。</li>\n<li>动力是杠杠的，没啥感觉没几秒就上了 80+ 码，找了找车机开启了超速“蜂鸣”提醒。</li>\n<li>隔音效果、车内震动优于预期，没有网上说的那么差。</li>\n<li>与 iOS 搭配，更可餐。锁屏、桌面、快捷小组件应有尽有。就等新系统推送，还能用 iWatch 控制。</li>\n</ul>\n<h4>缺点</h4>\n<ul>\n<li>新车味重，闻着晕。</li>\n<li>前排座位硬，怎么调都不舒服；后排空间小，做做小朋友还行。</li>\n<li>后车镜怎么调都难受，倒车拐弯盲区仍不少，没有 360 车身四周影像。</li>\n</ul>\n<h3>下单到提车，行云流水线</h3>\n<ul>\n<li>上周日晚 8 点，找了个客户经理，下定金 ¥1000。</li>\n<li>周一拉群，确认当地提车上牌，预计一周后（即今天）可提车。</li>\n<li>周二旧车置换官方合作方，上门验车估价签协议，立马收到 ¥1000 定金；虽老车已经符合报废补贴，但二手车估出来还值 1W1，这样加上后续的置换国补 1W5，比直接报废划算。</li>\n<li>同步，五年免息招行开启车贷申请流程。周三招行上门面签，周四贷款通过，同步 APP 里付了尾款 ¥79500，银行经理说贷个取个整 15W5，所以首付多付了些。</li>\n<li>同步，家用充电桩拉群，周三现场勘探后，确认方案。自己在国家电网上申请新电表，修改为新能源类型并开通峰谷电。</li>\n<li>周六，官方 App 内给车上好保险，选择周日也就是今天 0 点生效，太平洋保险基础套餐 ¥9013。</li>\n<li>今天，顺利提车，店内 0 消费，未延保，未买窗膜。</li>\n</ul>\n<h3>没日没夜，买了一堆软装</h3>\n<h4>山姆</h4>\n<ul>\n<li>腰靠、头靠两对 ¥245</li>\n</ul>\n<h4>YZ 牌</h4>\n<ul>\n<li>门槛条 4 件套 ¥156</li>\n<li>手套箱挂钩 ¥11.5</li>\n<li>通风口防尘网、后排空调出风口保护罩 ¥26.6</li>\n<li>后排空调下储物垃圾盒 ¥75.2</li>\n<li>中控储物收纳盒 ¥30</li>\n<li>补胎千斤顶支持 ¥20</li>\n<li>门锁保护扣 ¥15.7</li>\n<li>后排椅子下防踢垫板 ¥27.5</li>\n</ul>\n<h4>3M 牌</h4>\n<ul>\n<li>3M 屏下中控磁吸储物盒 ¥126</li>\n<li>3M 车头进风口防虫网 ¥109</li>\n</ul>\n<h4>小特叔叔车品</h4>\n<ul>\n<li>中控拓展坞，点烟器取电款 ¥108</li>\n<li>车门储物盒 x4，¥91.3</li>\n<li>碳纤纹车牌架 ¥70.2</li>\n<li>屏幕保护条 ¥8.3</li>\n<li>无线充软硅胶垫 ¥14.2</li>\n<li>后备箱垫 ¥63.7</li>\n<li>后备箱侧边储物盒 ¥54.4</li>\n</ul>\n<p>另外，买的刹车踏板扣到指甲开裂，仍安装失败，差评！还有中控水杯垫，毛胚就卡得够紧，多余。</p>\n<p>哦，找的客户经理私下送了脚垫，但还在路上。</p>\n<h3>感叹</h3>\n<p>副驾边的铭牌，生产日期 <code>2025年1月15日</code>，上周日 12 号晚下单，车子这周三下线，周日交付到车主手上。</p>\n<p>充值信仰，还看老马！</p>\n", "categories": ["%E6%97%A5%E5%B8%B8"], "time": 1737258493}, {"title": "浏览器插件推荐：AI Share Card 生成网页分享卡片", "author": "林木木的博客", "pubDate": "2025-01-06 15:17:22", "link": "https://immmmm.com/ai-share-card/", "description": "\n<p>一款 AI 网页分享卡片生成小工具，利用 AI 将网页内容一键转换为精美的分享卡片。</p>\n<p>真是万物皆可卡片，看到支持自定义模板，所以又折腾了一晚。</p>\n<p>但，好像也没啥大用…… 那就，玩呗～</p>\n<h3>上效果对比图（左为默认样式）</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.edui123.com/2025/01/Picsew_20250107195720.JPEG.webp\" alt=\"\"></p>\n<h3>自定义模版代码分享</h3>\n<p>两个 import 分别是来源 SVG 图标，自定义字体。</p>\n<pre tabindex=\"0\"><code>&lt;style&gt;\n@import url(https://r2.immmmm.com/via.css);\n@import url(https://static.zeoseven.com/zsft/7/main/result.css);\n.card{font-family:\"Zhuque Fangsong (technical preview)\"}\n\n.powered-by{visibility:hidden}\n.powered-by span{visibility:visible}\n#cardContainer,.card{width:380px!important}\n.card-wrapper{border-radius:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,.1),0 8px 10px -6px rgba(0,0,0,.1)}\n.card{font-weight:400;box-sizing:border-box;padding:28px;background:#fff;border-radius:20px}\n.header{color:#a6a6a6;height:24px;overflow:hidden}\n.product{font-style:italic}\n.product,h1.title{letter-spacing:.02em}\nh1.title{font-size:20px;font-weight:700;color:#2b2b2b;margin:4px 0 12px;line-height:1.5}\n.summary{background:#f8f9fc;padding:16px;border-radius:12px;margin-bottom:12px;font-size:15px;color:#2b2b2b;line-height:1.8;letter-spacing:.03em;box-shadow:inset 0 2px 4px 0 rgba(0,0,0,.06)}\n.points{margin-bottom:10px}\n.point{display:flex;align-items:flex-start;margin-top:12px;font-size:15px;color:#2b2b2b;padding:2px 0}\n.point:before{content:\"\";width:4px;height:4px;background:#287cf6;border-radius:50%;margin-top:10px;margin-right:6px;flex-shrink:0}\n.point:nth-last-child(-n+2){margin-right:100px}\n.qr-section{position:relative}\n#qrcode{width:76px;height:76px;border-radius:8px;padding:6px;background:#f8f9fc;border:1px solid #f5f5f5;position:absolute;bottom:0;right:0}\n#qrcode img{width:100%;height:100%;object-fit:contain}\n&lt;/style&gt;\n\n&lt;div class=\"card\"&gt;\n  &lt;div id=\"card-img\"&gt;&lt;/div&gt;\n  &lt;div class=\"header\"&gt;\n    &lt;span class=\"date\"&gt;{{DATE}} &lt;/span&gt; · &lt;span class=\"product\"&gt;{{QR_SUBTITLE}} &lt;/span&gt;\n  &lt;/div&gt;\n  &lt;h1 class=\"title\"&gt;{{TITLE}} &lt;span data-via=\"{{PLATFORM}}\"&gt;&lt;/span&gt;&lt;/h1&gt;\n  &lt;div class=\"summary\"&gt;\n    {{SUMMARY}}\n  &lt;/div&gt;\n  &lt;div class=\"points\"&gt;\n    {{#each POINTS}}\n    &lt;div class=\"point\"&gt;{{this}}&lt;/div&gt;\n    {{/each}}\n  &lt;/div&gt;\n  &lt;div class=\"qr-section\"&gt;\n    &lt;div id=\"qrcode\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt; \n</code></pre>\n<h3>相关站点记录</h3>\n<h4>官方介绍</h4>\n<ul>\n<li>主页 <a href=\"https://zkv549gmz8.feishu.cn/wiki/LPQEwSvUfiXgxckspzncGjOdnqe\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://zkv549gmz8.feishu.cn/wiki/LPQEwSvUfiXgxckspzncGjOdnqe</a>\n</li>\n<li>Chrome扩展 <a href=\"https://chromewebstore.google.com/detail/bfaolbpkelfmiijhdlcbflbpfpebepon\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://chromewebstore.google.com/detail/bfaolbpkelfmiijhdlcbflbpfpebepon</a>\n</li>\n</ul>\n<h4>来源 SVG 图标如下压缩：</h4>\n<ul>\n<li>获取图标 SVG 代码 <a href=\"https://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://www.iconfont.cn/</a>\n</li>\n<li>粘贴压缩并复制 <a href=\"https://jakearchibald.github.io/svgomg/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://jakearchibald.github.io/svgomg/</a>\n</li>\n<li>Encode 代码 <a href=\"https://meyerweb.com/eric/tools/dencoder/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://meyerweb.com/eric/tools/dencoder/</a>\n</li>\n</ul>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1736147842}, {"title": "2024年终总结", "author": "Redish101博客", "pubDate": "2024-12-29 11:32:59", "link": "https://blog.redish101.top/article/2024-summary", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://cdn.smartcis.cn/gh/redish101/cdn@src/img/postspark_export_2024-12-22_15-17-56.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412290927100.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291013292.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291018651.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741579.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741355.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291821543.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291929767.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291947480.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291953729.jpeg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292002652.jpg\">\n<link rel=\"preload\" as=\"image\" href=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292004463.jpg\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/2024-summary\">https://blog.redish101.top/article/2024-summary</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">2024年即将结束，在此总结一年中的功过荣辱以及值得记录或吐槽的事情、物品，并同时针对2025年进行总体规划。</p>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本文是针对已经完稿的年终总结部分能够公开发布的内容的节选，可能会有些地方前言不搭后语，如有错误，还请在评论指出。</p></blockquote>\n<h2>博客</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度对博客进行了大规模，长时间（从冬天到夏天）的重构，从去年七月Next.js SSG的方案转为Go(Fiber) + Next.js的前后端分离方案，使自己的Go能力更上一步，尝试规模稍微复杂些的项目的流程。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">具体详尽内容见<a href=\"https://www.notion.so/16b0d19ec45680f4998cfdc9afac1cd7?pvs=21\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">博客重构</a> 。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">今年认识了一个与SpringBoot类似风格的nodejs服务端框架（nestjs），可惜没有早点遇到，轻笑推荐的好好用，早知道的话reblog就用nest写了。</p>\n<h2>编程</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度基本着重于对reblog的开发，但经过一年的长时间拖延，reblog整体依然处于较简陋的状态，来年将对reblog进行进一步的完善，为reblog新增如下功能（优先级递减）：</p>\n<ol start=\"1\">\n<li>标签与分类</li>\n<li>即刻（类似于说说功能）</li>\n<li>评论</li>\n<li>友情链接朋友圈（文章聚合订阅）</li>\n<li>内置的AI支持（摘要、问答）</li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">同时，将考虑使用nestjs重构retalk项目。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">来年将将更多经历投入到的开发上。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">截至本文完成时，Redish101共在GitHub上产生了1047次提交，相比2023年约增长622%。</p>\n<img src=\"https://cdn.smartcis.cn/gh/redish101/cdn@src/img/postspark_export_2024-12-22_15-17-56.png\" alt=\"\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度共参与2个有效Pull Request：</p>\n<ol start=\"1\">\n<li><a href=\"https://github.com/umijs/umi/pull/12516\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">feat(create-umi): 为create-umi新增设置项目名称的步骤 #12516</a></li>\n<li><a href=\"https://github.com/gofiber/contrib/pull/1172\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">feat: Migrate Monitor Middleware #1172</a></li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">25年将着重对于以下领域的学习：</p>\n<ol start=\"1\">\n<li>Qt</li>\n<li>Nestjs</li>\n<li>OpenGL</li>\n<li>Vulkan</li>\n</ol>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">redish又在给自己挖坑了</p></blockquote>\n<h2>武汉</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">曾经出门的时候不止一次在火车上经过武汉，对于武昌火车站和长江大桥留下了深刻印象，再加上距离也不算很远，所以在24年二月初选择去武汉看看。</p>\n<h3>Day0</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">距离武汉并非十分遥远，便选择了乘火车（Z263硬座）前往。春节将至，凌晨三点钟的郑州站依旧灯火通明。列车缓缓驶出车站，前往武汉的旅途在窗外飞速后退的灯火旁拉开了帷幕。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">列车一路狂奔，天也蒙蒙亮了起来，但是天气似乎并不是十分晴朗，太阳在云层的遮挡下仅仅是撒下了些许白光。在无际的朦胧中，窗外的田野慢慢渐变到楼房。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">“前方到站——武昌站”。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412290927100.png\" alt=\"长江\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">随着人流下了车，正式踏入武汉的地界。</p>\n<h3>Day1</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">走出武昌火车站，外面正下着朦胧的小雨，冒着小雨到了粮道街。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">热干面！</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">既然到了武汉肯定是要尝尝热干面的。热干面还是蛮合胃口的，筋道的面条裹挟着浓郁的浆汁，很是美味（<del>看似一小份不过似乎很容易吃饱</del>）。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">吃过饭，便来到了武汉最著名的景点之一——黄鹤楼。</p>\n<blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">昔人已乘黄鹤去，此地空余黄鹤楼。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">黄鹤一去不复返，白云千载空悠悠。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">晴川历历汉阳树，芳草萋萋鹦鹉洲。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">日暮乡关何处是？烟波江上使人愁。</p>\n</blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">古往今来，数不尽的人登上黄鹤楼，感慨万千，吟诗作赋，给这座楼增添了许多文化气息。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">逐层登上黄鹤楼，苍茫朦胧的景色扑面而来。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291013292.jpeg\" alt=\"烟雨迷蒙的黄鹤楼下\"><img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291018651.jpeg\" alt=\"长江\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">下午去了辛亥革命纪念馆</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741579.jpeg\" alt=\"\"><img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291741355.jpg\" alt=\"\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">天色渐渐暗下来了，毕竟凌晨就起床，又累又饿的，便匆匆回了酒店。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">坐车到酒店附近，已是天昏地暗，浑身疲软。摸了下口袋，身份证不翼而飞。猛地惊醒，趁着公交尚未离开，狂奔了回去，抱着一丝希望想要从车上找到，可惜无果。回到房间，给博物馆的工作人员打了个电话，也并未有人找到。</p>\n<h3>Day2</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">上午去了古德寺。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">古德寺的建筑风格与我一般印象中的佛教寺院很不一样，没有红墙绿瓦，反倒是浓郁的异域风气。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291821543.jpeg\" alt=\"\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">雨水不大，微微拂面，给这建筑也衬上了一层静谧的气息。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">古德寺本身不大，没过多长时间就逛完了，便赶到湖北省博物馆附近。因为预约的是下午的场次，所以便准备先吃饭再前往博物馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">四周找寻好长时间，总算是走到小区附近找到了餐馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">吃过饭，排了好长时间队，总算进了博物馆。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">越王勾践剑展厅更是要排很长时间的队，排了好长时间进去后依然有很多人围到前面，身高又不占优势，甚至也没排到清楚的照片。</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291929767.jpeg\" alt=\"越王勾践剑\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">从博物馆出来后看到天色并非很晚，就在截止前一会预约了隔壁美术馆的门票。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><del>来都来了.jpg（逃）</del></p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">不过可能是我的眼光不足以欣赏，也可能阅历不够丰富吧，没有看懂什么。。。</p>\n<h3>Day3</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">第三天选择长途跋涉去了科技馆玩，见到了好多之前在北京看到的相似的设施。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">不过寒假的多选一作业里面：</p>\n<ol start=\"1\">\n<li>制造一枚核弹，并拍摄引爆视频；</li>\n<li>制造一台永动机；</li>\n<li>上传一张与牛顿或爱因斯坦的合照。</li>\n<li>…</li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">于是……</p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291947480.jpg\" alt=\"爱因斯坦！\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><del>太合理啦</del></p>\n<h3>Day4</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">第四天去了一个令我印象深刻的地方——五大旧址。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">曾经某次历史卷子曾给出了这里的图片，在学校“清晰”的印刷质量下已经是漆黑一片。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><del>所以，某种程度上的故地重游</del></p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">离开后时间还早，便前往晴川阁。</p>\n<blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">江上风烟望武昌，临江高阁晓苍苍。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">涛声八月蛟龙吼，霸气千秋草树荒。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">几点青山浮大别，一声残笛弄沧浪。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">自经崔颢题诗后，别是人间翰墨场。</p>\n</blockquote>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412291953729.jpeg\" alt=\"晴川阁望长江\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">由于下雪，（也许是雨夹雪，冻雨或者其他类似的各种东西），天气始终是朦胧的，迷蒙的，我很喜欢这种BSL（<del>白内障</del>）风格的氛围。远处楼影绰绰，淡墨色的长江大桥独跨江面。</p>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">忽如一夜春风来，千树万树梨花开。</p></blockquote>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292002652.jpg\" alt=\"千树万树梨花开\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><strong>徒步横跨长江！</strong></p>\n<img src=\"https://cdn1.tianli0.top/gh/redish101/cdn@src/reblog_imgs202412292004463.jpg\" alt=\"\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">走上了这座古朴的大桥，可能是风大，也可能单纯腿软，总觉得桥面在晃动。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">一不小心好险摔跤。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">还是小看了长江的长度，本以为能够步行过去后还能再徒步到酒店，看来还是高估自己了，最后依然选择坐地铁会酒店。</p>\n<h3>Day5</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">由于是上午的车，所以并没有去很远的地方，所以又去了一趟辛亥革命起义纪念馆，可惜身份证还是没找到。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">快到了回家的时候，走进武昌火车站，严峻的天气让诸多列车晚点，许多乘客滞留在候车厅，不过好在我们所乘坐的车次是从武昌火车站始发，而且有DF11G-0001/2的加持，列车依然正常出发。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">列车在风雪中奔驰，掠过楼房与田野。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">飞速的行驶并未成常态，在经过信阳附近时，开始了长时间的临时停车。（还好买的软座车票！）天逐渐黑了下来，腰酸背痛接踵而至，晚点了数小时后终于到了郑州站。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">深夜总算是回到家了，武汉之行也告一段落。</p>\n<h2>北京</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在七月份去了北京，内容较多，又考虑与以往在北京的经历串联起来写一篇文章，所以还是不放到年终总结里了吧（咕咕咕咕咕咕）。</p>\n<h2>来年旅行计划</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">重庆！重庆这座城市看起来确实是十分独特，可能会在明年春节前后前往。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">西安，南京也可能会在明年拜访。</p>\n<h2>A&amp;Q</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本年度也被人问了很多问题，这里集中回答下吧。</p>\n<h3>为什么叫redish，和redis有什么关系吗?</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">redish这个名字其实在很久之前（2020年之前）就已经取了，当时并不了解redis这一项目，取了这个名字。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">至于这个名字的含义？</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><strong>R</strong>obust and <strong>E</strong>fficient <strong>D</strong>istributed <strong>I</strong>ntelligent data <strong>S</strong>torage <strong>H</strong>andler</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><strong>强健且高效的分布式智能数据存储处理器</strong></p>\n<h3>为什么周末总是出门？</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">确实有些事情的，不要乱猜了）</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果还有其他问题，欢迎在评论里面说出来）</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">写到这里也差不多了，就这样吧，今年的文章似乎确实不是很多，明年一定狠狠的更新！</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/2024-summary#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1735443179}, {"title": "使用 Cursor 做了几个单页小工具", "author": "林木木的博客", "pubDate": "2024-12-21 03:13:43", "link": "https://immmmm.com/build-html-by-cursor/", "description": "\n<p>最大感受，说清楚需求，基本上第一次对话即可生成。之后都是叠加需求和反复修复的过程。</p>\n<p>最大感慨，需求是稀缺资源，真切合理的需求结合 AI，把之前根本不会想尝试，变为积极主动试一试。</p>\n<h3>由简到难的 24 点出题器</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-nqww.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-nqxm.png.webp\" alt=\"\"></p>\n<p>「24 点出题器」 <a href=\"https://edui123.com/24/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://edui123.com/24/</a></p>\n<p>把 1362 道有解的 24 点题目，依据难度排序，支持按序和随机出题，右上角有 30 秒倒计时，点击标题可查看解法。</p>\n<p>玩 24 点日常难受的点在于直接拿扑克牌玩，1820 个不同组合，而实际有解的只有 1362 个。1362/1820≈0.748≈75%，四局有一局无解，已经很打击兴趣咯。</p>\n<p>很早看到 <a href=\"https://www.4shu.net/game/difficulties/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">4数网</a> 经过难度排序的题库，基于世界各地的人们已经解决 6283289 个题目，计算了每道题目的 “统一中值解决时间”, 并从最简单到最难给这些题目排序。</p>\n<p>一拍即合，干活！</p>\n<h3>语文生字拼音匹配小游戏</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-npdd.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-npiy.png.webp\" alt=\"\"></p>\n<p>「认读小能手」 <a href=\"https://edui123.com/renzi/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://edui123.com/renzi/</a></p>\n<p>基于部编语文一年级上册“识字表”中的 280 字，给认读生字增加一点趣味互动性，家里或学校能在期末阶段用上一用。</p>\n<ul>\n<li>3 种模式可选：限时 1 分钟、3 分钟、不限时；</li>\n<li>拖动拼音到对应的汉字上方，右上角有实时的统计数据条。</li>\n<li>限时模型下，结束时会有统计数据汇总，还有过程中拖动错误的汉字记录回顾。</li>\n</ul>\n<h3>自动听写词语</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-nsoi.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241221-nsqr.png.webp\" alt=\"\"></p>\n<p>「词语听写」 <a href=\"https://edui123.com/tingxie\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">https://edui123.com/tingxie</a></p>\n<p>一个自动朗读语文书后“词语表”的在线网页。</p>\n<ul>\n<li>内置 3~6 年级上册词语，选择年级、第几课，点击开始即可；</li>\n<li>默认每个词语读两遍，不同词语停顿 3 秒（可拖动修改）；</li>\n<li>随机模式，全册词语打乱顺序 20 个为一组；</li>\n<li>早读模式，全册词语打乱顺序读完后会显示“词语”。</li>\n</ul>\n<h3>杂记</h3>\n<p>其实 3 个都是单页可离线的 html，听写后来改用第三方接口，因为发现 Edge 文字转语音国内不可用，能用也只能 PC 上，使用太受限。</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1734722023}, {"title": "Memos &amp; n8n ，秒接入 AI", "author": "林木木的博客", "pubDate": "2024-12-18 13:30:36", "link": "https://immmmm.com/get-ai-memos/", "description": "\n<p>Memos 0.18 还是哪个版本开始就支持 webhook ，一直不知道有啥用。自从折腾了 n8n，发现能连通，而且也自用有段时间。</p>\n<p>自动化流程思路是：接收 Memos Webhook，判断是新建事件，判断首行是否有 <code>触发词</code>，进入对应流程修改当前条笔记。</p>\n<h3>演示之一</h3>\n<p><code>a修改</code> 接内容，触发✌️</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-suku.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-supf.png.webp\" alt=\"\"></p>\n<h3>使用简要说明</h3>\n<p>安装 n8n 之后，下载 <a href=\"https://n8n.akashio.com/b121c42b66fe4963925baa70de007dd6\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Memos_v0_22_3__share.json</a>，其它版本需自行微调。</p>\n<h3>修改授权信息</h3>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-swwj.png.webp\" alt=\"\"></p>\n<h3>复制 Webhook 节点链接</h3>\n<p>粘贴到 Memos 设置 <code>偏好设置</code> 内。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-tdak.png.webp\" alt=\"\"></p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-teap.png.webp\" alt=\"\"></p>\n<h3>根据需要可修改触发词</h3>\n<p>基于正则匹配。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/SCR-20241218-swol.png.webp\" alt=\"\"></p>\n<h2>后记</h2>\n<p>拓展性极强，当日常使用次数极少，不太习惯……</p>\n<p>其它更多的拓展一个思路，对于有 webhook 或 api 接口，都能非常方便接入 n8n 做联动 💪</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1734499836}, {"title": "正在使用的 Docker 清单", "author": "林木木的博客", "pubDate": "2024-12-08 09:16:41", "link": "https://immmmm.com/my-docker-list/", "description": "\n<p>9 月底TX轻量云搞活动 ¥159x2 新开了 2C4G 机子，比起大几千的续费，便宜太多太多。</p>\n<p>试了试整站镜像备份还原，但被告知新机器的硬盘（70GB）比原来的（80GB）小，不行。</p>\n<p>搁置两月，趁着阴天降温宅家，花了一下午，迁移完毕。🎉</p>\n<h3><a href=\"https://github.com/soulteary/docker-flare\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Flare</a></h3>\n<p>超级轻量、快速、美观的个人导航页面，还支持前端编辑。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/flare-editor-beta.png.webp\" alt=\"\"><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/flare-ui.png.webp\" alt=\"\"></p>\n<h3><a href=\"https://github.com/Rock-Candy-Tea/hexo-circle-of-friends\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">友链朋友圈</a></h3>\n<p>古早博客功能，个人的首页调用和友圈都是基于此。</p>\n<p>刚发现后继有人，已经有了轻量版本。</p>\n<h3><a href=\"https://github.com/cooderl/wewe-rss\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">WeWe RSS</a></h3>\n<p>更优雅的微信公众号订阅方式。部署之后登录自己的微信读书账号，个人已稳定运行大半年。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/wewerss.png.webp\" alt=\"\"></p>\n<h3><a href=\"https://github.com/usememos/memos\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Memos</a></h3>\n<p>挺好的随记工具，但不兼容更新频繁，停留在 v0.18.2 安逸。博客首页调用、哔哔广场都基于此。</p>\n\n\n\n\n\t\n\n\n<div class=\"post-preview\">\n  <div class=\"post-preview--meta\">\n    <div class=\"post-preview--middle\">\n      <h4 class=\"post-preview--title\">\n        <a target=\"_blank\" href=\"https://immmmm.com/memobbs-app/\">哔哔广场.app</a>\n      </h4>\n      <time class=\"post-preview--date\">2024-01-21</time><small>#折腾 </small>\n      \n      <section class=\"post-preview--excerpt\">\n        基于 @归臧 的 Memos 样式和功能，在 @koobai 无限需求之下，连肝一周并败入域名解析之: https://memobbs.app/\n折腾核心动力：颜值在线！\n满足核心需求：Memos&amp;rsquo;er 共舞~\n\n      </section>\n</div>\n  </div>\n  \n    <img rel=\"link\" loading=\"lazy\" class=\"post-preview--image avatar\" src=\"https://r2.immmmm.com/2024/01/bbv3.png.webp\">\n</div>\n\n<h3><a href=\"https://github.com/twikoojs/twikoo\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Twikoo</a></h3>\n<p>一个简洁、安全、免费的静态网站评论系统。配置和评论数据迁移起来真方便。</p>\n<h3><a href=\"https://github.com/stilleshan/frps\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">stilleshan/frps</a></h3>\n<p>网穿透服务，原版怎么都不行，用这个分分钟搞定。</p>\n\n\n\n\n\t\n\n\n<div class=\"post-preview\">\n  <div class=\"post-preview--meta\">\n    <div class=\"post-preview--middle\">\n      <h4 class=\"post-preview--title\">\n        <a target=\"_blank\" href=\"https://immmmm.com/install-frp-record/\">迁移 FRP 记录</a>\n      </h4>\n      <time class=\"post-preview--date\">2024-11-10</time><small>#折腾 </small>\n      \n      <section class=\"post-preview--excerpt\">\n        （旧文重更：2024/11/10）\n服务器到期在即，迁移 FRP 小记，为了把家里的 书库 talebook 能无障碍在线使用。\n群晖拉起 frpc，服务器部署 frps，路由器端口转发，给个子域名解析，即可实现域名访问服务。\n\n      </section>\n</div>\n  </div>\n  \n    <img rel=\"link\" loading=\"lazy\" class=\"post-preview--image avatar\" src=\"https://r2.immmmm.com/2024/11/SCR-20241110-kfqf.png.webp\">\n</div>\n\n<h3><a href=\"https://umami.is/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Umami</a></h3>\n<p>一个高颜值可自部署的统计应用，还支持前端调用数据。</p>\n\n\n\n\n\t\n\n\n<div class=\"post-preview\">\n  <div class=\"post-preview--meta\">\n    <div class=\"post-preview--middle\">\n      <h4 class=\"post-preview--title\">\n        <a target=\"_blank\" href=\"https://immmmm.com/hi-umami-api/\">前端调用 Umami API 数据</a>\n      </h4>\n      <time class=\"post-preview--date\">2024-11-10</time><small>#折腾 </small>\n      \n      <section class=\"post-preview--excerpt\">\n        Umami 一个高颜值可自部署的统计应用。\n看着服务器负载常年低于10%，有一点点需求的应用，特别是能 Docker 部署的，全都安排上！看着基本的统计数据都有。不错不错！但，能直接 API 前端调用统计数据不？可以的，接口见官网： https://umami.is/docs/api\n\n      </section>\n</div>\n  </div>\n  \n    <img rel=\"link\" loading=\"lazy\" class=\"post-preview--image avatar\" src=\"https://r2.immmmm.com/2023/06/umami-im.png\">\n</div>\n\n<h3><a href=\"https://github.com/wy580477/musicn-container\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">musicn-container</a></h3>\n<p>可播放及下载音乐的命令行工具 musicn 的容器版本，支持 amd64/arm64 架构。偶尔用来下载个 MP3。</p>\n<h3><a href=\"https://github.com/n8n-io/n8n\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">n8n</a></h3>\n<p>免费自部署低代码平台，比如用来接入 <a href=\"https://n8n.akashio.com/b121c42b66fe4963925baa70de007dd6\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Memos AI 助理</a>，追踪微信公众号更新并生成 AI 日报等。</p>\n\n\n\n\n\t\n\n\n<div class=\"post-preview\">\n  <div class=\"post-preview--meta\">\n    <div class=\"post-preview--middle\">\n      <h4 class=\"post-preview--title\">\n        <a target=\"_blank\" href=\"https://immmmm.com/hi-n8n/\">我应该是最后一个才知道有 n8n 这个东西的人吧</a>\n      </h4>\n      <time class=\"post-preview--date\">2024-08-01</time><small>#折腾 </small>\n      \n      <section class=\"post-preview--excerpt\">\n        借用 @heo 某篇文章的句式，表达一下对 n8n 的惊叹之感！不搜不知道，一搜吓一跳。\n小众软件19年10月、少数派 @珪璋 去年5月、@OSEN今年1月、@lcomplete 今年4月，以及我最最后才从 @汐笺 知道的 n8n 中文教程。\n\n      </section>\n</div>\n  </div>\n  \n    <img rel=\"link\" loading=\"lazy\" class=\"post-preview--image avatar\" src=\"https://r2.immmmm.com/2024/08/SCR-20240801-mgzr.png.webp\">\n</div>\n\n<h3><a href=\"https://github.com/talebook/talebook\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Talebook</a></h3>\n<p>以下几个 Docker 都部署在 NAS 里。</p>\n<p>基于 Calibre 简单的个人图书管理系统，各方面都比 calibre-web 好用。而且 Talebook 可以直接读取 Calibre 数据库，日常通过本地连接 NAS 管理书籍，结合 frpc 穿透绑上域名，供好友自取，还内置了 opds 功能，手机用 KyBooks3 APP 顺利实现 APP 内检索下载阅读。</p>\n<p><img loading=\"lazy\" decoding=\"async\" src=\"https://r2.immmmm.com/2024/12/ds-docker-5.jpg.jpeg.webp\" alt=\"\"></p>\n<h3>vaultwarden</h3>\n<p>Bitwarden 自部署镜像。</p>\n<h3><a href=\"https://ghost.org/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">Ghost</a></h3>\n<p>用作家庭内部图片博客，基本上是整理照片时，随手丢上去更新一下。回头翻翻，把美好瞬间记录也是件美好的事。</p>\n<p>停留在 5.8.3 版本，因为这是 sqlite3 的最高版本，再高需要另外部署 MySQL 8。</p>\n<h3><a href=\"https://github.com/Sitoi/dailycheckin\" target=\"_blank\" rel=\"noopener nofollow noreferrer\">DailyCheckIn</a></h3>\n<p>基于「Docker」/「青龙面板」/「群晖」/「本地」的每日签到脚本。</p>\n", "categories": ["%E6%8A%98%E8%85%BE"], "time": 1733620601}, {"title": "Windows Server DataCentre 2022 Retail序列号一次激活多次使用", "author": "Chenxi", "pubDate": "2024-11-16 18:00:21", "link": "https://chenxi.in/post/wsd2rxlhycjhdcsy/", "description": "<p>最近某宝花12块钱买了个Windows Server DataCentre 2022 Retail序列号，用在激活虚拟机上了，其实原本是打算用在物理机上的。Retail的序列号设计上是只能用一次，现在博主的需求是能激活多次用于多台虚拟机（用于出租🤣），那么设计和需求之间就存在矛盾了，现在需要解决这个矛盾</p>", "categories": [], "time": 1731751221}, {"title": "如何优雅的截图", "author": "Redish101博客", "pubDate": "2024-09-22 01:30:19", "link": "https://blog.redish101.top/article/how-to-cap-screen", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://userbase.kde.org/images.userbase/thumb/4/48/Taking_Screenshots.png/500px-Taking_Screenshots.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/how-to-cap-screen\">https://blog.redish101.top/article/how-to-cap-screen</a>\n</blockquote>\n<div>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以免有些人在会截图的情况下故意不截图而拍屏，用满是摩尔纹的屏幕恶心群友的眼睛，这里准备了几篇文章来帮助你学会如何截图。如果你被人扔了这篇文章的链接，感到冒犯，不好意思，冒犯的就是你</p></blockquote>\n<h2>如何在 Windows 11 下截图</h2>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">翻译自：<a href=\"https://www.microsoft.com/en-us/windows/learning-center/how-to-screenshot-windows-11\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">How to Take Screenshots on Windows 11 | Windows Learning Center</a></p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在Windows 11中捕获屏幕截图是一个简单且高效的过程。了解以下几种截图方法，可以帮助您快速保存重要信息至您的个人计算机。</p>\n<h3>使用Snipping Tool截图</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Snipping Tool是Windows 11中截屏的一种便捷方式。如果您之前使用过Windows操作系统，那么您可能已经熟悉Snipping Tool。此版本的工具结合了原有的Snipping Tool与Snip &amp; Sketch Tool的功能。以下是开启Snipping Tool并开始截图的步骤：</p>\n<ul>\n<li>按下 <code>Windows徽标键 + Shift + S</code> 快捷键直接启动Snipping Tool。</li>\n<li>输入快捷键后，屏幕顶部会出现一个小工具栏。</li>\n<li>在工具栏中选择以下截图模式之一：\n<ul>\n<li>矩形截图</li>\n<li>自由绘制截图</li>\n<li>窗口截图</li>\n<li>全屏截图</li>\n</ul>\n</li>\n<li>选择矩形区域或自由绘制以突出显示活动窗口或全屏的指定区域。</li>\n<li>截图后，在屏幕右下角将出现截图的缩略图预览。</li>\n<li>Snipping Tool将截图直接复制到剪贴板，因此您可以根据需要将其粘贴（<code>Ctrl + V</code>）到其他应用程序中。</li>\n</ul>\n<h3>如何使用Snipping Tool编辑截图</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">利用Snipping Tool直观的界面个性化您的截图。只需打开屏幕下方的缩略图，并从多种可用工具中选择。可以使用高亮标记、裁剪、着色以及书写文本，并提供多种形状和字体。如果使用的是触摸屏设备，可以直接用手写笔或手指进行绘画。完成编辑后，您可以：</p>\n<ul>\n<li>通过点击磁盘图标保存截图及所有编辑；</li>\n<li>使用共享选项发送图像给朋友、家人或同事；</li>\n<li>打印图像；</li>\n<li>通过菜单选项在其他应用程序中打开图像。</li>\n</ul>\n<h3>使用Print Screen键截图</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">使用Print Screen键是一种传统的截图方式。该键通常位于大多数键盘的右上方，标签为Print Screen、PrtSc、PrtScn或PrntScrn。</p>\n<h4>如何捕获当前活动窗口</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">要捕获当前活动窗口，请按照以下步骤操作：</p>\n<ul>\n<li>选择您想截图的窗口。</li>\n<li>按下 <code>Alt + Print Screen</code>。</li>\n<li>将其粘贴（<code>Ctrl + V</code>）到所选的Office程序或其他应用程序中。</li>\n</ul>\n<h4>如何捕获整个屏幕</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">要复制整个屏幕上的图像，请遵循以下步骤：</p>\n<ul>\n<li>调整好您希望复制的内容。</li>\n<li>按下 <code>Print Screen</code>。</li>\n<li>将其粘贴（<code>Ctrl + V</code>）到所选的Office程序或其他应用程序中。</li>\n</ul>\n<h4>如何将截图保存为图像文件</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">按照以下步骤将截图直接保存至桌面为图像文件：</p>\n<ul>\n<li>按下 <code>Windows键 + Print Screen</code>。</li>\n<li>在文件资源管理器中导航至 <strong>图片 &gt; 截图</strong> 文件夹以找到PNG格式的截图。</li>\n</ul>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">希望以上指南能帮助您更好地掌握在Windows 11中的截图技巧。如果您正在寻找合适的Windows 11设备，可以考虑浏览我们提供的各类Windows电脑，找到最适合您的那一款。</p>\n<h2>如何在 macOS 中截图</h2>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">翻译自：<a href=\"https://support.apple.com/en-us/102646\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">Take a screenshot on your Mac - Apple Support</a></p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在Mac上，您可以轻松地捕获整个屏幕、某个窗口或是仅仅是一部分屏幕的截图。</p>\n<h3>如何在Mac上截屏</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">要截取整个屏幕的图片，请同时按下这三个键：Shift、Command 和 3。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果您在屏幕的一角看到了缩略图，可以点击它来编辑截图；或者等待截图自动保存到桌面上。</p>\n<h3>如何截取屏幕的一部分</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">要截取屏幕的一部分，请同时按下这三个键：Shift、Command 和 4。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">此时会出现一个十字光标，您可以拖动它来选择想要捕获的屏幕区域。要移动选择区域的位置，可以在拖动的同时按住空格键。如果要取消截屏，按下Esc（Esc键）即可。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">当您放开鼠标或触控板上的按钮时，截图即被拍摄下来。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果您在屏幕的一角看到了缩略图，可以点击它来编辑截图；或者等待截图自动保存到桌面上。</p>\n<h3>如何截取某个窗口或菜单</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">首先打开您想要截取的窗口或菜单。接着同时按下这四个键：Shift、Command、4 和 空格键。这时指针会变成一个相机图标。如果要取消截屏，按下Esc（Esc键）即可。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">点击您想要截取的窗口或菜单。为了在截图时不包括窗口阴影，可以在点击时按住Option键。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果您在屏幕的一角看到了缩略图，可以点击它来编辑截图；或者等待截图自动保存到桌面上。</p>\n<h3>在哪里查找截图</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">默认情况下，截图会被保存到您的桌面上，并命名为“Screen Shot [日期] at [时间].png”。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在macOS Mojave或更新版本的操作系统中，您可以从“截图”应用的“选项”菜单更改截图保存的默认位置。您也可以将截图的缩略图拖动到某个文件夹或文档中。</p>\n<h3>了解更多</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在macOS Mojave或更新版本的操作系统中，您还可以通过“截图”应用设置计时器，并选择截图保存的位置。要打开该应用，请同时按下这三个键：Shift、Command 和 5。更多关于“截图”应用的信息，请进一步查阅相关资料。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">一些应用程序，如Apple TV应用，可能不允许您对其窗口进行截图。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">若要将截图复制到剪贴板上，请在截屏时按住Control键。这样，您可以将截图粘贴到其他地方，或者使用通用剪贴板功能将其粘贴到另一台苹果设备上。</p>\n<h2>如何在 KDE 中截图</h2>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">摘自：<a href=\"https://userbase.kde.org/Taking_Screenshots\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">Taking Screenshots - KDE UserBase Wiki</a></p></blockquote>\n<h3>准则</h3>\n<ul>\n<li>如果不是中文截图，请把语言设为相应的语言</li>\n<li>把图片存为 PNG 格式</li>\n<li>最好使用默认设置（图标、配色、风格、窗口、应用设置等等）</li>\n<li>最好使用<strong>混成</strong> （<a href=\"https://userbase.kde.org/Special:MyLanguage/System_Settings\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/System Settings\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">系统设置</a>里的桌面效果模块），如果你的显卡不支持混成那就别用了，别担心。</li>\n<li>最好使用 9 点的 “Liberation Sans” 字体</li>\n<li>如果截图展现的是部分桌面，最好使用 plasma 的默认背景。如有可能，给图片留个边（约20像素），这样就不像把窗口阴影给去了</li>\n<li>如果是张中文截图，请用原来的英文文件名，外加 “zh-cn” 这个语言码</li>\n<li>如果更新已有截图，请用相同的文件名，这样就自动更新了(常见 <a href=\"https://userbase.kde.org/Special:MyLanguage/Update_an_Image\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/Update an Image\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">上传图片</a>).</li>\n</ul>\n<h3>步骤</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">下面这个例子用了 <a href=\"https://userbase.kde.org/Special:MyLanguage/KSnapshot\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/KSnapshot\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">KSnapshot</a>，不过别的截屏应用也可以。</p>\n<img src=\"https://userbase.kde.org/images.userbase/thumb/4/48/Taking_Screenshots.png/500px-Taking_Screenshots.png\" alt=\"\"><ol start=\"1\">\n<li>运行 <a href=\"https://userbase.kde.org/Special:MyLanguage/KSnapshot\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/KSnapshot\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">KSnapshot</a>\n</li>\n<li>从以下抓图模式中选一个：当前屏幕（只会在多屏幕环境下出现）抓取单个屏幕上的所有东西，常用于“桌面截图”。全屏所抓内容因屏幕个数而定，针对单屏幕用户抓取当前屏幕上的所有内容，对于多屏用户抓取所有屏幕到一个窗口。光标处的窗口抓取应用程序或对话框窗口的内容，常用于“应用程序截图”，选中“包含窗口装饰”选项就更好了。区域只抓取稍后界定的区域。</li>\n<li>单击<strong>新建抓图</strong>。全屏当前屏幕光标处的窗口单击屏幕的任一区域截图。区域1. 用鼠标在所抓区域（比如窗口）画个矩形。\n<ol start=\"1\"><li>按下<strong>回车</strong>键，或双击所选区域截图。</li></ol>\n</li>\n<li>单击<strong>另存为...</strong>。</li>\n<li>浏览想存图片的位置，命名（<strong><em>name.png</em></strong>）然后单击<strong>保存</strong>\n</li>\n</ol>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">To upload the image:</p>\n<ul>\n<li>If you are making a new version of an existing image, see <a href=\"https://userbase.kde.org/Special:MyLanguage/Update_an_Image\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/Update an Image\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">Update an Image</a>\n</li>\n<li>If you are making a new image go to <a href=\"https://userbase.kde.org/Special:Upload\" target=\"_blank\" class=\"link\" title=\"Special:Upload\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">Upload File</a> under <strong>Tools</strong> in the right margin. That brings you to a page, where you can upload the image file.</li>\n</ul>\n<h3>提示和技巧</h3>\n<ul>\n<li>\n<strong>抓图延时</strong>选项让 <a href=\"https://userbase.kde.org/Special:MyLanguage/KSnapshot\" target=\"_blank\" class=\"link\" title=\"Special:MyLanguage/KSnapshot\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">KSnapshot</a> 在抓图前等上特定一段时间（单位是秒），在为下拉菜单截图为首的许多情况下都很管用</li>\n<li>为保证标准外观和默认设置，建立单独用于截图的用户往往有所帮助。</li>\n<li>在墙纸设置里调整<strong>颜色</strong>来得到白色背景。</li>\n</ul>\n</div>\n<p><a href=\"https://blog.redish101.top/article/how-to-cap-screen#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1726939819}, {"title": "reblog: 使用 Go + Next.js重构我的博客", "author": "Redish101博客", "pubDate": "2024-08-30 07:02:54", "link": "https://blog.redish101.top/article/introduce-reblog", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/introduce-reblog\">https://blog.redish101.top/article/introduce-reblog</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">2022年，我曾使用django开发过一个简单的动态博客框架Cooler：</p>\n<div>GitHub仓库：<a href=\"https://github.com/Cooler-dev/Cooler-old\">Cooler-dev<!-- -->/<!-- -->Cooler-old</a>\n</div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">并且用了一段时间。之后觉得功能太少，又觉得hexo比较方便，就将博客迁移到了hexo。之后我学习了go，尝试用go重写cooler的后端：</p>\n<div>GitHub仓库：<a href=\"https://github.com/Cooler-dev/CoolerGo\">Cooler-dev<!-- -->/<!-- -->CoolerGo</a>\n</div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">然后便遥遥无期，最终由换回了hexo。去年三月份，我将博客<a href=\"https://blog.redish101.top/article/refactor-my-blog-with-next\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">迁移到了Next.js</a>，并与去年七月份将博客<a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">迁移到Next.js App Router</a>。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">期间我还尝试过halo，typecho，wordpress等动态博客框架，但因为对php，java等不熟练，无法进行进一步定制，就换回了hexo。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">今年年初，我开始尝试开发一个动态博客框架，并取名reblog。</p>\n<div>GitHub仓库：<a href=\"https://github.com/redish101/reblog\">redish101<!-- -->/<!-- -->reblog</a>\n</div>\n<h2>技术选型</h2>\n<h3>fiber</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">对于后端，我选择了fiber，fiber是一个轻量化的go http框架，由于其以fasthttp作为底层，所以有着相当不错的性能表现。同时，fiber有着类似于express的api风格，我相对比较熟悉。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在开始开发时，fiber v3处在开发阶段，但是redish相信fiber v3正式版会先reblog一步发布（）所以便使用了fiber v3作为底层。</p>\n<h3>gorm + gen</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">gorm是go开发中使用相当广泛的orm，功能较为齐全，但gorm并不是类型安全的，在调用一些接口时没有补全和检查：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">var product Product\ndb.First(&amp;product, 1) // find product with integer primary key\ndb.First(&amp;product, \"code = ?\", \"D42\") // find product with code D42</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如此处查询 <code>code</code>为 <code>D42</code>的产品，如果code拼写错误，编译阶段并不会导致错误，容易导致运行时异常。而gen通过代码生成实现了更为友好且不易出错的api：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">p := query.Product\nproduct, err := p.Where(p.Code.Eq(\"D42\")).First()</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但是代码生成让编译流程又复杂了一些.......</p></blockquote>\n<h3>Next.js</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">我对React比较熟悉一些，博客场景又需要良好的sso，所以自然选择next。</p>\n<h2>基本架构</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">reblog采用前后端分离的架构，分为三个部分：后端、控制台和主题（前端）。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">其中控制台嵌入到后端，用户通过访问后端对应url进入控制台。主题则通过HTTP API与后端交互，获取数据。</p>\n<h2>配置文件</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">yaml是一种常用的配置文件格式，相比于json更适合人类阅读，reblog采用yaml作为配置文件格式。为了未来的Serverless支持等一些不方便将配置信息明文储存在配置文件中，reblog提供了 <code>env(ENV_NAME)</code>这一特殊接口，在解析配置时读取环境变量，进行替换。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">例如使用vercel部署，由于fork无法设置为私有，所以需要将配置文件明文储存在仓库，为了避免数据库密码等信息的泄露，可以通过此接口从环境变量中读取配置：</p>\n<pre class=\"language-yaml lang-yaml\"><code class=\"language-yaml lang-yaml\"># reblog.yml\ndb:\n    type: postgres\n    host: localhost\n    # ...\n    pass: env(\"POSTGRES_PASSWORD\")\n    # ...</code></pre>\n<h2>依赖注入</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">reblog通过一个 <code>App</code>结构体封装查询，fiber，配置信息等依赖实例：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">type App struct {\n    config    *config.Config\n    fiber     *fiber.App\n    query     *query.Query\n    validator *validator.Validate\n    dev       bool\n\n    service *map[string]Service\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在启动时生成app实例：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func Start() {\n    log.Info(\"欢迎使用reblog\")\n\n    config := config.NewFromFile()\n    app := core.NewApp(config)\n\n    loadPlugins(app)\n    app.Bootstrap()\n\n    LoadHttp(app)\n\n    log.Fatal(app.Listen())\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">通过传参的形式将app实例注入到handler：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func ArticleAdd(app *core.App, router fiber.Router) {\n    router.Post(\"/:slug\", func(c fiber.Ctx) error {\n        a := app.Query().Article\n\n        var params ArticleAddParams\n        params.Slug = c.Params(\"slug\")\n        if isValid, resp := common.Param(app, c, &amp;params); !isValid {\n            return resp\n        }\n\n        article := &amp;model.Article{\n            Title:   params.Title,\n            Slug:    params.Slug,\n            Desc:    params.Desc,\n            Content: params.Content,\n            Draft:   &amp;params.Draft,\n        }\n\n        err := a.Create(article)\n\n        if err != nil {\n            return common.RespServerError(c, err)\n        }\n\n        return common.RespSuccess(c, \"操作成功\", nil)\n    }, common.Auth(app))\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">部分依赖（如验证器，查询等）直接作为 <code>App</code>结构体的字段，但也有一部分依赖（目前包含身份验证，Markdown渲染）动态注入，方便运行时的修改与插件侧的覆盖等操作，reblog将这些依赖统一封装为服务并以map的形式储存在 <code>App</code>结构体中：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">package core\n\nimport \"fmt\"\n\ntype Service interface {\n    Start() error\n    Stop() error\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">服务包含三个基本的接口，<code>NewXXService</code>，<code>Start</code>及 <code>Stop</code>：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">type MarkdownService struct {\n    app *App\n\n    renderer *markdown.Renderer\n    cache    map[string]string\n}\n\nfunc NewMarkdownService(app *App) *MarkdownService {\n    return &amp;MarkdownService{app: app}\n}\n\nfunc (s *MarkdownService) Start() error {\n    s.renderer = markdown.NewRenderer()\n    s.cache = make(map[string]string)\n\n    return nil\n}\n\nfunc (s *MarkdownService) Stop() error {\n    s.renderer = nil\n\n    return nil\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这部分接口会被统一调用，在注入等操作时调用，统一管理服务的生命周期：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">// 注入服务到App实例\nfunc (a *App) Inject(name string, service Service) {\n    (*a.service)[name] = service\n}\n\n// 注入服务到App实例, 并生成服务名称\nfunc AppInject[T Service](app *App, service T) {\n    log.Debugf(\"[SERVICE] 注入服务 %s\", getServiceName[T]())\n    app.Inject(getServiceName[T](), service)\n}\n\nfunc (app *App) Service(name string) (Service, error) {\n    if app.service == nil {\n        return nil, fmt.Errorf(\"服务未初始化\")\n    }\n\n    if _, isExits := (*app.service)[name]; !isExits {\n        return nil, fmt.Errorf(\"服务 %s 不存在\", name)\n    }\n\n    return (*app.service)[name], nil\n}\n\nfunc AppService[T Service](app *App) (T, error) {\n    service, err := app.Service(getServiceName[T]())\n\n    if err != nil {\n        var zero T\n        return zero, err\n    }\n\n    return service.(T), nil\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>AppInject</code>函数接受app指针与服务，向 <code>app.service</code>注入服务：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func (app *App) initDefaultServices() {\n    AppInject(app, NewAuthService(app))\n    AppInject(app, NewMarkdownService(app))\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">注入时根据类型自动生成服务名称：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func getServiceName[T any]() string {\n    var t T\n\n    // struct\n    name := fmt.Sprintf(\"%T\", t)\n    if name != \"&lt;nil&gt;\" {\n        return name\n    }\n\n    // interface\n    return fmt.Sprintf(\"%T\", new(T))\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>AppService</code>函数接收服务的类型和app指针，用以获取对应的服务实例：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">auth, err := core.AppService[*core.AuthService](app)\nauth.VerifyToken(token)</code></pre>\n<h2>身份验证</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">reblog使用jwt实现身份验证机制，登录时生成jwt并储存到客户端：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">claims := TokenClaim{\n    user.Username,\n    user.Password,\n    jwt.RegisteredClaims{\n        Issuer:    \"reblog-server\",\n        IssuedAt:  jwt.NewNumericDate(time.Now()),\n        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),\n    },\n}\n\ntoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\nsignedToken, _ := token.SignedString(a.key)\n\nreturn signedToken</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">通过校验token实现身份验证：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">parsedToken, err := jwt.ParseWithClaims(token, &amp;TokenClaim{}, func(t *jwt.Token) (interface{}, error) {\n    return a.key, nil\n})\n\nif err != nil {\n    return false\n}\n\nif _, ok := parsedToken.Claims.(*TokenClaim); ok &amp;&amp; parsedToken.Valid {\n    return true\n}\n\nreturn false</code></pre>\n<h2>控制台</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">动态博客自然是要有控制台的，控制台一般并不需要seo，且由于reblog使用go作为后端并不方便处理ssr，所以reblog控制台使用客户端渲染。由于我对react比较熟悉，所以控制台依然采用了react。但由于直接使用react开发要处理路由等基本框架，较为繁琐，所以控制台使用了umi进行开发。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">umi是一个基于react的前端开发框架，封装了路由、布局等常用的api，提供了从编码到构建各个阶段的轮子，能够使开发更快速。</p>\n<h2>插件</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">reblog实验性的支持运行时插件功能，插件开发者可以通过覆写、扩展或修改app结构体中的字段的形式在运行时更改reblog的行为。插件将被构建为动态链接库格式，并以服务的形式在运行时被加载，通过将app注入到插件中实现插件对reblog的修改。reblog在启动时会读取配置文件中的plugin字段，plugin字段是一个指向插件路径的数组，reblog将尝试加载对应路径下的插件。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">插件的路径最少有两个文件，<code>manifest.json</code>与插件的动态链接库。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>manifest.json</code>是插件的清单文件，用以声明插件的基本信息：</p>\n<pre class=\"language-json lang-json\"><code class=\"language-json lang-json\">{\n    \"name\": \"Hello\",\n    \"version\": \"0.1.0\",\n    \"path\": \"libhello.so\"\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">启动时reblog会加载清单中指定的动态链接库：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">p, err := plugin.Open(path + \"/\" + manifest.Path)</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">调用 <code>NewPlugin</code>方法，向插件注入依赖，并获取插件实例:</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">factoryFuncLookup, err := p.Lookup(fmt.Sprintf(\"New%sPlugin\", manifest.Name))\nif err != nil {\n    log.Warnf(\"[PLUGIN] 插件 %s 未实现 New%sPlugin 方法\", path, manifest.Name)\n}\n\nfactoryFunc := factoryFuncLookup.(func(*core.App) core.Service)\n\nservice := factoryFunc(app)\n\nif service == nil {\n    log.Warnf(\"[PLUGIN] 插件 %s 未返回有效服务实例\", manifest.Name)\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">然后向app注入插件服务：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">app.Inject(fmt.Sprintf(\"Plugin%s\", manifest.Name), service)</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">此时插件便可以以服务的形式参与到reblog的运行中，并通过修改app的形式修改reblog的行为，例如增加一个handler：</p>\n<pre class=\"language-go lang-go\"><code class=\"language-go lang-go\">func (p *HelloPlugin) Start() error {\n    log.Infof(\"[HelloPlugin] Start\")\n    p.app.Fiber().All(\"/api/hello\", func(c fiber.Ctx) error {\n        return common.RespSuccess(c, \"Hello from plugin!\", nil)\n    })\n\n    return nil\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">插件目前暂不能修改前端的行为，前端插件正在开发中，目前设想是插件通过下面的形式对外暴露api：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">const Dashboard: React.FC = () =&gt; \"Plugin Page...\"\n\nexport default definePlugin({\n    name: \"Hello\",\n    views: [\n        {\n            path: \"/\",\n            title: \"设置 Hello\",\n            icon: &lt;PluginIcon /&gt;,\n            component: &lt;Dashboard /&gt;\n        }\n    ]\n})</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">也可能维护一个vite插件处理插件的打包及开发阶段的mock等（？）</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">前端从后端或者cdn加载插件的打包产物，加载后调用插件暴露的api并以此修改前端的行为。前端插件可能更多适用于类似评论这种扩展型插件。</p>\n<h2>RSS</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">由于群友<a href=\"https://liushen.fun/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">清羽飞扬</a>的强烈催更，我给reblog加入了rss功能。</p>\n<h2>ThemeKit</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">前文提到，reblog前后端之间使用HTTP API进行交互，而直接通过HTTP API交互较为繁琐，编码时没有提示，且当api接口变动时若不修改接口调用会导致异常。基于此，reblog提供了ThemeKit(<code>@reblog/themekit</code>)，将HTTP API封装，使主题能够通过js的形式调用api：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import ThemeKit from \"@reblog/themekit\";\n \nconst themekit = new ThemeKit({\n  server: {\n    url: \"https://reblog.example.com\",\n  },\n  cache: \"no-store\",\n});\n\nconst ArticleList: React.FC = async () =&gt; {\n    const articles = await themekit.getArticleList({\n          pageIndex: 1,\n          pageSize: 10,\n    });\n  \n    return (\n        &lt;div&gt;\n            {articles.map(\n                article =&gt; &lt;Link href={`/article/${article.slug}`}&gt;{article.title}&lt;/Link&gt;\n            )}\n        &lt;/div&gt;\n    )\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">详细的api接口可见<a href=\"https://reblog-docs.redish101.top/develop/themekit\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">ThemeKit API文档</a>。</p>\n<h2>主题</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">前文提到，reblog提供ThemeKit方便主题的开发，所以主题可以专心的处理样式和渲染等，而不用与fetch斗智斗勇（</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">目前此网站所用的主题是<a href=\"https://github.com/Redish101/reblog-theme-next\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">reblog-theme-next</a>，使用Next.js开发。</p>\n<h2>Markdown渲染</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">reblog并不想过多约束主题的实现，希望让主题开发者能够得到更多自定义的便利，所以采用了前后端分离架构而非模板渲染，基于同样的目的，reblog后端除rss外，默认提供<strong>未经渲染</strong>的Markdown正文，方便主题自定义渲染逻辑以及实现。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">对于reblog-theme-next，我使用了remark处理文章的渲染，并使用了shiki处理高亮：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const render = cache(async (content: string) =&gt; {\n  const processor = unified()\n    .use(remarkParse)\n    .use(remarkGfm)\n    .use(remarkRehype)\n    .use(rehypeShiki, { theme: \"github-dark\" })\n    .use(rehypeStringify);\n\n  const result = await processor.process(content);\n  return result.toString();\n});</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">理论上reblog主题可以使用mdx甚至rst，latex等其他的格式作为正文格式，但可能需要主题提供对应的插件以支持渲染这些格式的正文。</p></blockquote>\n<h2>评论</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">因为我并不像再多部署一个评论的管理面板站，所以使用了支持嵌入式面板的twikoo。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">未来reblog可能会内置评论，目前暂定是重新复活基本停止维护的<a href=\"https://retalk.js.org/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">retalk</a>，retalk后端与reblog一致均为fiber + gorm + gen的组合，所以可能能方便的嵌入到reblog后端中使用。</p>\n<h2>结语</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">reblog基本上是自用项目，当然如果你想用我也是支持的（），同时reblog的接口也比较有扩展性，欢迎来写主题或者插件（</p>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">目前的控制台似乎有点过于杂乱了，当时只想着就剩控制台这个小任务就完成了，所以控制台代码质量堪忧，准备在后端更为稳定后重新开发一个控制台，并使用自定义的ui代替antd。</p></blockquote>\n</div>\n<p><a href=\"https://blog.redish101.top/article/introduce-reblog#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1724972574}, {"title": "Windows提权 - 特权利用", "author": "Chenxi", "pubDate": "2024-07-28 16:33:13", "link": "https://chenxi.in/post/wtqtqly/", "description": "<p>最近整了2单oscp的<s>考</s>(jiu)<s>前</s>(shi)<s>辅</s>(dai)<s>导</s>(kao)，发现这个考试引入了一些不常用的Windows提权手法，因此专门开一篇文章做个记录（有点散嗖嗖的，有空整理整理一下🤣）<br><em>有关Windows提权的手法：</em>  <a href=\"https://chenxi.in/tqslzwjqx/\">总览</a>，<a href=\"https://chenxi.in/wrgu/\">绕过UAC</a>，<a href=\"https://chenxi.in/wtqaie/\">MSI特权安装</a><br><em>持续更新中</em></p>", "categories": [], "time": 1722155593}, {"title": "Deno再尝试：使用Deno编写一个简单的HTTP API", "author": "Redish101博客", "pubDate": "2024-07-23 04:13:46", "link": "https://blog.redish101.top/article/deno", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/deno\">https://blog.redish101.top/article/deno</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">两年前，我通过<a href=\"https://mk1.io/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">Ray(@so1ve)</a>的博客系统<a href=\"https://github.com/dolan-x/dolan-server\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">dolan-x</a>：</p>\n<div>GitHub仓库：<a href=\"https://github.com/dolan-x/dolan-server\">dolan-x<!-- -->/<!-- -->dolan-server</a>\n</div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">了解到了 <code>Deno</code>这一新的 js 运行时以及其对应的 saas 服务 <code>Deno Deploy</code>，为了<del>白嫖 <code>Deno Deploy</code></del>，决定尝试一下，用 Deno + oak + LeanCloud 写了一个简单的友链管理。但是 Deno 脆弱的生态和与 go 类似的基于 url 的模块系统（即使能通过 <code>import_map.json</code>定义别名）实在没有太多优势，最近 Deno Deploy 又被群友提及，看到 Deno 本身变化很大，便决定再尝试用 Deno 写一个东西。凑巧<a href=\"https://redish101.top/\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">个人主页</a>想加一个活动监测器，便决定用 Deno 来实现。</p>\n<h2>web 框架的选择</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">相比之前的友链，这次要做的比较简单，所以没有使用一些框架，而是直接使用标准库中的 <code>Deno.serve</code>实现。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>Deno.serve</code>接受一个函数，函数接受请求对象返回响应。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const handler = (req: Request) {\n    return new Response(\"Hello, World!\");\n}\n\nDeno.serve(handler);</code></pre>\n<h2>路由</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Deno 本身并没有实现路由，但是可以通过手动解析 <code>pathname</code>实现。</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const handler = (req: Request) {\n    const { pathname } = new URL(req.url);\n\n    if (pathname === \"/\") {\n        return new Response(\"Hello, World!\");\n    }\n\n    if (pathname === \"/foo\") {\n        return new Response(\"bar\");\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">对于复杂的路由，可以尝试把 handler 封装到 map 中：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">type Handler = (req: Request) =&gt; Response;\ntype HandlerMap = { [pathname: string]: Handler };\n\nconst handlers: HandlerMap = {\n  \"/\": () =&gt; new Responese(\"Hello, World!\"),\n  \"/foo\": () =&gt; new Response(\"bar\"),\n};\n\nconst handler = (req: Request) =&gt; {\n  const { pathname } = new URL(req.url);\n\n  const matchedHandler = handlers[pathname];\n\n  if (matchedHandler) {\n    return matchedHandler(req);\n  }\n\n  return new Response(\"Not Found\", { status: 404 });\n};</code></pre>\n<h2>格式化响应</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">最好封装一个格式化响应对象，封装 <code>success</code>，<code>message</code>，<code>data</code>等属性，方便处理：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">class FmtResponse&lt;T&gt; {\n  private code: number = 200;\n  private success: boolean = true;\n  private message: string = \"success\";\n  private data: T | null = null;\n\n  constructor(opts: { code?: number; message?: string; data?: T }) {\n    if (opts.code &amp;&amp; opts.code &gt;= 400) {\n      this.success = false;\n    }\n    this.message = opts.message || \"success\";\n    this.data = opts.data || null;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">并提供一个 <code>json</code>方法返回 json 格式的响应：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">public json() {\n    const resObj = {\n      success: this.success,\n      message: this.message,\n      data: this.data,\n    };\n\n    return new Response(JSON.stringify(resObj), {\n      status: this.code,\n      headers: {\n        \"content-type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n        \"Access-Control-Allow-Headers\": \"Content-Type, apikey\",\n      },\n    });\n}</code></pre>\n<h2>数据的储存</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">选择 <code>Deno Deploy</code>很大一部分原因是因为其方便的 kv 储存，可以方便的持久化储存数据：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">const kv = await Deno.openKv();\n\nawait kv.set([\"settings\", \"username\"], \"redish101\");\n\nconst username = await kv.get([\"settings\", \"username\"]);\n\nconsole.log(username.value); // \"redish101\"</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">值得一提的是，<code>DenoKV</code>虽然可以在本地使用，但是需要在 cli 传入 <code>--unstable-kv</code>：</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">deno run --unstable-kv main.ts</code></pre>\n<h2>监控数据的上报</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这部分没什么可说的，用 rust 写了一个上报器，每 20 分钟通过请求接口上报正常状态的数据，并作为 macOS 服务运行：</p>\n<pre class=\"language-rust lang-rust\"><code class=\"language-rust lang-rust\">use std::env;\n\nuse tokio::time;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt::init();\n\n    info!(\"Welcome to remonitor!\");\n\n    let apiurl = \"https://redish101-remonitor.deno.dev/remonitor\";\n    let apikey = env::var(\"APIKEY\").unwrap();\n\n    let mut interval = time::interval(time::Duration::from_secs(1200));\n\n    loop {\n        interval.tick().await;\n        info!(\"Post status\");\n        reqwest::Client::new()\n           .get(apiurl)\n           .header(\"apikey\", apikey.clone())\n           .send()\n           .await\n           .expect(\"Failed to send request\");\n        info!(\"Sent request\");\n    }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">macos 的服务不能直接读取环境变量，只能读取通过 <code>launchctl setenv</code>设置的环境变量。通过 plist 设置 <code>keepAlive</code>可以实现后台运行：</p>\n<pre class=\"language-xml lang-xml\"><code class=\"language-xml lang-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;Label&lt;/key&gt;\n    &lt;string&gt;top.redish101.remonitor&lt;/string&gt;\n    &lt;key&gt;ProgramArguments&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;/path/to/client&lt;/string&gt;\n    &lt;/array&gt;\n    &lt;key&gt;RunAtLoad&lt;/key&gt;\n    &lt;true/&gt;\n    &lt;key&gt;KeepAlive&lt;/key&gt;\n    &lt;true/&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;</code></pre>\n<h2>部署</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>Deno Deploy</code>是Deno推出的saas服务，提供了Deno程序的部署、KV、定时任务等功能，并且速度不错，所以选择了通过Deno Deploy部署。</p>\n<h2>总结</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Deno虽说目前不怎么适合放到大型项目的生产环境，但是写一些小服务玩玩还是很舒服的，编码体验很好</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/deno#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1721679226}, {"title": "“台独”死路一条", "author": "Chenxi", "pubDate": "2024-05-26 11:33:43", "link": "https://chenxi.in/post/tdslyt/", "description": "<figure data-type=\"image\" tabindex=\"1\"><img src=\"https://images.chenxi.in/tdslyt/1.JPG\" alt=\"\" loading=\"lazy\"></figure>", "categories": [], "time": 1716694423}, {"title": "国产光学顶起来了？永诺42.5mm f1.7 使用体验报告", "author": "小N同学的博客", "pubDate": "2024-04-23 02:40:27", "link": "https://www.imcharon.com/8557/", "description": "在这个镜头机身溢价的时代，国产能否发力抢出一片市场？", "categories": ["往日余生", "精选", "摄影", "照片", "镜头"], "time": 1713811227}, {"title": "绕过群晖NAS“禁止下载和复制”", "author": "Chenxi", "pubDate": "2024-04-16 15:11:33", "link": "https://chenxi.in/post/rgqhnjzxzhfz/", "description": "<p>还以为群晖分享文件的时候勾选“禁止下载和复制”有什么加密解密套壳的操作，没想到打开控制台就能看到请求的文件地址，复制粘贴访问之直接弹出下载<br>\n万万没想到既不防君子也不防小人😂</p>", "categories": [], "time": 1713251493}, {"title": "【Magisk】方正悠黑 Google Sans VF On OPlus", "author": "小N同学的博客", "pubDate": "2024-03-27 14:33:01", "link": "https://www.imcharon.com/8539/", "description": "这是一款基于方正悠黑 Google VF Sans可变字体的OPlus机型字体模块 OPPO / OnePlu […]", "categories": ["往日余生", "教程", "maigsk", "root", "美化"], "time": 1711521181}, {"title": "【Magisk】Manrope腾祥黑体 VF On OPlus By Charon", "author": "小N同学的博客", "pubDate": "2024-03-25 17:53:32", "link": "https://www.imcharon.com/8525/", "description": "这是一款基于Manrope腾祥黑体 VF Sans可变字体的OPlus机型字体模块", "categories": ["往日余生", "教程", "magisk", "root", "美化"], "time": 1711360412}, {"title": "Bitwarden插件无法登录如何修复（Cannot read properties of nul(reading ‘iterations‘)）", "author": "小N同学的博客", "pubDate": "2024-03-22 17:58:32", "link": "https://www.imcharon.com/8514/", "description": "修复一个奇怪的BUG", "categories": ["往日余生", "教程", "bitwarden"], "time": 1711101512}, {"title": "忙到没空更新", "author": "Chenxi", "pubDate": "2024-03-15 19:22:08", "link": "https://chenxi.in/post/mdmkgx/", "description": "<p>实在是太忙了😂<br>\n正所谓：打工人打工魂，打工的才是人上人🤣</p>", "categories": [], "time": 1710501728}, {"title": "SteamDeck开启samba服务", "author": "Yume.KISEKI", "pubDate": "2024-01-15 14:27:53", "link": "https://www.monoko.jp/steamdeck-samba/", "description": "\n<p>SteamDeck开启samba服务 1.前言 为什么steamdeck要开启samba服务，不为别的，我只用 […]</p>\n<p><a href=\"https://www.monoko.jp/steamdeck-samba/\">SteamDeck开启samba服务</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "samba", "steamdeck"], "time": 1705300073}, {"title": "记录一次勇敢的旅程", "author": "小N同学的博客", "pubDate": "2023-12-30 13:56:09", "link": "https://www.imcharon.com/8477/", "description": "在12月初的时候，我计划了一场“特种兵”式的西部旅游计划。 不知道大家最近刷社交媒体，有没有刷到一句话： 纵观 […]", "categories": ["往日余生", "旅行"], "time": 1703915769}, {"title": "[搬运文] - offsec在线考试作弊“技巧”", "author": "Chenxi", "pubDate": "2023-12-08 18:16:03", "link": "https://chenxi.in/post/bywozxkszbjq/", "description": "<p><em>搬运自Quora</em><br>\n按照该文中的方法操作了一下，还真是无感作弊😂，根本不知道别的人登录进了考试用的虚拟机<br>\n能写出这篇“技巧”的人对于“漏洞”的理解可不是一般的深<br><em>稍微推广一下其实可以发现：这个方法适用于所有线上需要使用虚拟机进行的认证考试</em><br><a href=\"https://www.quora.com/profile/Nobody-Jack-1/\" target=\"_blank\">原文链接</a></p>", "categories": [], "time": 1702030563}, {"title": "浅谈Quest3", "author": "Yume.KISEKI", "pubDate": "2023-11-25 15:41:21", "link": "https://www.monoko.jp/about-quest3/", "description": "\n<p>入手quest3 当初想买quest2时发现已经出了有两年了，对于vr这种可有可无的设备干脆就等quest3了 […]</p>\n<p><a href=\"https://www.monoko.jp/about-quest3/\">浅谈Quest3</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "quest3", "vr"], "time": 1700898081}, {"title": "Windows电脑音频大优化！杜比音效+Fx Sound双调教！", "author": "小N同学的博客", "pubDate": "2023-10-29 11:56:50", "link": "https://www.imcharon.com/8447/", "description": "作为一名离开音乐会死星人，windows没有任何调教的声音听着真的很难受，但是单杜比的效果又有点差强人意，那怎 […]", "categories": ["往日余生", "教程", "精选", "资源分享", "windows", "音效"], "time": 1698551810}, {"title": "朝鲜红星OS提权到root", "author": "Chenxi", "pubDate": "2023-10-26 09:08:43", "link": "https://chenxi.in/post/cxhxotqdr/", "description": "<p>一段时间前做过的，忘记写下来了😅</p>", "categories": [], "time": 1698282523}, {"title": "2023年QQBOT防风控小妙招", "author": "轻音时雨的博客", "pubDate": "2023-09-25 11:20:37", "link": "https://www.594594.xyz/2023/09/25/qqbot_anti_risk/", "description": "<p>本文内容禁止抄袭、转载、搬运</p>", "categories": ["游戏相关", "教程"], "time": 1695612037}, {"title": "Windows提权 - AlwaysInstallElevated", "author": "Chenxi", "pubDate": "2023-09-18 04:29:13", "link": "https://chenxi.in/post/wtqaie/", "description": "<p>今天是 9·18，不要忘记：日本军国主义目前还没被清算，余孽依旧在<br>\n牢记历史 砥砺前行 吾辈自强</p>", "categories": [], "time": 1694982553}, {"title": "关于站点的未来，和最近的状况", "author": "小N同学的博客", "pubDate": "2023-09-01 15:19:47", "link": "https://www.imcharon.com/8436/", "description": "最近的时间非常少，站点几乎处于无维护状态。 首先！我要向申请友链的小伙伴们说声对不起，因为太忙导致没时间更新！ […]", "categories": ["往日余生"], "time": 1693552787}, {"title": "CloudFlare warp 优选", "author": "wututu-blog", "pubDate": "2023-08-12 15:20:04", "link": "https://blog.wututu.cn/cloudflare-warp-%E4%BC%98%E9%80%89/", "description": "博客原文地址：https://blog.misaka.rest/2023/03/12/cf-warp-yxip cloudflar ...", "categories": ["未分类"], "time": 1691824804}, {"title": "各大frp内网穿透评测", "author": "wututu-blog", "pubDate": "2023-08-06 02:41:43", "link": "https://blog.wututu.cn/%E5%90%84%E5%A4%A7frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%AF%84%E6%B5%8B/", "description": "只做评测排名不分上下 1.LoCyan Frp 此家frp坚持100%免费不做任何收费项目，如果有能力的话可以捐赠此项目 官网：h ...", "categories": ["内网穿透", "评测"], "time": 1691260903}, {"title": "这又是什么理论", "author": "Chenxi", "pubDate": "2023-07-28 16:39:11", "link": "https://chenxi.in/post/zyssmll/", "description": "<p>小红书上有个人说：就静态网站这点东西黑进去分分钟搞掂<br>\n博主不是很信，除非有手上有Apache 2.4.55 RCE / SSH 8.7p1 RCE<br>\n（最近做了迁移，现在是Apache 2.4.57 / SSH 9.2p1）<br>\n其实对于技术人员来说，劈里啪啦一大堆理论有个屁用，请用getshell说话（Talking is cheap，show me the code）（如果是真的有技术的话，早就入侵进来挂黑页了，根本不用在评论区里打嘴炮）<br>\n开启“装B之神”专区，截图挂出小红书B神（纯属没事干🤣）</p>", "categories": [], "time": 1690533551}, {"title": "termux 安装 aircrak-ng", "author": "Utermux博客", "pubDate": "2023-07-23 03:48:26", "link": "https://blog.utermux.dev/ut/aircrack-ng.html", "description": "pkg i tur-repo -ypkg i aircrack-ng -y", "categories": [], "time": 1690055306}, {"title": "termux 安装 mdk4", "author": "Utermux博客", "pubDate": "2023-07-23 03:47:53", "link": "https://blog.utermux.dev/ut/mdk4.html", "description": "pkg i tur-repo -ypkg i mdk4 -y", "categories": [], "time": 1690055273}, {"title": "Next.js App Router初体验与实践: 将我的博客迁移到Next.js App Router与React Server Components", "author": "Redish101博客", "pubDate": "2023-07-13 05:03:10", "link": "https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230712213628.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131357.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131238.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components\">https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components</a>\n</blockquote>\n<div>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在今年三月初，我使用 Next.js 重构了我的博客。现在，随着 Next.js AppRouter 的稳定，我又将博客从 Next.js Pages Router 迁移到了 Next.js 13 AppRouter 与 React Server Components，同时，我也做了大量的底层重构以及样式重构。</p>\n<h2>性能优化: React Server Components</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在 React 18 之前，所有的组件均为 <code>Client Components</code>，即客户端组件。顾名思义，客户端组件中的所有逻辑均在客户端执行。浏览器渲染客户端组件需要从服务端获取 chunk，然后渲染组件到页面。即使是在 SSR 中，也需要等待客户端组件所对应的 bundle 完成加载才能让页面具有逻辑，能够交互。而我们的一些操作并不需要在客户端调用：如获取数据，大量的类似的逻辑，大大提高了 bundle 的体积，使得页面加载相对较慢，而 <code>React Server Components</code>（以下简称 <code>RSC</code>）的出现很好的解决了这一问题。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">RSC 不同于客户端组件，RSC 在服务端的 React 执行，客户端所收到的是服务端的执行结果，也就是说，客户端不会加载任何 RSC 的逻辑代码，以此我们就能缩小 Client Bundle。因为 RSC 是在服务端执行的，所以理所当然，RSC 内能够调用 node 环境，我们也就不必通过 <code>getStaticProps</code>等 api 获取数据。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">之前的文章提到过，我将博客从 Hexo 迁移到了基于文件的 CMS，以往博客版本是这样获取数据的：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export async function getStaticPaths() {\n  const posts = getAllPosts([\"slug\"]);\n\n  return {\n    paths: posts.map((post) =&gt; {\n      return {\n        params: {\n          slug: post.slug,\n        },\n      };\n    }),\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }: any) {\n  const post = getPostBySlug(params.slug, [\"title\", \"date\", \"slug\", \"content\"]);\n  const content = await markdownToHtml(post.content || \"\");\n  await generateRss();\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content,\n      },\n    },\n  };\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">而在使用 RSC 后，我们可以直接获取数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default async function Post({ params }: { params: { slug: string } }) {\n  const post = getPostBySlug(params.slug, [\n    \"title\",\n    \"date\",\n    \"slug\",\n    \"cover\",\n    \"content\",\n  ]);\n  if (!post.title) {\n    return notFound();\n  }\n  const content = await markdownToHtml(post.content || \"\");\n  return (\n    &lt;&gt;\n      &lt;Card title={post.title} cover={post.cover} label={post.date.toString()}&gt;\n        &lt;div dangerouslySetInnerHTML={{ __html: content }} /&gt;\n      &lt;/Card&gt;\n    &lt;/&gt;\n  );\n}\n\nexport async function generateStaticParams() {\n  const posts = getAllPosts([\"slug\"]);\n  return posts.map((post) =&gt; ({\n    slug: post.slug,\n  }));\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">可以看见，使用 RSC 后的页面相比于不使用 RSC 的页面大幅减少了代码长度。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但正因 RSC 是在 node 环境运行的，所以我们不能在 RSC 使用浏览器的 api，也无法使用 <code>useState</code>等 api，也就是说，RSC 不能直接响应用户的交互。而当我们需要调用浏览器api时，可以通过在组件代码前加上 <code>\"use client\";</code>将组件更改为客户端组件，就能调用浏览器api。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">值得一提的是，我们可以在RSC中引入客户端组件：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;div&gt;\n  This is a RSC\n  &lt;ClientComponent /&gt;\n&lt;/div&gt;</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但我们不能在客户端组件内引入RSC：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;ClientComponent&gt;\n  &lt;ServerComponent /&gt;\n&lt;/ClientComponent&gt;</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但我们依然有办法在客户端组件内直接调用RSC。前文提到，RSC在渲染过程中需要node的参与，但是返回结果是相当于静态的，所以我们可以通过Props的方式向客户端组件传入RSC的返回值实现：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">&lt;ServerComponent&gt;\n  const res = &lt;AnotherSC /&gt;\n  &lt;ClientComponent aprop={res} /&gt;\n&lt;/ServerComponent&gt;</code></pre>\n<h2>布局优化： Next.js App Router</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在 Next.js 13 中，Next.js 新增了一种新的路由方式：<code>App Router</code>。它基于 <code>React Server Components</code>开发，支持共享布局，加载状态，嵌套路由，错误处理等。其中对我而言最重要的更新就是嵌套路由。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">App Router 将路由拆分为布局与内容两部分，其中布局支持嵌套，大大减少了代码冗余。例如我们要实现 AB 两个页面，二者都包含一个导航栏和一个侧边栏，B 页面在以上的基础下又包含其自身所需要的布局，即需要布局嵌套，在 <code>Pages Router</code>中，我们需要这样：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// A.tsx\nexport default function A() {\n  return (\n    &lt;LayoutA&gt;\n      &lt;Content /&gt;\n    &lt;/LayoutA&gt;\n  );\n}</code></pre>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// B.tsx\nexport default function B() {\n  return (\n    &lt;LayoutA&gt;\n      &lt;LayoutB&gt;\n        &lt;Content /&gt;\n      &lt;/LayoutB&gt;\n    &lt;/LayoutA&gt;\n  );\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">只有两层情况就已经如此糟糕，倘若有三层，四层.......代码的可读性将大大降低。但在 App Router 中，我们可以这样做:</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// app/a/layout.tsx\nexport default RootLayout({ children }: { children: ReactNode }) {\n  return (\n      &lt;html lang=\"zh-CN\"&gt;\n      &lt;body&gt;\n        &lt;NavBar /&gt;\n        &lt;div&gt;\n          &lt;LayoutA&gt;{children}&lt;/LayoutA&gt;\n        &lt;/div&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  )\n}</code></pre>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">// app/a/b/layout.tsx\nexport default LayoutB({ children }: { children: ReactNode }) {\n  return &lt;LayoutA&gt;{children}&lt;/LayoutA&gt;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">此时，b 页面的布局会自动继承 a 的布局，并在其基础上新增其自身布局，代码会十分简洁。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">除了语法更加简洁，我们也可以通过AppRouter实现共享布局。</p>\n<h2>服务端: 从 SSG 迈向 SSR</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在<a href=\"https://blog.redish101.top/post/blog-v5\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">「使用 Next.js 重构我的博客」</a>一文中我提到，我将博客核心所使用的 CMS 从 <code>Hexo</code>迁移到自研的基于文件的 CMS，在构建时使用 <code>Next.js Pages Router</code>提供的 <code>getStaticProps</code>等一系列 api 在构建时从本地获取文章并渲染，但在我迁移博客到 <code>Next.js App Router</code>时这样的做法无法通过构建，原因是 App Router 并不支持使用 <code>getStaticProps</code>等 api 获取数据。同时，在构建时渲染 Markdown 也会导致构建速度很慢，在考虑之下，我决定放弃 SSG，迈向 SSR。但现在依然有一个问题，现在服务端在收到请求后，会根据请求路径中的 slug 查找文章，并读取文章内容，但当文件不存在时，node 的 fs api 就会抛出错误，使 <code>getPostBySlug</code>方法没有返回任何内容，进而导致服务端返回 500，所以我们需要在 <code>getPostBySlug</code>方法中检测 slug 是否存在，若不存在则返回空对象而不是没有返回值：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">if (!fs.existsSync(fullPath)) {\n  return items;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在调用时检测返回对象是否包含 slug：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">if (!post.title) {\n  return notFound();\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\"><code>notFound()</code>是 Next.js 提供的方法，可以手动返回 404。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这时，我们再尝试访问不存在的文章，服务端会返回 404，而非 500。</p>\n<h2>元数据: 从 next/head 到 Next Metadata</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在 Pages Router 中，我们可以在页面中返回 <code>Head</code>组件自定义页面的元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import Head from \"next/head\";\n\nexport default function PageA() {\n  return (\n    &lt;Head&gt;\n      &lt;title&gt;Your Title&lt;/title&gt;\n    &lt;/Head&gt;\n  );\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">而在 App Router 中，我们可以通过导出 <code>metadata</code>的方法设置元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">import { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"Your Title\",\n};</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">简介等属性同理</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">除了静态导出，我们还可以通过导出 <code>generateMetadata</code>函数实现动态设置元数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export async function generateMetadata({\n  params,\n}: {\n  params: { slug: string };\n}): Promise&lt;Metadata&gt; {\n  const post = getPostBySlug(params.slug, [\"title\", \"content\"]);\n  if (!post.title) {\n    return {\n      title: `404 - ${config.name}`,\n    };\n  }\n  return {\n    title: `${post.title} - ${config.name}`,\n    description: post.content.slice(0, 200),\n  };\n}</code></pre>\n<h2>Markdown 渲染: 从 remark 到 marked</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在以往的版本中，我使用 <code>remark</code>完成 Markdown 的渲染，但我逐渐发现，remark 逐渐无法满足我的需求，所以更换到 <code>marked</code>。marked 支持自定义渲染器，可以更方便的修改渲染逻辑。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本站的 markdown 渲染被封装到了一个 <code>markdownToHtml</code>函数，所以更改渲染器十分方便：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">export default async function markdownToHtml(markdown: string) {\n  const renderer = new marked.Renderer();\n\n  renderer.code = function (code, language) {\n    // 添加hljs类和data-language属性\n    let lang = language ? language.toUpperCase() : \"\";\n    if (!language) {\n      lang = \"TEXT\";\n    }\n    if (language == \"\") {\n      language = \"plaintext\";\n    }\n    const highlightedCode = highlightjs(code, language);\n    return `&lt;pre class=\"hljs language-${lang}\" data-language=\"${lang}\"&gt;\n      &lt;code&gt;${highlightedCode}&lt;/code&gt;\n    &lt;/pre&gt;`;\n  };\n  return marked.parse(markdown, { mangle: false, headerIds: false, renderer });\n}</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">完整的渲染器代码较长，此处仅展示部分代码，可能无法单独使用</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">React 无法直接将 html 嵌入到组件作为子元素使用，但提供了属性 <code>dangerouslySetInnerHTML</code>供开发者显示 html 字符串，所以在这里可以这样写：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default async function Post({ params }: { params: { slug: string } }) {\n  const post = getPostBySlug(params.slug, [\n    \"title\",\n    \"date\",\n    \"slug\",\n    \"cover\",\n    \"content\",\n  ]);\n  if (!post.title) {\n    return notFound();\n  }\n  const content = await markdownToHtml(post.content || \"\");\n  return (\n    &lt;&gt;\n      &lt;Card title={post.title} cover={post.cover} label={post.date.toString()}&gt;\n        &lt;div&gt;\n          &lt;div&gt;{post.desc}&lt;/div&gt;\n          &lt;div dangerouslySetInnerHTML={{ __html: content }} /&gt;\n        &lt;/div&gt;\n      &lt;/Card&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<h2>代码高亮: 自定义主题</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以往版本中，正文部分所使用的代码高亮主题是由 <code>github-markdown-css</code>提供的，我逐渐发现其设计不满足我的需求，便进行了自定义。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">代码高亮配色我觉得没有必要更改，但是 <code>highlight.js</code>提供的主题不支持深色模式，我就不得不手写配色。我将包含深色模式的配色放到了全局变量中：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">:root {\n  --pre: #fafafa;\n  --pre-comment: #6a737d;\n  --pre-string: #032f62;\n  --pre-literal: #032f62;\n  --pre-keyword: #d73a49;\n  --pre-function: #6f42c1;\n  --pre-deleted: #24292e;\n  --pre-class: #22863a;\n  --pre-property: #005cc5;\n  --pre-namespace: #6f42c1;\n  --pre-punctuation: #24292e;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --pre-comment: #757575;\n    --pre-string: #977cdc;\n    --pre-literal: #c64640;\n    --pre-keyword: #77b7d7;\n    --pre-function: #86d9ca;\n    --pre-deleted: #fff;\n    --pre-class: #dfab5c;\n    --pre-property: #77b7d7;\n    --pre-namespace: #86d9ca;\n    --pre-punctuation: #fff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">然后在 highlight.js 提供的默认主题基础上做修改，将颜色从固定值改为变量：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.hljs {\n  color: var(--text);\n  background: var(--pre);\n}\n.hljs-doctag,\n.hljs-keyword,\n.hljs-meta .hljs-keyword,\n.hljs-template-tag,\n.hljs-template-variable,\n.hljs-type,\n.hljs-variable.language_ {\n  color: var(--pre-keyword);\n}\n.hljs-title,\n.hljs-title.class_,\n.hljs-title.class_.inherited__,\n.hljs-title.function_ {\n  color: var(--pre-function);\n}</code></pre>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">此处因篇幅原因只展示部分</p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">原有代码块并没有直接显示语言，容易产生歧义。出现了以下设计方案：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230712213628.png\" alt=\"两种方案\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">显然第一种更显眼并具有设计感。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">具体实现我使用了 <code>before</code>伪类的方式，通过 <code>attr(data-language)</code>读取自定义渲染器所输入的语言名称：</p>\n<pre class=\"language-ts lang-ts\"><code class=\"language-ts lang-ts\">return `&lt;pre class=\"hljs language-${lang}\" data-language=\"${lang}\"&gt;\n      &lt;code&gt;${highlightedCode}&lt;/code&gt;\n    &lt;/pre&gt;`;</code></pre>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">pre::before {\n  color: var(--text-l);\n  opacity: 0.25;\n  content: attr(data-language);\n  font-size: 1.625rem;\n  font-weight: 700;\n  position: absolute;\n  right: 0.5rem;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">至此完成了代码块的修改。</p>\n<h2>CSS: Atomic CSS In JS</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">传统的css在使用重复布局时回产生大量冗余，例如以下三个类：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.a {\n  padding: 1.125rem;\n  color: pink;\n}\n\n.b {\n  padding: 1.125rem;\n  color: skyblue;\n}\n\n.c {\n  margin: 1.125rem;\n  color: pink;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">可以看见，<code>pading: 1.125rem</code>与 <code>color: pink</code>被在css中出现了多次，现在这个css文件共有6个属性。我们可以将它们拆分，封装成4个类：</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">.p-125 {\n  pading: 1.125rem;\n}\n\n.color-pink {\n  color: pink;\n}\n\n.color-skyblue {\n  color: skyblue;\n}\n\n.m-125 {\n  margin: 1.125rem;\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在html中我们可以直接使用这些类的组合实现与第一种方式相同的效果，这就是原子化css。使用原子化设计的css只出现了4个属性。不难看出，原子化css能够减少css的体积。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在实际使用中，我们往往会使用已经绑定好的原子化css库，例如tailwindcss等。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">但是，这种做法会导致代码中有一大串的类名，显然不够优雅。所以，我使用了 <code>style9</code>，实现atomic css in js，您可以打开devtools查看效果。</p>\n<h2>布局设计: 拥抱双飞翼</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以往版本的博客使用单栏设计，只留出中间一栏展示所有信息，这样做实现简单，但会导致比较单调。在新博客的设计中，我采用了「双飞翼」布局，即三栏布局：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131357.png\" alt=\"三栏布局\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">将布局拆分为 <code>Sidebar</code>与 <code>Content</code>，使用Next App Router可以实现路由跳转只加载 <code>Content</code>。具体实现使用 <code>CSS Flex</code>布局。</p>\n<h2>基础设计: Card</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如你所见，本站现在的所有组件都是卡片，基础是一个具有 <code>title</code>，<code>label</code>，<code>content</code>，<code>size</code>，<code>cover</code>等众多属性的组件：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230713131238.png\" alt=\"布局演示\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以此保证样式的统一。</p>\n<h2>深色模式: CSS变量</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">深色模式能够提高用户体验，为了实现深色模式，我为深色模式单独设计了配色，并通过 <code>@media (prefers-color-scheme: dark)</code>实现根据系统设置自动切换。</p>\n<h2>友情链接: 从静态到动态</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">以往的友情链接是静态储存的，这样做难免会有局限性，在新版博客中，我将友情链接数据迁移到了GitHub仓库，并通过 <code>Chuqi CDN</code>实时获取友情链接信息。</p>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">你想与101互换友情链接吗，那就看看下面的步骤吧</p></blockquote>\n<h3>前置条件</h3>\n<ul>\n<li>友情链接，先友后链，所以最好是101比较眼熟的朋友</li>\n<li>您的网站不是免费域名，包括但不限于：\n<ul>\n<li>由Freenom公司运营的 <code>.tk</code>，<code>.ml</code>等免费域名（不包括付费购买的域名）</li>\n<li>由 Joshua Anderson 运营的 Afraid FreeDNS 提供的免费子域名</li>\n<li>其他不包含在 Public Suffix List 中的 <strong>免费子域名</strong> 服务</li>\n<li>\n<code>*.github.io</code>，<code>*.gitee.io</code>等域名</li>\n</ul>\n</li>\n<li>不能是采集站！！！！！！！！！</li>\n<li>有三篇以上的原创文章（包括三篇）</li>\n<li>站点上有我的链接</li>\n</ul>\n<h3>我的信息</h3>\n<pre class=\"language-json lang-json\"><code class=\"language-json lang-json\">{\n  \"name\": \"Redish101 Blog\",\n  \"desc\": \"人文 科技 白日梦\",\n  \"icon\": \"https://blog.redish101.top/favicon.ico\",\n  \"link\": \"https://blog.redish101.top\"\n}</code></pre>\n<h3>添加</h3>\n<blockquote><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">仓库: <a href=\"https://github.com/Redish101/friend-links\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">https://github.com/Redish101/friend-links</a></p></blockquote>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如果你满足前置条件，就可以开始提交。</p>\n<ol start=\"1\">\n<li>Fork本仓库</li>\n<li>更改data.json</li>\n<li>添加你的网站</li>\n<li>向本仓库提交pr</li>\n<li>等待审核</li>\n<li>审核完成后将会在Redish101 Blog下次构建时生效</li>\n</ol>\n<h2>尾声</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">感谢阅读</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/migrate-my-blog-to-nextjs-app-router-and-react-server-components#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1689195790}, {"title": "Termux 安装xLog", "author": "Utermux博客", "pubDate": "2023-05-06 10:04:00", "link": "https://blog.utermux.dev/ut/xLog.html", "description": "Termux 安装xLog", "categories": [], "time": 1683338640}, {"title": "Termux安装各版本gcc", "author": "Utermux博客", "pubDate": "2023-04-30 08:32:00", "link": "https://blog.utermux.dev/ut/gcc.html", "description": "Termux安装各版本gcc", "categories": [], "time": 1682814720}, {"title": "Termux安装Vscode以及code-server", "author": "Utermux博客", "pubDate": "2023-04-30 08:29:15", "link": "https://blog.utermux.dev/ut/vscode.html", "description": "Termux安装Vscode以及code-server", "categories": [], "time": 1682814555}, {"title": "为我的网站添加深色模式", "author": "Redish101博客", "pubDate": "2023-03-28 13:06:55", "link": "https://blog.redish101.top/article/darkmode", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/darkmode\">https://blog.redish101.top/article/darkmode</a>\n</blockquote>\n<div>\n<h2>我们为什么需要「深色模式」</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">不可避免的，我们在很多时候需要在黑暗的环境下访问网站，而在黑暗的环境下，如果网站依然有大部分亮色区域，会在瞬间使眼睛受到刺激，极大的降低了用户体验。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">同时，深色模式能减少OLED屏幕的功耗，延长设备的使用时间这也是很多人在白天也依然打开深色模式的原因。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">如今，很多操作系统已经支持了深色模式，macos也提供了很好的深色模式支持。Chrome、FireFox等主流浏览器也已经支持通过 <code>prefers-color-scheme</code>单独定义深色模式下的样式，这也降低了我们制作深色模式的难度。</p>\n<h2>「深色模式」的切换逻辑</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">前面提到，我们可以通过 <code>prefers-color-scheme</code>来单独定义深色模式的样式，而 <code>prefers-color-scheme</code>是跟随系统的，显然，这种方式可以较好符合用户的个人喜好。</p>\n<h3>\n<code>prefers-color-scheme</code>的兼容问题</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">的确，<code>prefers-color-scheme</code>对于低版本的浏览器适配并不友好，但是考虑到本站用户群体，这种问题几乎不会发生(其实是我懒)，所以就没有做过多处理。</p>\n<h2>「深色模式」的前端实现</h2>\n<h3>单独编写样式</h3>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">body {\n  color: #000;\n}\n\n@media (prefers-color-scheme: dark) {\n  body {\n    color: #fff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">显然，这种方式繁琐且复杂。</p>\n<h3>使用CSS Variable</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本站的配色信息都是以CSS Variable的形式存放在一个单独的css(global.css)中的，并在其他的css文件中可以直接通过 <code>var(xxxx)</code>引用，所以，我们可以为深色模式和亮色模式设计两种配色，并通过第一种方法实现，就可以实现自动的深色模式切换。</p>\n<pre class=\"language-css lang-css\"><code class=\"language-css lang-css\">:root {\n  --bg: #f2f5f8;\n  --card-bg: #fff;\n  --text: #000;\n  --link: #007bff;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --bg: #0d1117;\n    --card-bg: #161b22;\n    --text: #c9d1d9;\n    --link: #58a6ff;\n  }\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本站就是用的这种方法，在你的系统设置中切换配色即可体验。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/darkmode#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1679980015}, {"title": "文章更新说明", "author": "Chenxi", "pubDate": "2023-03-21 00:07:24", "link": "https://chenxi.in/post/wzgxsm/", "description": "<p>由于最近有点高产，花在实验上的时间比重很大，文章还没来得及精修，如有纰漏还请各位看官海涵<br><em>部分文章会有小更新和小修改</em></p>", "categories": [], "time": 1679328444}, {"title": "使用Next.js重构我的博客", "author": "Redish101博客", "pubDate": "2023-03-04 04:33:10", "link": "https://blog.redish101.top/article/refactor-my-blog-with-next", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193114.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193416.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/refactor-my-blog-with-next\">https://blog.redish101.top/article/refactor-my-blog-with-next</a>\n</blockquote>\n<div>\n<h2>技术选型</h2>\n<h3>React VS Vue</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在这两者之间，我对React的使用更加熟练些，而且我认为使用TSX开发React应用的体验是愉悦的，所以选择React。</p>\n<h3>Gatsby VS Next.js</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这两者都是十分优秀的React框架，但我一直无法成功配置Gatsby环境，而且考虑到应用以后可能使用服务端渲染，所以选择Next.js。</p>\n<h3>SSR VS SSG</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">博客目前并没有一些复杂的功能需要使用SSR实现，为了节省性能，选择了Next.js的SSG（以后会计划开发管理后台，所以以后可能会更换为SSR）。</p>\n<h2>UI设计</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">为了提高界面主题的美观，降低实现的难度，我设计了较为简单（简陋）的ui，并做了移动端适配，尽量让移动端的用户能有较好的体验。</p>\n<h2>内容管理</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">最开始，我准备效仿苏卡卡，使用hexo管理文章，但在进行一段时间的开发后，发现我对hexo api的了解无法满足使用。最后，我选择将文章储存为Markdown文件，并在每次更新后将其渲染为静态页面。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在众多Markdown渲染库中，我选择使用比较简单易用的 <code>remark</code>将markdown渲染为html：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">import { remark } from \"remark\";\nimport html from \"remark-html\";\n\nexport default async function markdownToHtml(markdown: string) {\n  const result = await remark().use(html).process(markdown);\n  return result.toString();\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">搞定正文的渲染，还有一个问题，由于并没有使用数据库文章信息，所以需要将文章信息放到 <code>front matter</code>内，再在构建时解析，转换为js能够读取的数据格式，并储存到页面的 <code>props</code>中，供前端使用。在处理 <code>front-matter</code>中，我选择了 <code>gray-matter</code>。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在读取Markdown并处理后，需要将文章数据传递给前端，供前端使用，但我并没有使用SSR，所以无法做到获取实时的文章数据，但得益于强大的Next.js，我们可以通过 <code>getStaticProps</code>，<code>getStaticPaths</code>在执行构建时获取数据，储存到props中，例如文章详情页的数据可以这样获取：</p>\n<pre class=\"language-typescript lang-typescript\"><code class=\"language-typescript lang-typescript\">export async function getStaticPaths() {\n  const posts = getAllPosts([\"slug\"]);\n\n  return {\n    paths: posts.map((post) =&gt; {\n      return {\n        params: {\n          slug: post.slug,\n        },\n      };\n    }),\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }: any) {\n  const post = getPostBySlug(params.slug, [\"title\", \"date\", \"slug\", \"content\"]);\n  const content = await markdownToHtml(post.content || \"\");\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content,\n      },\n    },\n  };\n}</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这样在前端就可以十分方便的使用数据：</p>\n<pre class=\"language-tsx lang-tsx\"><code class=\"language-tsx lang-tsx\">export default function Post(props: props) {\n  const router = useRouter();\n  const post = props.post;\n  const title = `${post.title} | Redish101 Blog`;\n  if (!router.isFallback &amp;&amp; !post?.slug) {\n    return &lt;Error404 /&gt;;\n  }\n  return (\n    &lt;&gt;\n      &lt;Head&gt;\n        &lt;title&gt;{title}&lt;/title&gt;\n      &lt;/Head&gt;\n      &lt;PostBody title={post.title} date={post.date} content={post.content} /&gt;\n    &lt;/&gt;\n  );\n}</code></pre>\n<h2>样式实现</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在众多css in js库中，我选择了 <code>griffel</code>，通过 <code>makeStyles()</code>定义样式， <code>useStyles()</code>使用样式。使用它定义样式，在编码过程中ide会给出效果较好的代码提示，且由于其类名经过了处理，不会导致不同组件类名重复导致的样式冲突：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193114.png\" alt=\"\"><p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在开发的过程中节约了很多时间，生成的随机类名可以很好的避免类名重复导致的错误：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20230304193416.png\" alt=\"\"><h2>一言</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在新版博客的首页，我将原来固定的副标题替换为从一言api获取一句质量较高的话作为副标题，数据的获取与文章数据的获取一样，都使用 <code>getStaticProps</code>在构建时获取，所以一言的更新频率完去取决于我的更新频率。</p>\n<h2>部署</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">网站的部署有以下几个选择：服务器部署，vercel，netlify。前面说过，本站是静态网站，所以如果选择服务器部署，在每次内容更新后都需要上传到服务器，浪费时间，即使使用ci，服务器由于地域原因也无法从GitHub拉取网站源码进行构建，所以率先出局。在vercel和netlify中我选择vercel，一是使用熟练，二是对Next.js有较好的支持，若是以后更改为ssr也很方便。</p>\n<h2>重构博客给我带来了什么</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Nextjs SSG网站的性能明显是要好于动态博客的，而且构建速度也比之前用Hexo的时候更快。而且自己造的轮子，自己肯定更熟悉，改起来也方便。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/refactor-my-blog-with-next#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1677875590}, {"title": "非4k显示器开启hidpi", "author": "Yume.KISEKI", "pubDate": "2023-02-11 04:29:27", "link": "https://www.monoko.jp/enable-hidpi/", "description": "\n<p>macOS想要完美体验hidpi只能是换上4k及以上显示器，如果用上苹果自家的6K Pro Display X […]</p>\n<p><a href=\"https://www.monoko.jp/enable-hidpi/\">非4k显示器开启hidpi</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "BetterDisplay", "hidpi", "macOS"], "time": 1676060967}, {"title": "Artalk公益服务 已阵亡", "author": "小N同学的博客", "pubDate": "2023-02-04 16:49:39", "link": "https://www.imcharon.com/1505/", "description": "自从4月15日以来，服务器经受了长期DDoS，目前已经彻底放弃抵抗了，没办法了。", "categories": ["往日余生", "公益服务"], "time": 1675500579}, {"title": "Pro App 教育套装", "author": "Yume.KISEKI", "pubDate": "2023-02-02 14:24:50", "link": "https://www.monoko.jp/pro-app/", "description": "\n<p>一个Final Cut Pro多少钱？是1998元 一个教育优惠套装多少钱？是1298元(前几年是1543元) […]</p>\n<p><a href=\"https://www.monoko.jp/pro-app/\">Pro App 教育套装</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "Apple教育优惠", "Final Cut Pro"], "time": 1675319090}, {"title": "memos纯公益代部署服务", "author": "小N同学的博客", "pubDate": "2023-02-02 03:01:14", "link": "https://www.imcharon.com/1467/", "description": "具体memos参考基于Memos实现说说和清单功能。 | Leonus 云备份，每天备份数据至onedrive […]", "categories": ["往日余生", "公益服务"], "time": 1675278074}, {"title": "windows手动安装哪吒探针客户端", "author": "wututu-blog", "pubDate": "2023-01-30 18:30:31", "link": "https://blog.wututu.cn/nztz-for-windows/", "description": "以针会友，几乎成了吃灰服务器的标配行为，得益于最近火起来的哪吒探针，我也搭建了自己的探针平台，数据直观且美观，兼具实用与装 13特 ...", "categories": ["未分类"], "time": 1675074631}, {"title": "网站迁移完成，如有BUG欢迎留言", "author": "wututu-blog", "pubDate": "2023-01-30 18:04:37", "link": "https://blog.wututu.cn/gx/", "description": "", "categories": ["未分类"], "time": 1675073077}, {"title": "一款好用的摄影包——Bellroy Venture Sling 10L", "author": "Yume.KISEKI", "pubDate": "2023-01-15 13:40:21", "link": "https://www.monoko.jp/bellroy-venture-sling-10l/", "description": "\n<p>终于还是灭门了佳能，转而马上投入大法的怀抱，真香。话说都2023年了确实早已是无反的时代了，还好我的5d4和它 […]</p>\n<p><a href=\"https://www.monoko.jp/bellroy-venture-sling-10l/\">一款好用的摄影包——Bellroy Venture Sling 10L</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["share", "Bellroy"], "time": 1673761221}, {"title": "Termux安装maturin模块", "author": "Utermux博客", "pubDate": "2023-01-09 06:15:00", "link": "https://blog.utermux.dev/ut/maturin.html", "description": "Termux安装maturin模块", "categories": [], "time": 1673216100}, {"title": "Termux安装mitmproxy", "author": "Utermux博客", "pubDate": "2022-12-26 07:08:00", "link": "https://blog.utermux.dev/ut/mitmproxy.html", "description": "Termux安装mitmproxy", "categories": [], "time": 1672009680}, {"title": "解决acme.sh签发SSL证书失败", "author": "Yume.KISEKI", "pubDate": "2022-12-18 04:39:26", "link": "https://www.monoko.jp/create-ssl-with-acme-sh/", "description": "\n<p>前段时间在甲骨文云成功开了台arm的机器后一直闲置没用，最近看到甲骨文云开始有回收清理白嫖机器的动作了，吓得我 […]</p>\n<p><a href=\"https://www.monoko.jp/create-ssl-with-acme-sh/\">解决acme.sh签发SSL证书失败</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["vps", "acme.sh"], "time": 1671309566}, {"title": "「古典文法」推量系の助動詞の関係性", "author": "Yume.KISEKI", "pubDate": "2022-12-04 07:34:51", "link": "https://www.monoko.jp/suiryokei-no-jyodoushi/", "description": "\n<p>不难发现在助动词中有那么一堆词都带有推定的意思，我们可以称之为推量系助动词，对于这些词之间的关系总结如下图，可 […]</p>\n<p><a href=\"https://www.monoko.jp/suiryokei-no-jyodoushi/\">「古典文法」推量系の助動詞の関係性</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["古典文法", "助动词", "推量系", "日语古文"], "time": 1670110491}, {"title": "好用的ssh客户端工具—electerm", "author": "Yume.KISEKI", "pubDate": "2022-11-30 14:13:22", "link": "https://www.monoko.jp/ssh-electerm/", "description": "\n<p>前段时间偶然发现一款开源ssh客户端——electerm，三大平台全能型，多语言支持，支持sftp并且能直接编 […]</p>\n<p><a href=\"https://www.monoko.jp/ssh-electerm/\">好用的ssh客户端工具—electerm</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["software", "electerm"], "time": 1669788802}, {"title": "异常低价的CleanMyMac X", "author": "Yume.KISEKI", "pubDate": "2022-11-20 02:30:00", "link": "https://www.monoko.jp/low-price-of-cleanmymac/", "description": "\n<p>近期需要用到笔记本电脑一段时间，也就突然想到还有台14款的mbp正好可以拿来用段时间，系统是一代代升级到了最终 […]</p>\n<p><a href=\"https://www.monoko.jp/low-price-of-cleanmymac/\">异常低价的CleanMyMac X</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["software", "CleanMyMac X"], "time": 1668882600}, {"title": "遭遇xmrig挖矿病毒", "author": "Yume.KISEKI", "pubDate": "2022-10-21 15:39:10", "link": "https://www.monoko.jp/cryptojacking-xmrig/", "description": "\n<p>起因 前段时间conoha为纪念突破50万用户大搞活动，看着优惠力度和近期的日元汇率是真的香！但太久没用con […]</p>\n<p><a href=\"https://www.monoko.jp/cryptojacking-xmrig/\">遭遇xmrig挖矿病毒</a>最先出现在<a href=\"https://www.monoko.jp/\">Yume.KISEKI</a>。</p>\n", "categories": ["vps", "xmrig"], "time": 1666337950}, {"title": "Linux/Windows系统安装最新版JAVA教程", "author": "wututu-blog", "pubDate": "2022-10-18 18:00:18", "link": "https://blog.wututu.cn/linux-windows-install-java/", "description": "<div class=\"wp-block-jetpack-markdown\">\n<h2>说明</h2>\n<p>我们很多时候都需要用到JAVA环境，这里博主就记录下安装过程。</p>\n<h2>1、获取最新版JAVA下载链接</h2>\n<p>首先进入JAVA下载地址：点击进入，再点击中间框框右下角的<code>JDK Download</code>按钮进入下载界面，然后点击<code>Accept License Agreement</code>，这时候就可以点击一下对应版本的<code>JAVA JDK</code>包，浏览器下载器会弹出来文件下载，这时候就可以复制下载链接了。\n注意别直接将<code>jdk</code>包的超链接当成下载链接，这样下载会出错的。</p>\n<h2>2、Linux安装</h2>\n<p>这里<code>CentOS</code>、<code>Debian</code>、<code>Ubuntu</code>等常见Linux系统都可以用以下方法安装JAVA。</p>\n<pre><code>#下载JAVA JRE包，将你获取的链接替换到后面，下载链接通常为http://xx/jdk_linux-x64.tar.gz?AuthParam=xx\nwget -O jdk.tar.gz http://xx/jdk_linux-x64.tar.gz?AuthParam=xx\n#解压文件\ntar -zxvf jdk.tar.gz\n#记住这时候解压出的文件夹路径，比如目前为/root/jdk1.8.0_191\n</code></pre>\n<p>编辑<code>/etc/profile</code>文件：</p>\n<pre><code>编辑/etc/profile文件：\n</code></pre>\n<p>在后面添加以下代码：</p>\n<pre><code>#前2行后面的参数为解压出的JAVA文件夹路径\nJAVA_HOME=/root/jdk1.8.0_191\nexport JRE_HOME=/root/jdk1.8.0_191/jre \nexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH \nexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH\n</code></pre>\n<p>使配置生效：</p>\n<pre><code>source /etc/profile\n</code></pre>\n<p>查看JAVA版本：</p>\n<pre><code>java -version\n</code></pre>\n<h2>3、Windows系统安装</h2>\n<p>获取JAVA JRE包的方法参考上面，然后直接下载Win版本的点击安装即可。</p>\n</div>", "categories": ["教程", "软件"], "time": 1666087218}, {"title": "Linux VPS一键添加/删除Swap虚拟内存", "author": "wututu-blog", "pubDate": "2022-10-17 17:55:42", "link": "https://blog.wututu.cn/linux-vps-swap/", "description": "\n<div class=\"wp-block-jetpack-markdown\">\n<h2>脚本</h2>\n<p>提示：脚本不支持<code>OpenVZ</code>架构，安装会自动退出。\n运行命令：\n国外机器</p>\n<pre><code>wget https://cdn.jsdelivr.net/gh/wututua/file@master/swap.sh &amp;&amp; bash swap.sh\n</code></pre>\n<p>国内机器</p>\n<pre><code>wget https://gitee.com/wututua/file-storage-warehouse/raw/master/swap.sh &amp;&amp; bash swap.sh\n</code></pre>\n<p>然后根据选项进行操作，记得添加<code>swap</code>的时候填写纯数字，默认单位为<code>M</code>。</p>\n</div>\n\n\n\n<figure class=\"wp-block-image size-large\"><img decoding=\"async\" src=\"https://i0.wp.com/cdn.jsdelivr.net/gh/wututua/image@master/img/swap_add.png?w=640&amp;ssl=1\" alt=\"\" data-recalc-dims=\"1\"></figure>\n", "categories": ["未分类"], "time": 1666000542}, {"title": "主流 Markdown 编辑器推荐", "author": "wututu-blog", "pubDate": "2022-10-16 17:54:57", "link": "https://blog.wututu.cn/markdown/", "description": "开头 Markdown ，2004年由 John Gruberis 设计和开发，是一种可以使用普通文本编辑器编写的标记语言，通过简 ...", "categories": ["软件"], "time": 1665914097}, {"title": "iptables一键配置端口转发脚本，支持tcp和udp", "author": "wututu-blog", "pubDate": "2022-10-15 17:50:01", "link": "https://blog.wututu.cn/iptables/", "description": "<div class=\"wp-block-jetpack-markdown\">\n<h2>iptables</h2>\n<p>iptables是一款非常强大的防火墙管理工具，同样支持端口转发，同时也支持端口段转发。上一篇文章使用iptables进行端口转发配置对于小白非常不友好，自然在网络上面找到了一键脚本，对小白非常友好，可视化的UI配置界面。</p>\n<h2>系统要求</h2>\n<p>支持Centos / Debian / Ubuntu 14.04 +\n推荐 Debian / Ubuntu，这个是我一直使用的系统，我的脚本在这个系统上面出错率最低。\nCentOS 7 默认的防火墙是 firewall，要使用本脚本，请先卸载或关闭 firewall 服务器，并安装 iptables 全套软件。</p>\n<h2>安装说明</h2>\n<p>下载iptables一键配置端口转发脚本，并赋予执行权限运行</p>\n<pre><code>wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/iptables-pf.sh &amp;&amp; chmod +x iptables-pf.sh &amp;&amp; bash iptables-pf.sh\n</code></pre>\n<p>下载并运行脚本后，先选择 1. 安装 iptables ，会检测是否安装 iptables 同时也会进行 iptables 防火墙开机启动加载等配置。</p>\n<h2>使用方法</h2>\n<pre><code>./iptables-pf.sh\n</code></pre>\n<p>运行脚本后，会显示菜单：</p>\n<pre><code>iptables 端口转发一键管理脚本 [vx.x.x]\n \n-- Toyo | doub.io/wlzy-20 --\n \n0. 升级脚本\n \n————————————\n \n1. 安装 iptables\n \n2. 清空 iptables 端口转发\n \n————————————\n \n3. 查看 iptables 端口转发\n \n4. 添加 iptables 端口转发\n \n5. 删除 iptables 端口转发\n \n————————————\n</code></pre>\n<p>注意：初次使用前请请务必执行 1. 安装 iptables(不仅仅是安装)\n请输入数字 [0–5]:\n选择 <code>4. 添加 iptables</code> 端口转发 后，会提示你依次输入 欲转发IP、欲转发端口、本地监听端口、本地IP、转发类型：</p>\n<pre><code>(默认端口: 10000-11000):\n \n本地监听端口 : 10000-11000\n \n请输入 本服务器的 公网IP网卡IP(注意是网卡绑定的IP，而不仅仅是公网IP，回车自动检测):\n \n本服务器IP : 1.1.1.1\n \n请输入数字 来选择 iptables 转发类型:\n \n1. TCP\n \n2. UDP\n \n3. TCP+UDP\n \n(默认: TCP+UDP):\n \n——————————————————————————————\n \n请检查 iptables 端口转发规则配置是否有误 !\n \n本地监听端口 : 10000-11000\n \n服务器 IP : 2.2.2.2\n \n欲转发的端口 : 10000-11000\n \n欲转发 IP : 1.1.1.1\n \n转发类型 : TCP+UDP\n \n——————————————————————————————\n</code></pre>\n<p>最后会提示你确认配置是否有误，如果没有问题就按任意键继续，启动成功后就会提示：</p>\n<pre><code>——————————————————————————————\n \niptables 端口转发规则配置完成 !\n \n本地监听端口 : 10000:11000\n \n服务器 IP : 1.1.1.1\n \n欲转发的端口 : 10000:11000\n \n欲转发 IP : 2.2.2.2\n \n转发类型 : TCP+UDP\n \n——————————————————————————————\n</code></pre>\n<p>选择 <code>3. 查看 iptables 端口转发</code> 后，会显示如下：</p>\n<pre><code>当前有 2 个 iptables 端口转发规则。\n \n1. 类型: tcp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000\n \n2. 类型: udp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000\n</code></pre>\n<p>选择 <code>5. 删除 iptables 端口转发</code> 后，也会显示列表，然后让你选择 要删除的端口转发规则序号。\n就这些啦</p>\n</div>", "categories": ["教程"], "time": 1665827401}, {"title": "Navicat Premium 12安装教程(完整激活版)", "author": "wututu-blog", "pubDate": "2022-10-14 17:49:00", "link": "https://blog.wututu.cn/navicat-premium-12/", "description": "开始 本文所有文件下载 下载地址1 下载地址2 1.安装 1.双击安装，点击下一步： 2.同意协议，点击下一步： 3.选择安装位置 ...", "categories": ["破解"], "time": 1665740940}, {"title": "Navicat Premium 15安装教程(完整激活版)", "author": "wututu-blog", "pubDate": "2022-10-08 17:45:00", "link": "https://blog.wututu.cn/navicat-premium-15/", "description": "写在前面 之前一直忙着工作，趁着休假，加上身边的小伙伴想尝鲜一把最新版的Navicat Premium 15，官网说，最新一版的N ...", "categories": ["未分类"], "time": 1665222300}, {"title": "[通知] 我们的Termux镜像", "author": "Utermux博客", "pubDate": "2022-07-19 08:47:00", "link": "https://blog.utermux.dev/ut/mirror.html", "description": "[通知] 我们的Termux镜像", "categories": [], "time": 1658191620}, {"title": "Github Codespaces初体验", "author": "Redish101博客", "pubDate": "2022-06-19 10:52:04", "link": "https://blog.redish101.top/article/github-codespace", "description": "\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610210634.png\">\n<link rel=\"preload\" as=\"image\" href=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610211120.png\">\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/github-codespace\">https://blog.redish101.top/article/github-codespace</a>\n</blockquote>\n<div>\n<h1>这是什么</h1>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在去年，GitHub上线了一个的新功能：<code>Codespaces</code>，使用Codespaces可以随时随地在浏览器里编辑、调试、运行托管在GitHub的代码。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">在前几天，GitHub将此功能开放公测，任何用户都能申请使用，我，于是就有了这篇文章。</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610210634.png\" alt=\"邮件\"><h1>性能</h1>\n<h2>硬件配置</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">先说性能，GitHub面对个人项目提供了一台4Cores 8RAM的设备，这性能对于普通的开发那是绰绰有余，话不多说，上bench截图：</p>\n<img src=\"https://jsd.onmicrosoft.cn/gh/Redish101/cdn@src/img/20220610211120.png\" alt=\"测试结果\"><h2>网络</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">配置虽好值得夸赞，但这网络之遭也十分的影响使用，在笔者试用的时候，2个小时中断线了将近十次。虽然大部分时间下编辑器的使用没有发现明显卡顿，但终端在使用时的卡顿是真的让人无法忍受。</p>\n<h2>终端相关</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Github Codespaces的终端是可以通过 <code>sudo su</code>进入root用户的，也可以直接通过 <code>sudo</code>命令来运行需要root权限的服务。</p>\n<h2>自动休眠</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这是非常重要的一个点，是我们白嫖之路的最大绊脚石，在一段时间（暂未明确结果）内如果编辑器没有活跃，codespace就会自动关闭。</p>\n<h1>写代码</h1>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">Codespaces使用了web版本的VS Code，所以说编辑体验是与直接在本地使用Code编辑并无不同，经过测试，也能完美的适配各种插件。运行时方面也无需担心，已经自动预装了docker、python、node、c/cpp等大部分语言的开发环境。</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">同时，如果在终端里启动程序的开发服务器时编辑器会自动发现开放的端口并映射到公网，默认是私有的，只有codespace的所有者才能访问，但是可以在图中的这个位置中更改穿透为对外公开，但是101奉劝各位早点死了用这个搭建什么服务的心吧，同GitHub一样，几乎是无法访问，在速度这方面，甚至比不上GitHub Pages。</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/github-codespace#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1655607124}, {"title": "你问我答 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-05-25 14:28:40", "link": "https://www.594594.xyz/2022/05/25/xqa/", "description": "<p>一个适用hoshinobot的你问我答插件</p>", "categories": ["hoshino插件", "功能拓展"], "time": 1653460120}, {"title": "适用小白的快速搭建QQ机器人的超详细教程(可选带马娘插件)2023-10-13更新", "author": "轻音时雨的博客", "pubDate": "2022-03-05 03:10:37", "link": "https://www.594594.xyz/2022/03/05/uma_bot/", "description": "<p>适用小白的快速搭建一个QQ机器人(可选带马娘插件)</p>", "categories": ["游戏相关", "教程", "赛马娘"], "time": 1646421037}, {"title": "docsify - 一个优雅的静态文档生成器", "author": "Redish101博客", "pubDate": "2022-03-04 16:00:00", "link": "https://blog.redish101.top/article/docsify", "description": "\n<p></p>\n<blockquote>本文该渲染由 reblog 前端生成，可能存在排版问题，最佳体验请前往：<a href=\"https://blog.redish101.top/article/docsify\">https://blog.redish101.top/article/docsify</a>\n</blockquote>\n<div>\n<h2>docsify好在哪里</h2>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">docsify相比于其他的静态文档站点生成器相比更加的简洁，易用。</p>\n<h4>Sphinx</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">先拿Sphinx来说吧，Sphinx因背后有python的驱动，功能十分强大，但是rst的语法还是比较复杂的</p>\n<h4>Vuepress</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">vuepress更适合大型项目的文档编写，而且维护成本高。</p>\n<h2>使用</h2>\n<h3>安装</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">全局安装Docsify-cli:</p>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">yarn global add docsify-cli\n# 或者使用npm</code></pre>\n<h3>开始一个项目</h3>\n<pre class=\"language-bash lang-bash\"><code class=\"language-bash lang-bash\">docsify init &lt;项目路径&gt;</code></pre>\n<h3>配置</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">本文不再对配置方面进行过多的论述，可以参考<a href=\"https://docsify.js.org/#/zh-cn/configuration\" target=\"_blank\" class=\"link\" data-sentry-component=\"MLink\" data-sentry-source-file=\"Link.tsx\">配置项 (docsify.js.org)</a></p>\n<h3>编写</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">docsify会自动识别目录下的所有markdown文件，所以在docs目录新增markdown文件即可编写文档</p>\n<h4>路径问题</h4>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">这里要注意一下路径：</p>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">假设你的目录结构如下：</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">.\n└── docs\n├── README.md\n├── guide.md\n└── zh-cn\n├── README.md\n└── guide.md</code></pre>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">那么渲染后的路径就是：</p>\n<pre class=\"language-text lang-text\"><code class=\"language-text lang-text\">docs/README.md        =&gt; http://domain.com\ndocs/guide.md         =&gt; http://domain.com/guide\ndocs/zh-cn/README.md  =&gt; http://domain.com/zh-cn/\ndocs/zh-cn/guide.md   =&gt; http://domain.com/zh-cn/guide</code></pre>\n<h2>部署</h2>\n<h3>Github Pages</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">将Github Pages的工作目录设置到docsify所在目录。</p>\n<h3>Vercel</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">选中docsify所在仓库，点击下面的deploy</p>\n<h3>服务器</h3>\n<p class=\"paragraph\" data-sentry-component=\"MParagraph\" data-sentry-source-file=\"Paragraph.tsx\">将docsify所在文件夹上传到网站目录即可</p>\n</div>\n<p><a href=\"https://blog.redish101.top/article/docsify#twikoo\">看完了？点击发送评论</a></p>\n", "categories": [], "time": 1646380800}, {"title": "马娘功能插件整合版v2.0.1 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-03-04 07:36:40", "link": "https://www.594594.xyz/2022/03/04/uma_plugin/", "description": "<p>一个适用hoshinobot的马娘功能插件整合版</p>", "categories": ["hoshino插件", "赛马娘"], "time": 1646350600}, {"title": "赛马娘模拟抽卡 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2022-02-05 03:43:40", "link": "https://www.594594.xyz/2022/02/05/uma_gacha_for_hoshino/", "description": "<p>一个适用hoshinobot的赛马娘模拟抽卡插件</p>", "categories": ["hoshino插件", "赛马娘"], "time": 1644003820}, {"title": "ZeroTier One搭建MOON服务器", "author": "轻音时雨的博客", "pubDate": "2022-02-03 03:30:40", "link": "https://www.594594.xyz/2022/02/03/moon_for_zerotier/", "description": "<p>完美解决Tabletop等和好友P2P联机延迟高的解决办法及相关踩坑</p>", "categories": ["游戏相关"], "time": 1643830240}, {"title": "Windows实用小工具教程", "author": "Utermux博客", "pubDate": "2022-01-23 07:55:00", "link": "https://blog.utermux.dev/win/Windows-utilities.html", "description": "Windows实用小工具教程", "categories": [], "time": 1642895700}, {"title": "UTermux/ZeroTermux/TermuxWatch下载链接", "author": "Utermux博客", "pubDate": "2021-12-26 06:53:00", "link": "https://blog.utermux.dev/ut/download.html", "description": "UTermux/ZeroTermux/TermuxWatch下载链接", "categories": [], "time": 1640472780}, {"title": "早安晚安 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:16:12", "link": "https://www.594594.xyz/2021/10/24/good_morning_for_hoshino/", "description": "<p>一个适用hoshinobot的 早安晚安 插件</p>", "categories": ["hoshino插件", "pcr"], "time": 1635016572}, {"title": "pcr签到黄历 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:09:12", "link": "https://www.594594.xyz/2021/10/24/pcr_almanac_for_hoshino/", "description": "<p>一个适用hoshinobot的 pcr签到黄历 插件</p>", "categories": ["hoshino插件", "pcr"], "time": 1635016152}, {"title": "mc数据查询监控 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-10-24 03:00:12", "link": "https://www.594594.xyz/2021/10/24/mc_status_for_hoshino/", "description": "<p>一个适用hoshinobot的 mc数据查询监控 插件</p>", "categories": ["hoshino插件", "mc"], "time": 1635015612}, {"title": "github仓库更新提醒 for HoshinoBot", "author": "轻音时雨的博客", "pubDate": "2021-08-23 04:00:12", "link": "https://www.594594.xyz/2021/08/23/github_reminder_for_hoshino/", "description": "<p>一个适用hoshinobot的 github仓库更新提醒 插件</p>", "categories": ["hoshino插件", "github"], "time": 1629662412}, {"title": "职场浮生纪修改器发布", "author": "小N同学的博客", "pubDate": "2021-08-08 17:59:53", "link": "https://www.imcharon.com/54/", "description": "先打开游戏，然后使用管理员身份启动修改器即可。 之前能改很多东西的，现在为什么只能加钱了。 -因为很多基址当时 […]", "categories": ["往日余生", "教程", "精选", "修改器", "职场浮生纪"], "time": 1628416793}]